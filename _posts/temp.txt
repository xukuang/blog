这篇文章记录的是在使用R的过程中偶然遇到的非常实用的函数，然而由于这些函数在自己的学习中太常用特别容易忘记，所以这里记下来以便以后使用的时候可以查看。学无止境，长期更新。
## 场景一
在查看多个变量之间的两两相关性的是时候，用到的picante包中的cor.table()函数。
## 场景二
在R中加载了不同R包的时候，希望查看当前环境中都加载了哪些R包的find.package()函数，临时卸载某个R包可以使用函数detach(package:报名)。如要卸载dplyr包，则为detach(package:dplyr)。
## 场景三
expand.grid()用来建立一些factor相乘出来的矩阵或data.frame。
## 场景四
with()和within()不用在输入长长的数据框名字了。within区别于with地方在于，within直接在原始的数据框上新增一列。例如，在data新增两列y1和y2，可以用data =  within(data, {y1= x + 1; y2 = x + 3})。
## 场景五
cut()函数可以把连续变量离散化，即numeric型的数据转换成factor型，可以与table()函数一起使用。
```
cut(x, breaks, labels = NULL,
    include.lowest = FALSE, right = TRUE, dig.lab = 3,
    ordered_result = FALSE, ...)
```
**主要参数**
x: 需要离散化的连续型向量
breaks: 向量类型，指定分类指标。默认的情况下，左开右闭合，这里可以结合正无穷(+Inf)和负无穷使用
labels：向量类型，指定分类指标的名称。如果不限定，则默认用分类指标为名称
inlude.lowest: 逻辑类型，指定边界是否闭合，默认的是边界不闭合
right: 逻辑类型，指定左开右闭合还是右开左闭合，默认的是TURE，左开右闭合
dig.lab: 数字，指定分类指标名称的数字位数。默认情况下，当labels为NULL时，指标名称的数字只显示3位
orederd_result: 逻辑类型，指定分类指标是否有序
```
cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf))
	#  [1] <NA>     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] <NA>     (5,Inf] 
	# Levels: (1,2.22] (2.22,5] (5,Inf]
## 边界闭合，即包含左端的1
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), include.lowest = T)
	#  [1] [1,2.22] (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  [1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] [1,2.22] (5,Inf] 
	# Levels: [1,2.22] (2.22,5] (5,Inf]
## 左闭合右开
cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), right = F)
	#  [1] [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [5,Inf)  [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [2.22,5) [1,2.22) [5,Inf) 
	# Levels: [1,2.22) [2.22,5) [5,Inf)
## 指定分类名称
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), labels = c('small', 'middle', 'big'))
	#  [1] <NA>   middle middle big    big    small  middle big    big    middle <NA>   big   
	# Levels: small middle big
## 分类指标有序
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), ordered_result = T)
	#  [1] <NA>     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] <NA>     (5,Inf] 
	# Levels: (1,2.22] < (2.22,5] < (5,Inf]
```
## 场景六
求导数的函数。dxy=deriv(f~x^2+y^2,c('x','y'),func=T) 
## 场景七
split()函数能将数据框按某一列分为包含若干个数据框的列表。然后，unsplit()可以将这个列表合并。