---
layout: post
title: "Numpy包的学习"
description: 
date: 2016-04-27 13:04:53
categories: [技术篇]
tags: [ python, numpy]
styles: [ data-table ]
---
Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。其实它 本身并没有提供多么高级的数据结构和分析功能，但它是很多高级工具（如 pandas）构建的基础，在结构和操作上具有统一性，因此理解 Numpy 的数组及面向数组的计算有助于更加高效地使用诸如 pandas 之类的工具。

Numpy 的核心内容是它的多维数组对象——ndarray（N-Dimensions Array），整个包几乎都是围绕这个对象展开。

### ndarray：多维数组对象
Numpy 的 ndarray 提供了一种将同质数据块解释为多维数组对象的方式。同质，表示数组的元素必须都是相同的数据类型（如 int，float 等）；解释，表示 ndarray 的数据块其实是线性存储的，并通过额外的元信息解释为多维数组结构。

```
import pandas as pd
array1 = np.array([[ 0.9526, -0.246 , -0.8856], 
				   [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
```

上面是一个 2×3 的矩阵。在使用类似 2×3×4...这种格式表示多维数组的结构时，从左向右的数字对应表示由表及里的维度，或称为轴，按索引给轴编号后可称为“轴 0”、“轴 1”和“轴2”等）。

```
array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
array1.strides
	## (24, 8)
```
这个矩阵的形状（shape）是（2,3）或 2×3，即它有 2 个长度为 3 的一维数组；它的 dtype 是 float64 表示它的单位元素是占 8 字节的浮点型；跨度（strides）元组指的是在某一维度下为了获取到下一个元素需要“跨过”的字节数。可见跨度是可以由 形状+dtype 来确定的。显然这种同质的静态数据结构在进行数值运算时效率要比 Python 内建的可以混杂动态类型的列表要快得多。

### ndarray对象的创建
创建数组的方法是使用array( )函数。它接受一切序列对象，产生一个包含所传递的数据的新ndarry数组，维度视序列的嵌套深度而定。首先，列表就是一个很好的用于转换的候选。

```
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
```

嵌套序列，如等长列表的列表，将会转化为一个多维数组。

```
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
```
数组的 dtype 会由系统自动推定，除非你显式传递一个参数进去。系统一般会默认使用 int32 或 float64。
除 array() 之外，还有许多函数来创建新的数组。

**数组构建函数**

| 函数 | 描述 |
| :------------- |:-------------|
| array | 转换输入数据（列表，数组或其它序列类型）为ndarray，可以推断一个dtype或明确的设置一个dtype，默认拷贝输入数据 |
| asarray | 将输入转换为 ndarray，若输入本身是 ndarray 就不拷贝 |
| arange | 同内建的range函数，但不返回的不是列表而是一个一维的ndarray |
| ones, ones_like | 根据提供的shape和dtype产生一个全1的数组；ones_like使用另一个数组为参数，产生一个shape和dtype都相同的数组 |
| zeros, zeros_like | 同ones和ones_like，但是生成一个全0的数组 |
| empty, enpty_like | 创建新数组，但只分配内存空间不赋值 |
| eye, identity | 创建一个NxN的单位方阵（对角线上为1，其余为0） |

例如，zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。

```
np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
```
在 pandas 中尽量不要使用 np.empty()，这个函数创建的数组里面是有值的，除非你确定创建的这个数组能被完全赋值，否则后面运算起来很麻烦，这些“空值”的布尔类型是 True，而且 dropna() 方法删不掉。想创建空的 Series ，可以使用 Series(np.nan,index=???)。

arange 是python内建 range 函数的数组版本。

```
np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
```

### ndarray 对象的属性
.reshape(shape)

此方法用于改变数组的形状。虽然我觉得既然 ndarray 对象的数据块都是线性存储的，按说调用 .reshape() 方法的话只需要改一下数据头中的 shape 属性就可以了啊，但实际上不是这样子的！a.reshape(shape, order='C') 方法会返回一个新数组，而不是直接改变调用者的形状。


>>> foo = np.arange(9)
>>> bar = foo.reshape((3,3))
>>> bar
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> foo
array([0, 1, 2, 3, 4, 5, 6, 7, 8])


.astype(dtype)

这是一个用于转换数组 dtype 的方法，从前面的 ndarray 数据结构可以猜到，这种转换必然需要创建一个新数组。如果转换过程因为某种原因而失败了，就会引发一个 TypeError 异常。另外，如 np.int32() 这样把 dtype 当做函数来用也是可行的，但更推荐 .astype() 方法：


>>> bar.astype(float)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.]])
本例中使用 Python 内建的 float 当做 dtype 传了进去，也是可行的哦，当对数据大小不敏感时就可以这么做。 


.transpose(*axes)

转置方法返回的是原数组的视图（不复制）。因为我对多维数组也搞不太懂，就只举个二维数组的例子吧（不给 axes 参数）：


>>> foo = np.arange(8).reshape(2,4)
>>> foo
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
>>> foo.transpose()
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
>>> foo.T
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
数组的 .T 属性是轴对换的快捷方式。一般在计算矩阵点积时比较方便：np.dot(arr,att.T)。嗯，简单的乘法（星号）是广播运算，点积需要使用 dot() 函数。 


.sort()

ndarray 的 .sort(axis=-1, kind='quicksort', order=None) 方法可用于给数组在指定轴向上排序。比如一个 （4，3，2）的数组，它的对应轴向分别为（2，1，0），方法默认的 axis=-1 代表最外层维度，如 “表” 里的 “行”。


>>> a = np.array([[1,4], [3,1]])
>>> a
array([[1, 4],
       [3, 1]])
>>> np.sort(a,0)
array([[1, 1],
       [3, 4]])
>>> np.sort(a,1)
array([[1, 4],
       [1, 3]])
这里使用了外部函数 np.sort() 是为了在演示过程中不会影响到原数组。np.sort() 函数总是返回一份拷贝，而 .sort() 方法则会更改原数组。 

#### 数组和纯量间的操作

数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。

```
arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
	## array([[ 1.,  2.,  3.],
	##        [ 4.,  5.,  6.]])
arr * arr                 
	## array([[  1.,   4.,   9.],       
	##        [ 16.,  25.,  36.]])
```

纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：

```
1 / arr                       
	## array([[ 1. , 0.5 , 0.3333],            
	##        [ 0.25 , 0.2 , 0.1667]])
```

#### 基本的索引和切片
Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。

```
arr = np.arange(10)
arr
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[5]
	## 5
arr[5:8]
	## array([5, 6, 7])
arr[5:8] = 12
arr
	## array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
```
如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。

```
arr_slice = arr[5:8]
arr_slice[1] = 12345
arr_slice
	## array([   12, 12345,    12])
arr
	## array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
arr_slice[:] = 64
arr_slice
	## array([64, 64, 64])
arr
	## array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
```
如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。

对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。

```
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
	## array([7, 8, 9])
```
因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。

```
arr2d[0][2]
	## 3
arr2d[0, 2]
	## 3
```
在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2\*\2\*3 的数组 arr3d 中

```
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
```
arr3d[0] 是一个 2*3 的数组。

```
arr3d[0]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
```
纯量值和数组都可以给 arr3d[0] 赋值。

```
old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
	## array([[[42, 42, 42],
	##         [42, 42, 42]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
arr3d[0] = old_values
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
```
类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：

```
arr3d[1, 0]
	## array([7, 8, 9])
```
请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。
如同一维对象，ndarrys可以使用熟悉的语法来切片。

```
arr[1:6]
	## array([ 1, 2, 3, 4, 64])
```
较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。

```
arr2d
	## array([[1, 2, 3],          
	##        [4, 5, 6],                 
	##        [7, 8, 9]])
arr2d[:2]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
```
正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。

```
arr2d[:2, 1:]
	## array([[2, 3],
	##        [5, 6]])
```
像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。

```
arr2d[1, :2] 
	## array([4, 5])
```
注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：

```
arr2d[:, :1]
	## array([[1],
	##        [4],
	##        [7]])
```
当然，给一个切片表达式赋值会对整个选择赋值：

```
arr2d[:2, 1:] = 0
```

## 布尔索引
让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。

```
import numpy.random as np_rd
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np_rd.randn(7, 4)
names
	## array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	##       dtype='|S4')
data
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
```
假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。

```
names == 'Bob'
	## array([ True, False, False, True, False, False, False], dtype=bool)
```
当索引数组时可以传递这一布尔数组。

```
data[names == 'Bob']
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672]])
```
布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。

```
data[names == 'Bob', 2:]
	## array([[-0.2349, 1.2792],
	##        [-0.0523, 0.0672]])
```
为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：

```
names != 'Bob'
	## array([False, True, True, False, True, True, True], dtype=bool)
data[-(names == 'Bob')]
	## array([[-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
```
使用布尔算术操作符如 & （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。

```
mask = (names == 'Bob') | (names == 'Will')
mask
array([True, False, True, True, True, False, False], dtype=bool)
data[mask]
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289]])
```
通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。
为了设置 data 中所有的负值为0，我们只需要。

```
data[data < 0] = 0
data
	## array([[ 0. , 0.5433, 0. , 1.2792],
	##        [ 0. , 0.5465, 0.0939, 0. ],
	##        [ 0. , 0. , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, 0. , 0.0672],
	##        [ 0. , 0. , 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, 0. , 0. ]])
```
使用一维布尔数组设置整行或列也非常简单：

```
data[names != 'Joe'] = 7
data
array([[ 7. , 7. , 7. , 7. ],
       [ 0. , 0.5465, 0.0939, 0. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 0.1913, 0.4544, 0.4519, 0.5535],
       [ 0.5994, 0.8174, 0. , 0. ]])
```

#### Fancy索引
Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8*4 的数组。

```
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
	## array([[ 0., 0., 0., 0.],
	##        [ 1., 1., 1., 1.],
	##        [ 2., 2., 2., 2.],
	##        [ 3., 3., 3., 3.],
	##        [ 4., 4., 4., 4.],
	##        [ 5., 5., 5., 5.],
	##        [ 6., 6., 6., 6.],
	##        [ 7., 7., 7., 7.]])
```
为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。

```
arr[[4, 3, 0, 6]]
	## array([[ 4., 4., 4., 4.],
	##        [ 3., 3., 3., 3.],
	##        [ 0., 0., 0., 0.],
	##        [ 6., 6., 6., 6.]])
```
很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。

```
arr[[-3, -5, -7]]
	## array([[ 5., 5., 5., 5.],
	##        [ 3., 3., 3., 3.],
	##        [ 1., 1., 1., 1.]])
```
传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。

```
arr = np.arange(32).reshape((8, 4))
arr
	## array([[ 0, 1, 2, 3],
	##        [ 4, 5, 6, 7],
	##        [ 8, 9, 10, 11],
	##        [12, 13, 14, 15],
	##        [16, 17, 18, 19],
	##        [20, 21, 22, 23],
	##        [24, 25, 26, 27],
	##        [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
	## array([ 4, 23, 29, 10])
```
花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。

```
arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
```
另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：

```
arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
```
注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。
### 转置数组和交换坐标轴
转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：

```
arr = np.arange(15).reshape((3, 5))
arr                  
	## array([[ 0, 1, 2, 3, 4],               
	##        [ 5, 6, 7, 8, 9],               
	##        [10, 11, 12, 13, 14]])          
arr.T
	## array([[ 0, 5, 10],
	##        [ 1, 6, 11],
	##        [ 2, 7, 12],
	##        [ 3, 8, 13],
	##        [ 4, 9, 14]])
```
当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX` 。

```
arr = np.random.randn(6, 3)
np.dot(arr.T, arr)
	## array([[ 2.584 , 1.8753, 0.8888],
	##        [ 1.8753, 6.6636, 0.3884],
	##        [ 0.8888, 0.3884, 3.9781]])
```
对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：

```
arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
```
使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。

```
arr                            			                   
	## array([[[ 0, 1, 2, 3],            
	##         [ 4, 5, 6, 7]],                                     
	##        [[ 8, 9, 10, 11],          
	##         [12, 13, 14, 15]]])                                      
arr.swapaxes(1, 2)          
    ## array([[[ 0, 4],
    ##         [ 1, 5],
    ##         [ 2, 6],
    ##         [ 3, 7]],
    ##        [[ 8, 12],
    ##        [ 9, 13],
    ##        [10, 14],
    ##        [11, 15]]])
```
类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。

### 通用函数：快速的基于元素的数组函数
一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。
许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。

```
Iarr = np.arange(10)
Inp.sqrt(arr)
	## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,
	##         2.6458, 2.8284, 3. ])
np.exp(arr)
	## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,
	##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])
```
这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：

```
x = randn(8)
y = randn(8)
x
	## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,
	##        -0.9337])
y
	## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,
	##        -0.7147])
np.maximum(x, y) # element-wise maximum
	## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,
	##        -0.7147])
```
虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。

```
arr = randn(7) * 5
np.modf(arr)
	##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),
	## array([-2., 4., -3., 5., -3., 3., -6.]))
```
