<!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
      <meta name="author" content="Xu Kuang" />
        <title>Numpy包的学习 | Xu Kuang</title>
        <link rel="shortcut icon" href="/favicon.ico">
          <link href="http://xukuang.github.io/blog/feed/" rel="alternate" title="Xu Kuang" type="application/atom+xml" />
            <link rel="stylesheet" href="/media/css/style.css">
              <link rel="stylesheet" href="/media/css/highlight.css">
                <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
                  <!--highlight.js Start-->
                  <link rel="stylesheet" title="Default" href="/media/js/styles/tomorrow-night-blue.css">
                    <script type="text/javascript" src="/media/js/highlight.pack.js"></script>
                      <script>
                      hljs.configure({tabReplace: '    '});
                    hljs.initHighlightingOnLoad();
                    </script>
                      <!--highlight.js End-->
                      <!--mathjax start-->
                      <script type="text/javascript"
                      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
                        </script>
                        
                        <!--mathjax end-->
                        </head>
                        <body>
                        <div id="container">
                          <div id="main" role="main">
                            <header>
                            <h1>Numpy包的学习</h1>
                            </header>
                            <nav>
                            <!-- Sidebar -->
                            <h5 id="logo" style="text-align:center;">
                              <a href="http://xukuang.github.io/">主页</a></h5>
                                <span><a title="blog" class="" href="http://xukuang.github.io/blog/">博客</a></span>
                                  <span><a title="about" class="" href="http://xukuang.github.io/blog/about/">关于</a></span>
                                    <span><a title="categories" class="" href="http://xukuang.github.io/blog/categories/">分类</a></span>
                                      <span><a title="vitae" class="" href="http://xukuang.github.io/blog/vitae/">简历</a></span>
                                        <span><a title="tags" class="" href="http://xukuang.github.io/blog/tags/">标签</a></span>
                                          <span><a title="links" class="" href="http://xukuang.github.io/blog/links/">链接</a></span>
                                            <span><a title="subscribe by RSS" class="" href="http://xukuang.github.io/blog/feed/">订阅</a></span>
                                              </nav>
                                              <article class="content">
                                              <section class="post">
<p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。
* ndarray，快速和节省空间的多维数组，提供数组化的算术运算和高级的广播功能『广播功能是个什么东东啊』
* 使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环
* 读取/写入磁盘上的阵列数据和操作存储器映像文件的工具
* 线性代数，随机数生成，和傅里叶变换的能力
* 集成C，C++，Fortran代码的工具</p>

<p>从生态系统的角度看，最后一点是最为重要的。因为Numpy提供了易用的C ApI，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回Numpy数组数据到python。这一特性使得python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。『完全不懂啊』
虽然Numpy本身并没有提供非常高级的数据分析功能，但是了解Numpy的数组和面向数组的计算将会帮助你高效的使用类似于pandas这样的工具。
对于大多数的数据分析应用来说，我关注的主要功能是。
* 快速的矢量化数组操作：数据切割和清除，子集和过滤，转化和任何其它类型的计算
* 通用的数组算法，例如：sorting，unique和set操作
* 有效的描述性统计和聚集/汇总数据
* 数据对齐、关系数据的合并操作、异构数据的拼接操作
* 使用数组表达式来表示条件逻辑，而不是用带有 if-elif-else 分支的循环来表示
* 组间数据的操作（聚合，转换，功能应用）。</p>

<p>虽然Numpy提供了这些操作的计算功能，但你或许希望使用pandas作为大多数数据分析的基础（特别是结构化或表格数据），因为pandas提供了一个丰富的，高级的接口使得常见的数据任务非常简洁和简单。此外，pandas还提供了更多的一些特定领域的功能，如时间数组操作，这是Numpy所没有的。
###  Numpy ndarray：多维数组对象
Numpy的一个关键特性是它的N维数组对象(ndarray)，它在python中是一个大型数据集的快速的，灵活的容器。 数组使你能够在整个数据块上进行数学运算，且与对应的纯量元素间操作有相似的语法：
<code class="highlighter-rouge">
array1 = np.array([[ 0.9526, -0.246 , -0.8856], [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
</code>
ndarray是一个同种类数据的多维容器，也就是说，它的所有元素都是同类型的。每一个数组都有一个 shape （表示它每一维大小的元组）和 dtype （一个描述数组数据类型的对象）的属性。
<code class="highlighter-rouge">
array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
</code>
#### 创建ndarray对象
最简单的创建数组的方式是使用array函数。它接受任何数组对象（包括其它数组），产生一个包含所传递的数据的新Numpy数组。例如，列表就是一个很好的用于转换的候选。
<code class="highlighter-rouge">
data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
</code>
嵌套序列，如等长列表的列表，将会转化为一个多维数组。
<code class="highlighter-rouge">
data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
</code>
除 np.array 之外，还有许多函数来创建新的数组。例如， zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。empty 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组。
<code class="highlighter-rouge">
np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
</code>
arange 是python内建 range 函数的数组版本。
<code class="highlighter-rouge">
np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
</code>
#### 数组和纯量间的操作
数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。
<code class="highlighter-rouge">
arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
	## array([[ 1.,  2.,  3.],
	##        [ 4.,  5.,  6.]])
arr * arr                 
	## array([[  1.,   4.,   9.],       
	##        [ 16.,  25.,  36.]])
</code></p>

<p>纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 / arr                       
	## array([[ 1. , 0.5 , 0.3333],            
	##        [ 0.25 , 0.2 , 0.1667]])
</code></pre>
</div>

<h4 id="section">基本的索引和切片</h4>
<p>Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。
<code class="highlighter-rouge">
arr = np.arange(10)
arr
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[5]
	## 5
arr[5:8]
	## array([5, 6, 7])
arr[5:8] = 12
arr
	## array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code>
如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。
<code class="highlighter-rouge">
arr_slice = arr[5:8]
arr_slice[1] = 12345
arr_slice
	## array([   12, 12345,    12])
arr
	## array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
arr_slice[:] = 64
arr_slice
	## array([64, 64, 64])
arr
	## array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
</code>
如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。</p>

<p>对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。
<code class="highlighter-rouge">
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
	## array([7, 8, 9])
</code>
因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。
<code class="highlighter-rouge">
arr2d[0][2]
	## 3
arr2d[0, 2]
	## 3
</code>
在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中
<code class="highlighter-rouge">
arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code>
arr3d[0] 是一个 2<em>3 的数组。
<code class="highlighter-rouge">
arr3d[0]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code>
纯量值和数组都可以给 arr3d[0] 赋值。
<code class="highlighter-rouge">
old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
	## array([[[42, 42, 42],
	##         [42, 42, 42]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
arr3d[0] = old_values
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code>
类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：
<code class="highlighter-rouge">
arr3d[1, 0]
	## array([7, 8, 9])
</code>
请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。
如同一维对象，ndarrys可以使用熟悉的语法来切片。
<code class="highlighter-rouge">
arr[1:6]
	## array([ 1, 2, 3, 4, 64])
</code>
较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。
<code class="highlighter-rouge">
arr2d
	## array([[1, 2, 3],          
	##        [4, 5, 6],                 
	##        [7, 8, 9]])
arr2d[:2]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code>
正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。
<code class="highlighter-rouge">
arr2d[:2, 1:]
	## array([[2, 3],
	##        [5, 6]])
</code>
像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。
<code class="highlighter-rouge">
arr2d[1, :2] 
	## array([4, 5])
</code>
注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：
<code class="highlighter-rouge">
arr2d[:, :1]
	## array([[1],
	##        [4],
	##        [7]])
</code>
当然，给一个切片表达式赋值会对整个选择赋值：
<code class="highlighter-rouge">
arr2d[:2, 1:] = 0
</code>
## 布尔索引
让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。
<code class="highlighter-rouge">
import numpy.random as np_rd
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np_rd.randn(7, 4)
names
	## array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	##       dtype='|S4')
data
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code>
假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。
<code class="highlighter-rouge">
names == 'Bob'
	## array([ True, False, False, True, False, False, False], dtype=bool)
</code>
当索引数组时可以传递这一布尔数组。
<code class="highlighter-rouge">
data[names == 'Bob']
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672]])
</code>
布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。
<code class="highlighter-rouge">
data[names == 'Bob', 2:]
	## array([[-0.2349, 1.2792],
	##        [-0.0523, 0.0672]])
</code>
为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：
<code class="highlighter-rouge">
names != 'Bob'
	## array([False, True, True, False, True, True, True], dtype=bool)
data[-(names == 'Bob')]
	## array([[-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code>
使用布尔算术操作符如 &amp; （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。
<code class="highlighter-rouge">
mask = (names == 'Bob') | (names == 'Will')
mask
array([True, False, True, True, True, False, False], dtype=bool)
data[mask]
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289]])
</code>
通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。
为了设置 data 中所有的负值为0，我们只需要。
<code class="highlighter-rouge">
data[data &lt; 0] = 0
data
	## array([[ 0. , 0.5433, 0. , 1.2792],
	##        [ 0. , 0.5465, 0.0939, 0. ],
	##        [ 0. , 0. , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, 0. , 0.0672],
	##        [ 0. , 0. , 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, 0. , 0. ]])
</code>
使用一维布尔数组设置整行或列也非常简单：
<code class="highlighter-rouge">
data[names != 'Joe'] = 7
data
array([[ 7. , 7. , 7. , 7. ],
       [ 0. , 0.5465, 0.0939, 0. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 0.1913, 0.4544, 0.4519, 0.5535],
       [ 0.5994, 0.8174, 0. , 0. ]])
</code>
#### Fancy索引
Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8</em>4 的数组。
<code class="highlighter-rouge">
arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
	## array([[ 0., 0., 0., 0.],
	##        [ 1., 1., 1., 1.],
	##        [ 2., 2., 2., 2.],
	##        [ 3., 3., 3., 3.],
	##        [ 4., 4., 4., 4.],
	##        [ 5., 5., 5., 5.],
	##        [ 6., 6., 6., 6.],
	##        [ 7., 7., 7., 7.]])
</code>
为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。
<code class="highlighter-rouge">
arr[[4, 3, 0, 6]]
	## array([[ 4., 4., 4., 4.],
	##        [ 3., 3., 3., 3.],
	##        [ 0., 0., 0., 0.],
	##        [ 6., 6., 6., 6.]])
</code>
很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。
<code class="highlighter-rouge">
arr[[-3, -5, -7]]
	## array([[ 5., 5., 5., 5.],
	##        [ 3., 3., 3., 3.],
	##        [ 1., 1., 1., 1.]])
</code>
传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。
<code class="highlighter-rouge">
arr = np.arange(32).reshape((8, 4))
arr
	## array([[ 0, 1, 2, 3],
	##        [ 4, 5, 6, 7],
	##        [ 8, 9, 10, 11],
	##        [12, 13, 14, 15],
	##        [16, 17, 18, 19],
	##        [20, 21, 22, 23],
	##        [24, 25, 26, 27],
	##        [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
	## array([ 4, 23, 29, 10])
</code>
花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。
<code class="highlighter-rouge">
arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code>
另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：
<code class="highlighter-rouge">
arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code>
注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。
### 转置数组和交换坐标轴
转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：
<code class="highlighter-rouge">
arr = np.arange(15).reshape((3, 5))
arr                  
	## array([[ 0, 1, 2, 3, 4],               
	##        [ 5, 6, 7, 8, 9],               
	##        [10, 11, 12, 13, 14]])          
arr.T
	## array([[ 0, 5, 10],
	##        [ 1, 6, 11],
	##        [ 2, 7, 12],
	##        [ 3, 8, 13],
	##        [ 4, 9, 14]])
</code>
当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX<code class="highlighter-rouge"> 。
</code><code class="highlighter-rouge">
arr = np.random.randn(6, 3)
np.dot(arr.T, arr)
	## array([[ 2.584 , 1.8753, 0.8888],
	##        [ 1.8753, 6.6636, 0.3884],
	##        [ 0.8888, 0.3884, 3.9781]])
</code><code class="highlighter-rouge">
对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：
</code><code class="highlighter-rouge">
arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
</code><code class="highlighter-rouge">
使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。
</code><code class="highlighter-rouge">
arr                            			                   
	## array([[[ 0, 1, 2, 3],            
	##         [ 4, 5, 6, 7]],                                     
	##        [[ 8, 9, 10, 11],          
	##         [12, 13, 14, 15]]])                                      
arr.swapaxes(1, 2)          
    ## array([[[ 0, 4],
    ##         [ 1, 5],
    ##         [ 2, 6],
    ##         [ 3, 7]],
    ##        [[ 8, 12],
    ##        [ 9, 13],
    ##        [10, 14],
    ##        [11, 15]]])
</code><code class="highlighter-rouge">
类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。
### 通用函数：快速的基于元素的数组函数
一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。
许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。
</code><code class="highlighter-rouge">
Iarr = np.arange(10)
Inp.sqrt(arr)
	## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,
	##         2.6458, 2.8284, 3. ])
np.exp(arr)
	## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,
	##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])
</code><code class="highlighter-rouge">
这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：
</code><code class="highlighter-rouge">
x = randn(8)
y = randn(8)
x
	## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,
	##        -0.9337])
y
	## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,
	##        -0.7147])
np.maximum(x, y) # element-wise maximum
	## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,
	##        -0.7147])
</code><code class="highlighter-rouge">
虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。
</code><code class="highlighter-rouge">
arr = randn(7) * 5
np.modf(arr)
	##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),
	## array([-2., 4., -3., 5., -3., 3., -6.]))
</code>`</p>

</section>
<section class="meta">



<span>
	<a  href="http://xukuang.github.io/blog/2016/04/spatial-pattern-analysis/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a   class="pageNavInvalid"  >Next</a>
</span>


<span class="author">
  <a href="http://xukuang.github.io/cn">Xu Kuang</a>
</span>
<span class="time">
  /
  <time datetime="2016-04-27">2016-04-27</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://xukuang.github.io/blog/categories/#技术篇" title="技术篇">技术篇</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://xukuang.github.io/blog/tags/#python" title="python">python</a>&nbsp;
  
  <a href="http://xukuang.github.io/blog/tags/#numpy" title="numpy">numpy</a>&nbsp;
  
</span>

</section>
<section class="comment">
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname ='Xu_Kuang'; // required: replace example with your forum shortname
    var disqus_url = 'http://xukuang.github.io/blog/2016/04/numpy/';
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://xukuang.github.io/blog/2016/04/spatial-pattern-analysis/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>


                                              </article>
                                                </div>
                                                </div>
                                                <script type="text/javascript">
                                                  var _gaq = _gaq || [];
                                                  _gaq.push(['_setAccount', '']);
                                                  _gaq.push(['_trackPageview']);
                                                  (function() {
                                                    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                                                    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                                                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                                                  })();
                                                  </script>
                                                    </body>
                                                    </html>
                                                    