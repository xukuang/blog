<!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
      <meta name="author" content="Xu Kuang" />
        <title>Numpy包的学习 | Xu Kuang</title>
        <link rel="shortcut icon" href="/favicon.ico">
          <link href="http://xukuang.github.io/blog/feed/" rel="alternate" title="Xu Kuang" type="application/atom+xml" />
            <link rel="stylesheet" href="/media/css/style.css">
              <link rel="stylesheet" href="/media/css/highlight.css">
                <script type="text/javascript" src="/media/js/jquery-1.7.1.min.js"></script>
                  <!--highlight.js Start-->
                  <link rel="stylesheet" title="Default" href="/media/js/styles/tomorrow-night-blue.css">
                    <script type="text/javascript" src="/media/js/highlight.pack.js"></script>
                      <script>
                      hljs.configure({tabReplace: '    '});
                    hljs.initHighlightingOnLoad();
                    </script>
                      <!--highlight.js End-->
                      <!--mathjax start-->
                      <script type="text/javascript"
                      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
                        </script>
                        
                        <!--mathjax end-->
                        </head>
                        <body>
                        <div id="container">
                          <div id="main" role="main">
                            <header>
                            <h1>Numpy包的学习</h1>
                            </header>
                            <nav>
                            <!-- Sidebar -->
                            <h5 id="logo" style="text-align:center;">
                              <a href="http://xukuang.github.io/">HOME</a></h5>
                                <span><a title="blog" class="" href="http://xukuang.github.io/blog/">BLOG</a></span>
                                  <span><a title="about" class="" href="http://xukuang.github.io/blog/about/">ABOUT</a></span>
                                    <span><a title="categories" class="" href="http://xukuang.github.io/blog/categories/">CATEGORIES</a></span>
                                      <span><a title="vitae" class="" href="http://xukuang.github.io/blog/vitae/">VITAE</a></span>
                                        <span><a title="tags" class="" href="http://xukuang.github.io/blog/tags/">TAGS</a></span>
                                          <span><a title="links" class="" href="http://xukuang.github.io/blog/links/">LINKS</a></span>
                                            <span><a title="subscribe by RSS" class="" href="http://xukuang.github.io/blog/feed/">SUBSCRIBE</a></span>
                                              </nav>
                                              <article class="content">
                                              <section class="post">
<p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。其实它 本身并没有提供多么高级的数据结构和分析功能，但它是很多高级工具（如 pandas）构建的基础，在结构和操作上具有统一性，因此理解 Numpy 的数组及面向数组的计算有助于更加高效地使用诸如 pandas 之类的工具。</p>

<p>Numpy 的核心内容是它的多维数组对象——ndarray（N-Dimensions Array），整个包几乎都是围绕这个对象展开。</p>

<h3 id="ndarray">ndarray：多维数组对象</h3>
<p>Numpy 的 ndarray 提供了一种将同质数据块解释为多维数组对象的方式。同质，表示数组的元素必须都是相同的数据类型（如 int，float 等）；解释，表示 ndarray 的数据块其实是线性存储的，并通过额外的元信息解释为多维数组结构。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import pandas as pd
array1 = np.array([[ 0.9526, -0.246 , -0.8856], 
				   [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
</code></pre>
</div>

<p>上面是一个 2×3 的矩阵。在使用类似 2×3×4…这种格式表示多维数组的结构时，从左向右的数字对应表示由表及里的维度，或称为轴，按索引给轴编号后可称为“轴 0”、“轴 1”和“轴2”等）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
array1.strides
	## (24, 8)
</code></pre>
</div>
<p>这个矩阵的形状（shape）是（2,3）或 2×3，即它有 2 个长度为 3 的一维数组；它的 dtype 是 float64 表示它的单位元素是占 8 字节的浮点型；跨度（strides）元组指的是在某一维度下为了获取到下一个元素需要“跨过”的字节数。可见跨度是可以由 形状+dtype 来确定的。显然这种同质的静态数据结构在进行数值运算时效率要比 Python 内建的可以混杂动态类型的列表要快得多。</p>

<h3 id="ndarray-1">ndarray对象的创建</h3>
<p>创建数组的方法是使用array( )函数。它接受一切序列对象，产生一个包含所传递的数据的新ndarry数组，维度视序列的嵌套深度而定。首先，列表就是一个很好的用于转换的候选。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
</code></pre>
</div>

<p>嵌套序列，如等长列表的列表，将会转化为一个多维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
</code></pre>
</div>
<p>数组的 dtype 会由系统自动推定，除非你显式传递一个参数进去。系统一般会默认使用 int32 或 float64。
除 array() 之外，还有许多函数来创建新的数组。</p>

<p><strong>数组构建函数</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">array</td>
      <td style="text-align: left">转换输入数据（列表，数组或其它序列类型）为ndarray，可以推断一个dtype或明确的设置一个dtype，默认拷贝输入数据</td>
    </tr>
    <tr>
      <td style="text-align: left">asarray</td>
      <td style="text-align: left">将输入转换为 ndarray，若输入本身是 ndarray 就不拷贝</td>
    </tr>
    <tr>
      <td style="text-align: left">arange</td>
      <td style="text-align: left">同内建的range函数，但不返回的不是列表而是一个一维的ndarray</td>
    </tr>
    <tr>
      <td style="text-align: left">ones, ones_like</td>
      <td style="text-align: left">根据提供的shape和dtype产生一个全1的数组；ones_like使用另一个数组为参数，产生一个shape和dtype都相同的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">zeros, zeros_like</td>
      <td style="text-align: left">同ones和ones_like，但是生成一个全0的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">empty, enpty_like</td>
      <td style="text-align: left">创建新数组，但只分配内存空间不赋值</td>
    </tr>
    <tr>
      <td style="text-align: left">eye, identity</td>
      <td style="text-align: left">创建一个NxN的单位方阵（对角线上为1，其余为0）</td>
    </tr>
  </tbody>
</table>

<p>例如，zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
</code></pre>
</div>
<p>在 pandas 中尽量不要使用 np.empty()，这个函数创建的数组里面是有值的，除非你确定创建的这个数组能被完全赋值，否则后面运算起来很麻烦，这些“空值”的布尔类型是 True，而且 dropna() 方法删不掉。想创建空的 Series ，可以使用 Series(np.nan,index=???)。</p>

<p>arange 是python内建 range 函数的数组版本。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
</code></pre>
</div>

<h3 id="ndarray-">ndarray 对象的属性</h3>
<p>.reshape(shape)</p>

<p>此方法用于改变数组的形状。虽然我觉得既然 ndarray 对象的数据块都是线性存储的，按说调用 .reshape() 方法的话只需要改一下数据头中的 shape 属性就可以了啊，但实际上不是这样子的！a.reshape(shape, order=’C’) 方法会返回一个新数组，而不是直接改变调用者的形状。</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>foo = np.arange(9)
bar = foo.reshape((3,3))
bar
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
foo
array([0, 1, 2, 3, 4, 5, 6, 7, 8])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.astype(dtype)</p>

<p>这是一个用于转换数组 dtype 的方法，从前面的 ndarray 数据结构可以猜到，这种转换必然需要创建一个新数组。如果转换过程因为某种原因而失败了，就会引发一个 TypeError 异常。另外，如 np.int32() 这样把 dtype 当做函数来用也是可行的，但更推荐 .astype() 方法：</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>bar.astype(float)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.]])
本例中使用 Python 内建的 float 当做 dtype 传了进去，也是可行的哦，当对数据大小不敏感时就可以这么做。</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.transpose(*axes)</p>

<p>转置方法返回的是原数组的视图（不复制）。因为我对多维数组也搞不太懂，就只举个二维数组的例子吧（不给 axes 参数）：</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>foo = np.arange(8).reshape(2,4)
foo
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
foo.transpose()
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
foo.T
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
数组的 .T 属性是轴对换的快捷方式。一般在计算矩阵点积时比较方便：np.dot(arr,att.T)。嗯，简单的乘法（星号）是广播运算，点积需要使用 dot() 函数。</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.sort()</p>

<p>ndarray 的 .sort(axis=-1, kind=’quicksort’, order=None) 方法可用于给数组在指定轴向上排序。比如一个 （4，3，2）的数组，它的对应轴向分别为（2，1，0），方法默认的 axis=-1 代表最外层维度，如 “表” 里的 “行”。</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([[1,4], [3,1]])
a
array([[1, 4],
       [3, 1]])
np.sort(a,0)
array([[1, 1],
       [3, 4]])
np.sort(a,1)
array([[1, 4],
       [1, 3]])
这里使用了外部函数 np.sort() 是为了在演示过程中不会影响到原数组。np.sort() 函数总是返回一份拷贝，而 .sort() 方法则会更改原数组。</p>
    </blockquote>
  </blockquote>
</blockquote>

<h4 id="section">数组和纯量间的操作</h4>

<p>数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
	## array([[ 1.,  2.,  3.],
	##        [ 4.,  5.,  6.]])
arr * arr                 
	## array([[  1.,   4.,   9.],       
	##        [ 16.,  25.,  36.]])
</code></pre>
</div>

<p>纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 / arr                       
	## array([[ 1. , 0.5 , 0.3333],            
	##        [ 0.25 , 0.2 , 0.1667]])
</code></pre>
</div>

<h4 id="section-1">基本的索引和切片</h4>
<p>Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(10)
arr
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[5]
	## 5
arr[5:8]
	## array([5, 6, 7])
arr[5:8] = 12
arr
	## array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code></pre>
</div>
<p>如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr_slice = arr[5:8]
arr_slice[1] = 12345
arr_slice
	## array([   12, 12345,    12])
arr
	## array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
arr_slice[:] = 64
arr_slice
	## array([64, 64, 64])
arr
	## array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
</code></pre>
</div>
<p>如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。</p>

<p>对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
	## array([7, 8, 9])
</code></pre>
</div>
<p>因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[0][2]
	## 3
arr2d[0, 2]
	## 3
</code></pre>
</div>
<p>在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>arr3d[0] 是一个 2*3 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[0]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>纯量值和数组都可以给 arr3d[0] 赋值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
	## array([[[42, 42, 42],
	##         [42, 42, 42]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
arr3d[0] = old_values
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[1, 0]
	## array([7, 8, 9])
</code></pre>
</div>
<p>请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。
如同一维对象，ndarrys可以使用熟悉的语法来切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[1:6]
	## array([ 1, 2, 3, 4, 64])
</code></pre>
</div>
<p>较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d
	## array([[1, 2, 3],          
	##        [4, 5, 6],                 
	##        [7, 8, 9]])
arr2d[:2]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:]
	## array([[2, 3],
	##        [5, 6]])
</code></pre>
</div>
<p>像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[1, :2] 
	## array([4, 5])
</code></pre>
</div>
<p>注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:, :1]
	## array([[1],
	##        [4],
	##        [7]])
</code></pre>
</div>
<p>当然，给一个切片表达式赋值会对整个选择赋值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:] = 0
</code></pre>
</div>

<h2 id="section-2">布尔索引</h2>
<p>让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import numpy.random as np_rd
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np_rd.randn(7, 4)
names
	## array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	##       dtype='|S4')
data
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names == 'Bob'
	## array([ True, False, False, True, False, False, False], dtype=bool)
</code></pre>
</div>
<p>当索引数组时可以传递这一布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob']
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672]])
</code></pre>
</div>
<p>布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob', 2:]
	## array([[-0.2349, 1.2792],
	##        [-0.0523, 0.0672]])
</code></pre>
</div>
<p>为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names != 'Bob'
	## array([False, True, True, False, True, True, True], dtype=bool)
data[-(names == 'Bob')]
	## array([[-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>使用布尔算术操作符如 &amp; （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mask = (names == 'Bob') | (names == 'Will')
mask
array([True, False, True, True, True, False, False], dtype=bool)
data[mask]
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289]])
</code></pre>
</div>
<p>通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。
为了设置 data 中所有的负值为0，我们只需要。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[data &lt; 0] = 0
data
	## array([[ 0. , 0.5433, 0. , 1.2792],
	##        [ 0. , 0.5465, 0.0939, 0. ],
	##        [ 0. , 0. , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, 0. , 0.0672],
	##        [ 0. , 0. , 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>
<p>使用一维布尔数组设置整行或列也非常简单：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names != 'Joe'] = 7
data
array([[ 7. , 7. , 7. , 7. ],
       [ 0. , 0.5465, 0.0939, 0. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 0.1913, 0.4544, 0.4519, 0.5535],
       [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>

<h4 id="fancy">Fancy索引</h4>
<p>Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8*4 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
	## array([[ 0., 0., 0., 0.],
	##        [ 1., 1., 1., 1.],
	##        [ 2., 2., 2., 2.],
	##        [ 3., 3., 3., 3.],
	##        [ 4., 4., 4., 4.],
	##        [ 5., 5., 5., 5.],
	##        [ 6., 6., 6., 6.],
	##        [ 7., 7., 7., 7.]])
</code></pre>
</div>
<p>为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[4, 3, 0, 6]]
	## array([[ 4., 4., 4., 4.],
	##        [ 3., 3., 3., 3.],
	##        [ 0., 0., 0., 0.],
	##        [ 6., 6., 6., 6.]])
</code></pre>
</div>
<p>很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[-3, -5, -7]]
	## array([[ 5., 5., 5., 5.],
	##        [ 3., 3., 3., 3.],
	##        [ 1., 1., 1., 1.]])
</code></pre>
</div>
<p>传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(32).reshape((8, 4))
arr
	## array([[ 0, 1, 2, 3],
	##        [ 4, 5, 6, 7],
	##        [ 8, 9, 10, 11],
	##        [12, 13, 14, 15],
	##        [16, 17, 18, 19],
	##        [20, 21, 22, 23],
	##        [24, 25, 26, 27],
	##        [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
	## array([ 4, 23, 29, 10])
</code></pre>
</div>
<p>花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。
### 转置数组和交换坐标轴
转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(15).reshape((3, 5))
arr                  
	## array([[ 0, 1, 2, 3, 4],               
	##        [ 5, 6, 7, 8, 9],               
	##        [10, 11, 12, 13, 14]])          
arr.T
	## array([[ 0, 5, 10],
	##        [ 1, 6, 11],
	##        [ 2, 7, 12],
	##        [ 3, 8, 13],
	##        [ 4, 9, 14]])
</code></pre>
</div>
<p>当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX` 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.random.randn(6, 3)
np.dot(arr.T, arr)
	## array([[ 2.584 , 1.8753, 0.8888],
	##        [ 1.8753, 6.6636, 0.3884],
	##        [ 0.8888, 0.3884, 3.9781]])
</code></pre>
</div>
<p>对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
</code></pre>
</div>
<p>使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr                            			                   
	## array([[[ 0, 1, 2, 3],            
	##         [ 4, 5, 6, 7]],                                     
	##        [[ 8, 9, 10, 11],          
	##         [12, 13, 14, 15]]])                                      
arr.swapaxes(1, 2)          
    ## array([[[ 0, 4],
    ##         [ 1, 5],
    ##         [ 2, 6],
    ##         [ 3, 7]],
    ##        [[ 8, 12],
    ##        [ 9, 13],
    ##        [10, 14],
    ##        [11, 15]]])
</code></pre>
</div>
<p>类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。</p>

<h3 id="section-3">通用函数：快速的基于元素的数组函数</h3>
<p>一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。
许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Iarr = np.arange(10)
Inp.sqrt(arr)
	## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,
	##         2.6458, 2.8284, 3. ])
np.exp(arr)
	## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,
	##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])
</code></pre>
</div>
<p>这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x = randn(8)
y = randn(8)
x
	## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,
	##        -0.9337])
y
	## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,
	##        -0.7147])
np.maximum(x, y) # element-wise maximum
	## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,
	##        -0.7147])
</code></pre>
</div>
<p>虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = randn(7) * 5
np.modf(arr)
	##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),
	## array([-2., 4., -3., 5., -3., 3., -6.]))
</code></pre>
</div>

</section>
<section class="meta">



<span>
	<a  href="http://xukuang.github.io/blog/2016/04/dots-in-r/" class="pageNav"  >Previous</a>
	&nbsp;&nbsp;&nbsp;
	<a   class="pageNavInvalid"  >Next</a>
</span>


<span class="author">
  <a href="http://xukuang.github.io/blog">Xu Kuang</a>
</span>
<span class="time">
  /
  <time datetime="2016-04-27">2016-04-27</time>
</span>
<br />
<span class="license">
  Published under <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">(CC) BY-NC-SA</a>
</span>

<span class="categories">
  in categories
  
  <a href="http://xukuang.github.io/blog/categories/#技术篇" title="技术篇">技术篇</a>&nbsp;
  
</span>


<span class="tags">
  tagged with 
  
  <a href="http://xukuang.github.io/blog/tags/#python" title="python">python</a>&nbsp;
  
  <a href="http://xukuang.github.io/blog/tags/#numpy" title="numpy">numpy</a>&nbsp;
  
</span>

</section>
<div id="disqus_thread"></div>
<script>
/**
* RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
* LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');

s.src = '//httpxukuanggithubio.disqus.com/embed.js';

s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<script type="text/javascript">
$(function(){
  $(document).keydown(function(e) {
    if (e.target.nodeName.toUpperCase() != 'BODY') return;
    var url = false;
        if (e.which == 37 || e.which == 74) {  // Left arrow and J
            
        url = 'http://xukuang.github.io/blog/2016/04/dots-in-r/';
        
        }
        else if (e.which == 39 || e.which == 75) {  // Right arrow and K
            
        }
        if (url) {
            window.location = url;
        }
  });
})
</script>


                                              </article>
                                                </div>
                                                </div>
                                                <script type="text/javascript">
                                                  var _gaq = _gaq || [];
                                                  _gaq.push(['_setAccount', '']);
                                                  _gaq.push(['_trackPageview']);
                                                  (function() {
                                                    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                                                    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                                                    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
                                                  })();
                                                  </script>
                                                    </body>
                                                    </html>
                                                    