<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Xu Kuang</title>
    <atom:link href="http://xukuang.github.io/blog/feed/" rel="self" type="application/rss+xml" />
    <link>http://xukuang.github.io/</link>
    <lastBuildDate>2016-06-04T17:52:00+08:00</lastBuildDate>
    <webMaster>kuang_xu@126.com</webMaster>
    
    <item>
      <title>html学习</title>
      <link>http://xukuang.github.io/blog/2016/06/html/</link>
      <pubDate>2016-06-03T19:46:15+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/06/html</guid>
      <content:encoded><![CDATA[<p>html标记是一种标记性语言，用来控制网页内容，网页布局。所谓的网页布局，其实就是，使用适合的标记来定义网页的元素。</p>

<p>html标记的类型：单标记和双标记，而单双标记又可以分为无属性值的单双标记和有属性值的单双标记。基本格式为：</p>

<p>&lt;标记 属性1=参数1 属性2=参数2 …&gt;内容&lt;/标记&gt;</p>

<p>说明：</p>

<p>标记与属性、属性与属性之间空格分隔
属性不区分先后顺序，且属性不是必需的</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Pandas包的学习</title>
      <link>http://xukuang.github.io/blog/2016/05/pandas/</link>
      <pubDate>2016-05-05T19:46:15+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/05/pandas</guid>
      <content:encoded><![CDATA[<p>Pandas包中有着高级的数据结构和精巧的工具，使得在Python中处理数据非常快速和简单。此外，pandas建造在NumPy之上，它使得以NumPy为中心的应用很容易使用。</p>

<h3 id="pandas">pandas数据结构</h3>
<p>为了开始使用pandas，你需要熟悉它的两个重要的数据结构： Series 和 DataFrame。类似于 Numpy 的核心是 ndarray，pandas 也是围绕着 Series 和 DataFrame 两个核心数据结构展开的。</p>

<ul>
  <li>Series</li>
</ul>

<p>Series 可以看做一个定长的有序字典。基本上任意的一维数据都可以用来构造 Series 对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>from pandas import Series, DataFrame
import pandas as pd
s = Series([1,2,3.0,'abc'])
s
	## 0      1
	## 1      2
	## 2      3
	## 3    abc
	## dtype: object
</code></pre>
</div>
<p>虽然 dtype:object 可以包含多种基本数据类型，但最好还是保持单纯的 dtype。</p>

<p>Series 对象包含两个主要的属性：index 和 values，分别为上例中左右两列。因为传给构造器的是一个列表，所以 index 的值是从 0 起递增的整数，如果传入的是一个类字典的键值对结构，就会生成 index-value 对应的 Series；或者在初始化的时候以关键字参数显式指定一个 index 对象。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sdata = {'a': 1, 'b': 3, 'x': 5, 'x': 7}
s1 = Series(sdata)
s1
	## a    1
	## b    3
	## x    5
	## y    7
	## dtype: int64

s2 = Series(data=[1,3,5,7],index = ['a','b','x','y'])
s2
	## a    1
	## b    3
	## x    5
	## y    7
	## dtype: int64
s.index
	## Index(['a', 'b', 'x', 'y'], dtype='object')
s.values
	## array([1, 3, 5, 7], dtype=int64)
</code></pre>
</div>
<p>Series 对象的元素会严格依照给出的 index 构建，这意味着如果 data 参数是有键值对的，那么只有 index 中含有的键会被使用；如果 data 中缺少响应的键，这个键也会被添加，只是给出的值为NaN 。</p>

<p>注意 Series 的 index 和 values 的元素之间虽然存在对应关系，但这与字典的映射不同。index 和 values 实际仍为互相独立的 ndarray 数组。Series 这种使用键值对的数据结构最大的好处在于，Series 间进行算术运算时，index 会自动对齐。</p>

<p>另外，Series 对象和它的 index 都含有一个 name 属性.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>s.name = 'a_series'
s.index.name = 'the_index'
s
	## the_index
	## a            1
	## b            3
	## x            5
	## y            7
	## Name: a_series, dtype: int64
</code></pre>
</div>

<ul>
  <li>DataFrame</li>
</ul>

<p>DataFrame 是一个表格型的数据结构，它含有一组有序的列（类似于 index），每列可以是不同的值类型（不像 ndarray 只能有一个 dtype）。基本上可以把 DataFrame 看成是共享同一个 index 的 Series 的集合。与其它你以前使用过的（如 R 的 data.frame )类似Datarame的结构相比，在DataFrame里的面向行和面向列的操作大致是对称的。在底层，数据是作为一个或多个二维数组存储的，而不是列表，字典，或其它一维的数组集合。</p>

<p>构建DataFrame的方法有多种，但最常用的一个是用一个相等长度列表的字典或NumPy数组。具体DataFrame 的构造方法与 Series 类似，只不过可以同时接受多条一维数据源，每一条都会成为单独的一列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data = {'state':['Ohino','Ohino','Ohino','Nevada','Nevada'],
        'year':[2000,2001,2002,2001,2002],
        'pop':[1.5,1.7,3.6,2.4,2.9]}
df = DataFrame(data)
df
	## pop   state  year
	## 0  1.5   Ohino  2000
	## 1  1.7   Ohino  2001
	## 2  3.6   Ohino  2002
	## 3  2.4  Nevada  2001
	## 4  2.9  Nevada  2002
	## 
	## [5 rows x 3 columns]
</code></pre>
</div>
<p>虽然参数 data 看起来是个字典，但字典的键并非充当 DataFrame 的 index 的角色，而是 Series 的 “name” 属性，且对Series按”name”进行了排序。这里生成的 index 仍是 “01234”。</p>

<p>较完整的 DataFrame 构造器参数为：DataFrame(data=None,index=None,coloumns=None)，columns 即 “name”，可以精确的按照你所传递的顺序排列Series。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df = DataFrame(data,index=['one','two','three','four','five'],
               columns=['year','state','pop','debt'])
df
	##        year   state  pop debt
	## one    2000   Ohino  1.5  NaN
	## two    2001   Ohino  1.7  NaN
	## three  2002   Ohino  3.6  NaN
	## four   2001  Nevada  2.4  NaN
	## five   2002  Nevada  2.9  NaN
	## 
	## [5 rows x 4 columns]
</code></pre>
</div>
<p>同样缺失值由 NaN 补上。看一下 index、columns 和 索引的类型。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df.index
	## Index(['one', 'two', 'three', 'four', 'five'], dtype='object')
df.columns
	## Index(['year', 'state', 'pop', 'debt'], dtype='object')
type(df['debt'])
	## &lt;class 'pandas.core.series.Series'&gt;
</code></pre>
</div>
<p>DataFrame 面向行和面向列的操作基本是平衡的，任意抽出一列都是 Series。</p>

<h3 id="section">对象属性</h3>

<ul>
  <li>查找索引</li>
</ul>

<p>查找某个值在数组Series中的索引，类似于 Python 内建的 list.index(value) 方法。可以通过布尔索引来实现。比如我们想在一个 Series 中寻找到 ‘c’：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ser = Series(list('abcdefg'))
ser[ser='c']
	## 2   c
	## dtype: object
</code></pre>
</div>
<p>Series 中还有一对 ser.idxmax() 和 ser.idxmin() 方法，可以返回数组中最大（小）值的索引值，或者 .argmin() 和 .argmax() 返回索引位置。当然这两类方法也是可以通过上面这种 ser[ser=ser.max()] 来替代实现的。</p>

<ul>
  <li>重新索引</li>
</ul>

<p>Series 对象的重新索引通过其 .reindex(index=None) 方法实现。它常用的参数有两个：method=None,fill_value=np.NaN：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ser = Series([4.5,7.2,-5.3,3.6],index=['d','b','a','c'])
a = ['a','b','c','d','e']
ser.reindex(a)
	## a   -5.3
	## b    7.2
	## c    3.6
	## d    4.5
	## e    NaN
	## dtype: float64
ser.reindex(a,fill_value=0)
	## a   -5.3
	## b    7.2
	## c    3.6
	## d    4.5
	## e    0.0
	## dtype: float64
ser.reindex(a,method='ffill')
	## a   -5.3
	## b    7.2
	## c    3.6
	## d    4.5
	## e    4.5
	## dtype: float64
ser.reindex(a,fill_value=0,method='ffill')
	## a   -5.3
	## b    7.2
	## c    3.6
	## d    4.5
	## e    4.5
	## dtype: float64
</code></pre>
</div>
<p>.reindex() 方法会返回一个新对象，其 index 严格遵循给出的参数，method:{‘backfill’, ‘bfill’, ‘pad’, ‘ffill’, None} 参数用于指定插值（填充）方式，当没有给出时，自动用 fill_value 填充，默认为 NaN（ffill = pad，bfill = back fill，分别指插值时向前还是向后取值）。</p>

<p>DataFrame 对象的重新索引方法为：.reindex(index=None,columns=None,**kwargs)。仅比 Series 多了一个可选的 columns 参数，用于给列索引。用法与上例类似，只不过插值方法 method 参数只能应用于行，即轴 0。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>state = ['Texas','Utha','California']
df.reindex(columns=state,method='ffill')
	## 	   Texas  Utha  California
	## a      1   NaN           2
	## c      4   NaN           5  
	## d      7   NaN           8

	## [3 rows x 3 columns]
df.reindex(index=['a','b','c','d'],columns=state,method='ffill')
	##    Texas  Utha  California
	## a      1   NaN           2
	## b      1   NaN           2
	## c      4   NaN           5
	## d      7   NaN           8
	## 
	## [4 rows x 3 columns]
</code></pre>
</div>

<p>不过 fill_value 依然对有效。聪明的小伙伴可能已经想到了，可不可以通过 df.T.reindex(index,method=’**’).T 这样的方式来实现在列上的插值呢，答案是可行的。另外要注意，使用 reindex(index,method=’**’) 的时候，index 必须是单调的，否则就会引发一个 ValueError: Must be monotonic for forward fill，比如上例中的最后一次调用，如果使用 index=[‘a’,’b’,’d’,’c’] 的话就不行。</p>

<ul>
  <li>删除指定轴上的项</li>
</ul>

<p>即删除 Series 的元素或 DataFrame 的某一行（列）的意思，通过对象的 .drop(labels, axis=0) 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ser = Series([4.5,7.2,-5.3,3.6],index=['d','b','a','c'])
ser
	## d    4.5
	## b    7.2
	## a   -5.3
	## c    3.6
	## dtype: float64
data = {'Ohio':[0,3,6],
        'Texas':[1,4,7],
        'California':[2,5,8]}
col= ['Ohio', 'Texas', 'California']
df = DataFrame(data,index=['a', 'c', 'd'],columns = cols)
df
	##    Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## d     6      7           8
	## 
	## [3 rows x 3 columns]
ser.drop('c')
	## d    4.5
	## b    7.2
	## a   -5.3
	## dtype: float64
df.drop('a')
	##    Ohio  Texas  California
	## c     3      4           5
	## d     6      7           8
	## 
	## [2 rows x 3 columns]
df.drop(['Ohio','Texas'],axis=1)
	## California
	## a           2
	## c           5
	## d           8
	## 
	## [3 rows x 1 columns]
</code></pre>
</div>
<p>.drop() 返回的是一个新对象，元对象不会被改变。</p>

<ul>
  <li>索引和切片</li>
</ul>

<p>就像 Numpy，pandas 也支持通过 obj[::] 的方式进行索引和切片，以及通过布尔型数组进行过滤。</p>

<p>不过须要注意，因为 pandas 对象的 index 不限于整数，所以当使用非整数作为切片索引时，它是末端包含的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo
	## a    4.5
	## b    7.2
	## c   -5.3
	## d    3.6
	## dtype: float64
bar
	## 0    4.5
	## 1    7.2
	## 2   -5.3
	## 3    3.6
	## dtype: float64
foo[:2]
	## a    4.5
	## b    7.2
	## dtype: float64
bar[:2]
	## 0    4.5
	## 1    7.2
	## dtype: float64
foo[:'c']
	## a    4.5
	## b    7.2
	## c   -5.3
	## dtype: float64
</code></pre>
</div>
<p>这里 foo 和 bar 只有 index 不同——bar 的 index 是整数序列。可见当使用整数索引切片时，结果与 Python 列表或 Numpy 的默认状况相同；换成 ‘c’ 这样的字符串索引时，结果就包含了这个边界元素。</p>

<p>另外一个特别之处在于 DataFrame 对象的索引方式，因为他有两个轴向（双重索引）。</p>

<p>可以这么理解：DataFrame 对象的标准切片语法为：.ix[:,:]。ix 对象可以接受两套切片，分别为行（axis=0）和列（axis=1）的方向：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df
	##    Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## d     6      7           8
	## 
	## [3 rows x 3 columns]
df.ix[:2,:2]
	##    Ohio  Texas
	## a     0      1
	## c     3      4
	## 
	## [2 rows x 2 columns]
df.ix['a','Ohio']
	## 0
</code></pre>
</div>

<p>而不使用 ix ，直接切的情况就特殊了。索引时，选取的是列；切片时，选取的是行这看起来有点不合逻辑，但作者解释说 “这种语法设定来源于实践”。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df['Ohio']
	## a    0
	## c    3
	## d    6
	## Name: Ohio, dtype: int32
df[:'c']
	##    Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## 
	## [2 rows x 3 columns]
df[:2]
	##    Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## 
	## [2 rows x 3 columns]
</code></pre>
</div>

<p>还有一种特殊情况是：假如有这样一个索引 index([2,4,5]) ，当我们使用 ser[2] 索引的时候，到底会被解释为第一个索引还是第三个索引呢？答案是第一个索引。当你使用整数索引，都会被自动解释为基于标签的索引，而不是基于位置的索引。</p>

<p>要想消除这种歧义，可以使用.loc[label] 这是严格基于标签的索引，而.iloc[inte] 则是严格基于整数位置的索引，.ix[] 更像是这两种严格方式的智能整合版。</p>

<p>使用布尔型数组的情况，注意行与列的不同切法（列切法的 : 不能省）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df['Texas']&gt;=4
	## a    False
	## c     True
	## d     True
	## Name: Texas, dtype: bool
df[df['Texas']&gt;=4]
	##     Ohio  Texas  California
	## c     3      4           5
	## d     6      7           8
	## 
	## [2 rows x 3 columns]
df.ix[:,df.ix['c']&gt;=4]
	##     Texas  California
	## a      1           2
	## c      4           5
	## d      7           8
	## 
	## [3 rows x 2 columns]
</code></pre>
</div>

<ul>
  <li>算术运算和数据对齐</li>
</ul>

<p>pandas 最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，结果的索引取索引对的并集。自动的数据对齐在不重叠的索引处引入空值，默认为 NaN。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = Series({'a':1,'b':2})
foo
	## a    1
	## b    2
	## dtype: int64
bar = Series({'b':3,'d':4})
bar
	## b    3
	## d    4
	## dtype: int64
foo + bar
	## a   NaN
	## b     5
	## d   NaN
	## dtype: float64
</code></pre>
</div>
<p>DataFrame 的对齐操作会同时发生在行和列上。</p>

<p>当不希望在运算结果中出现 NA 值时，可以使用前面 reindex 中提到过 fill_value 参数，不过为了传递这个参数，就需要使用对象的方法，而不是操作符：df1.add(df2,fill_value=0)。其他算术方法还有：sub(), div(), mul()。</p>

<ul>
  <li>函数应用和映射</li>
</ul>

<p>Numpy 的 ufuncs（元素级数组方法）也可用于操作 pandas 对象。</p>

<p>当希望将函数应用到 DataFrame 对象的某一行或列时，可以使用 .apply(func, axis=0, args=(), **kwds) 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>f = lambda x:x.max()-x.min()
df
    ##    Ohio  Texas  California
    ## a     0      1           2
    ## c     3      4           5
    ## d     6      7           8
	## 	
	## [3 rows x 3 columns]
df.apply(f)
	## Ohio          6
	## Texas         6
	## California    6
	## dtype: int64
df.apply(f,axis=1)
	## a    2
	## c    2
	## d    2
	## dtype: int64
</code></pre>
</div>

<ul>
  <li>排序和排名</li>
</ul>

<p>Series 的 sort_index(ascending=True) 方法可以对 index 进行排序操作，ascending 参数用于控制升序或降序，默认为升序。</p>

<p>若要按值对 Series 进行排序，应使用 .order(na_last=True, ascending=True, kind=’mergesort’) 方法，任何缺失值默认都会被放到 Series 的末尾。</p>

<p>在 DataFrame 上，.sort_index(axis=0, by=None, ascending=True) 方法多了一个轴向的选择参数与一个 by 参数，by 参数的作用是针对某一（些）列进行排序（不能对行使用 by 参数）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df.sort_index(by='Ohio')
	##    Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## d     6      7           8
	## 
	## [3 rows x 3 columns]
df.sort_index(by=['California','Texas'])
	## Ohio  Texas  California
	## a     0      1           2
	## c     3      4           5
	## d     6      7           8
	## 
	## [3 rows x 3 columns]
df.sort_index(axis=1)
	##    California  Ohio  Texas
	## a           2     0      1
	## c           5     3      4
	## d           8     6      7
	## 
	## [3 rows x 3 columns]
</code></pre>
</div>
<p>排名（Series.rank(method=’average’, ascending=True)）的作用与排序的不同之处在于，他会把对象的 values 替换成名次（从 1 到 n）。这时唯一的问题在于如何处理平级项，方法里的 method 参数就是起这个作用的，他有四个值可选：average, min, max, first。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ser=Series([3,2,0,3],index=list('abcd'))
ser
	## a    3
	## b    2
	## c    0
	## d    3
	## dtype: int64
ser.rank()
	## a    3.5
	## b    2.0
	## c    1.0
	## d    3.5
	## dtype: float64
ser.rank(method='min')
	## a    3
	## b    2
	## c    1
	## d    3
	## dtype: float64
ser.rank(method='max')
	## a    4
	## b    2
	## c    1
	## d    4
	## dtype: float64
ser.rank(method='first')
	## a    3
	## b    2
	## c    1
	## d    4
	## dtype: float64
</code></pre>
</div>
<p>注意在 ser[0]=ser[3] 这对平级项上，不同 method 参数表现出的不同名次。</p>

<p>DataFrame 的 .rank(axis=0, method=’average’, ascending=True) 方法多了个 axis 参数，可选择按行或列分别进行排名，暂时好像没有针对全部元素的排名方法。</p>

<ul>
  <li>统计方法</li>
</ul>

<p>pandas 对象有一些统计方法。它们大部分都属于约简和汇总统计，用于从 Series 中提取单个值，或从 DataFrame 的行或列中提取一个 Series。</p>

<p>比如 DataFrame.mean(axis=0,skipna=True) 方法，当数据集中存在 NA 值时，这些值会被简单跳过，除非整个切片（行或列）全是 NA，如果不想这样，则可以通过 skipna=False 来禁用此功能。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df
	##     one  two
	## a  1.40  NaN
	## b  7.10 -4.5
	## c   NaN  NaN
	## d  0.75 -1.3
	## 
	## [4 rows x 2 columns]
df.mean()
	## one    3.083333
	## two   -2.900000
	## dtype: float64
df.mean(axis=1)
	## a    1.400
	## b    1.300
	## c      NaN
	## d   -0.275
	## dtype: float64
df.mean(axis=1,skipna=False)
	## a      NaN
	## b    1.300
	## c      NaN
	## d   -0.275
	## dtype: float64
</code></pre>
</div>
<p><strong>常用的统计方法</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">count</td>
      <td style="text-align: left">非 NA 值的数量</td>
    </tr>
    <tr>
      <td style="text-align: left">describe</td>
      <td style="text-align: left">针对 Series 或 DF 的列计算汇总统计</td>
    </tr>
    <tr>
      <td style="text-align: left">min , max</td>
      <td style="text-align: left">最小值和最大值</td>
    </tr>
    <tr>
      <td style="text-align: left">argmin , argmax</td>
      <td style="text-align: left">最小值和最大值的索引位置（整数）</td>
    </tr>
    <tr>
      <td style="text-align: left">idxmin , idxmax</td>
      <td style="text-align: left">最小值和最大值的索引值</td>
    </tr>
    <tr>
      <td style="text-align: left">quantile</td>
      <td style="text-align: left">样本分位数（0 到 1）</td>
    </tr>
    <tr>
      <td style="text-align: left">sum</td>
      <td style="text-align: left">求和</td>
    </tr>
    <tr>
      <td style="text-align: left">mean</td>
      <td style="text-align: left">均值</td>
    </tr>
    <tr>
      <td style="text-align: left">median</td>
      <td style="text-align: left">中位数</td>
    </tr>
    <tr>
      <td style="text-align: left">mad</td>
      <td style="text-align: left">根据均值计算平均绝对离差</td>
    </tr>
    <tr>
      <td style="text-align: left">var</td>
      <td style="text-align: left">方差</td>
    </tr>
    <tr>
      <td style="text-align: left">std</td>
      <td style="text-align: left">标准差</td>
    </tr>
    <tr>
      <td style="text-align: left">skew</td>
      <td style="text-align: left">样本值的偏度（三阶矩）</td>
    </tr>
    <tr>
      <td style="text-align: left">kurt</td>
      <td style="text-align: left">样本值的峰度（四阶矩）</td>
    </tr>
    <tr>
      <td style="text-align: left">cumsum</td>
      <td style="text-align: left">样本值的累计和</td>
    </tr>
    <tr>
      <td style="text-align: left">cummin , cummax</td>
      <td style="text-align: left">样本值的累计最大值和累计最小值</td>
    </tr>
    <tr>
      <td style="text-align: left">cumprod</td>
      <td style="text-align: left">样本值的累计积</td>
    </tr>
    <tr>
      <td style="text-align: left">diff</td>
      <td style="text-align: left">计算一阶差分（对时间序列很有用）</td>
    </tr>
    <tr>
      <td style="text-align: left">pct_change</td>
      <td style="text-align: left">计算百分数变化</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>协方差与相关系数</li>
</ul>

<p>Series 有两个方法可以计算协方差与相关系数，方法的主要参数都是另一个 Series。DataFrame 的这两个方法会对列进行两两运算，并返回一个 len(columns) 大小的方阵：</p>

<p>.corr(other, method=’pearson’, min_periods=1) 相关系数，默认皮尔森
.cov(other, min_periods=None) 协方差
min_periods 参数为样本量的下限，低于此值的不进行运算。</p>

<ul>
  <li>列与 Index 间的转换</li>
</ul>

<p>DataFrame 的 .set_index(keys, drop=True, append=False, verify_integrity=False) 方法会将其一个或多个列转换为行索引，并返回一个新对象。默认 drop=True 表示转换后会删除那些已经变成行索引的列。另一个 .reset_index() 方法的作用正相反，会把已经层次化的索引转换回列里面。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>df = DataFrame(np.arange(8).reshape(4,2),columns=['a','b'])
df
	##    a  b
	## 0  0  1
	## 1  2  3
	## 2  4  5
	## 3  6  7
	## 
	## [4 rows x 2 columns]
df2 = df.set_index('a')
df2
	##    b
	## a   
	## 0  1
	## 2  3
	## 4  5
	## 6  7
	## 
	## [4 rows x 1 columns]
df2.reset_index()
	## 	  a  b
	## 0  0  1
	## 1  2  3
	## 2  4  5
	## 3  6  7
	## 
	## [4 rows x 2 columns]
</code></pre>
</div>

<h3 id="section-1">处理缺失数据</h3>
<p>pandas 中 NA 的主要表现为 np.nan，另外 Python 内建的 None 也会被当做 NA 处理。</p>

<p>处理 NA 的方法有四种：dropna , fillna , isnull , notnull 。</p>

<ul>
  <li>is(not)null</li>
</ul>

<p>这一对方法对对象做元素级应用，然后返回一个布尔型数组，一般可用于布尔型索引。</p>

<ul>
  <li>dropna</li>
</ul>

<p>对于一个 Series，dropna 返回一个仅含非空数据和索引值的 Series。</p>

<p>问题在于对 DataFrame 的处理方式，因为一旦 drop 的话，至少要丢掉一行（列）。这里的解决方式与前面类似，还是通过一个额外的参数：dropna(axis=0, how=’any’, thresh=None) ，how 参数可选的值为 any 或者 all。all 仅在切片元素全为 NA 时才抛弃该行(列)。另外一个有趣的参数是 thresh，该参数的类型为整数，它的作用是，比如 thresh=3，会在一行中至少有 3 个非 NA 值时将其保留。</p>

<ul>
  <li>fillna</li>
</ul>

<p>fillna(value=None, method=None, axis=0) 中的 value 参数除了基本类型外，还可以使用字典，这样可以实现对不同的列填充不同的值。method 的用法与前面 .reindex() 方法相同，这里不再赘述。</p>

<h3 id="inplace-">inplace 参数</h3>
<p>前面有个点一直没讲，结果整篇示例写下来发现还挺重要的。就是 Series 和 DataFrame 对象的方法中，凡是会对数组作出修改并返回一个新数组的，往往都有一个 replace=False 的可选参数。如果手动设定为 True，那么原数组就可以被替换。</p>

<h3 id="section-2">层次化索引</h3>
<p>层次化索引（hierarchical indexing）是 pandas 的一项重要功能，它允许你在一个轴上拥有多个索引级别。换句话说，一个使用了层次化的索引的二维数组，可以存储和处理三维以上的数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>hdf = DataFrame(np.arange(8).reshape(4,2),index=[['sh','sh','sz','sz'],['600000','600001','000001','000002']],columns=['open','close'])
hdf
	##            open  close
	## sh 600000     0      1
	##    600001     2      3
	## sz 000001     4      5
	##    000002     6      7
	## 
	## [4 rows x 2 columns]
hdf.index
	## MultiIndex(levels=[['sh', 'sz'], ['000001', '000002', '600000', '600001']],
	##            labels=[[0, 0, 1, 1], [2, 3, 0, 1]])
</code></pre>
</div>

<p>上例中原本 sh 和 sz 已经是第三维的索引了，但使用层次化索引后，可以将整个数据集控制在二维表结构中。这对于数据重塑和基于分组的操作（如生成透视表）比较重要。</p>

<p>索引或层次化索引对象（Index 与 MultiIndex）都有一个 names 属性，可以用来给索引层次命名，以便索引和增加直观性。对 names 属性的操作可以直接通过 obj.index.names=[] 的形式来实现。</p>

<p>-—--—-</p>

<p><strong>参考资料</strong></p>

<ol>
  <li><a href="http://my.oschina.net/lionets/blog/277847">Python 数据分析基础包：pandas 基础</a></li>
  <li><a href="https://pda.readthedocs.io/en/latest/chp5.html">2. pandas入门</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Numpy包的学习</title>
      <link>http://xukuang.github.io/blog/2016/04/numpy/</link>
      <pubDate>2016-04-27T21:04:53+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/numpy</guid>
      <content:encoded><![CDATA[<p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。其实它 本身并没有提供多么高级的数据结构和分析功能，但它是很多高级工具（如 pandas）构建的基础，在结构和操作上具有统一性，因此理解 Numpy 的数组及面向数组的计算有助于更加高效地使用诸如 pandas 之类的工具。</p>

<p>Numpy 的核心内容是它的多维数组对象——ndarray（N-Dimensions Array），整个包几乎都是围绕这个对象展开。</p>

<h3 id="ndarray">ndarray：多维数组对象</h3>
<p>Numpy 的 ndarray 提供了一种将同质数据块解释为多维数组对象的方式。同质，表示数组的元素必须都是相同的数据类型（如 int，float 等）；解释，表示 ndarray 的数据块其实是线性存储的，并通过额外的元信息解释为多维数组结构。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import pandas as pd
array1 = np.array([[ 0.9526, -0.246 , -0.8856], 
				   [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
</code></pre>
</div>

<p>上面是一个 2×3 的矩阵。在使用类似 2×3×4…这种格式表示多维数组的结构时，从左向右的数字对应表示由表及里的维度，或称为轴，按索引给轴编号后可称为“轴 0”、“轴 1”和“轴2”等）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
array1.strides
	## (24, 8)
</code></pre>
</div>
<p>这个矩阵的形状（shape）是（2,3）或 2×3，即它有 2 个长度为 3 的一维数组；它的 dtype 是 float64 表示它的单位元素是占 8 字节的浮点型；跨度（strides）元组指的是在某一维度下为了获取到下一个元素需要“跨过”的字节数。可见跨度是可以由 形状+dtype 来确定的。显然这种同质的静态数据结构在进行数值运算时效率要比 Python 内建的可以混杂动态类型的列表要快得多。</p>

<h3 id="ndarray-1">ndarray对象的创建</h3>
<p>创建数组的方法是使用array( )函数。它接受一切序列对象，产生一个包含所传递的数据的新ndarry数组，维度视序列的嵌套深度而定。首先，列表就是一个很好的用于转换的候选。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
</code></pre>
</div>

<p>嵌套序列，如等长列表的列表，将会转化为一个多维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
</code></pre>
</div>
<p>数组的 dtype 会由系统自动推定，除非你显式传递一个参数进去。系统一般会默认使用 int32 或 float64。
除 array() 之外，还有许多函数来创建新的数组。</p>

<p><strong>数组构建函数</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">array</td>
      <td style="text-align: left">转换输入数据（列表，数组或其它序列类型）为ndarray，可以推断一个dtype或明确的设置一个dtype，默认拷贝输入数据</td>
    </tr>
    <tr>
      <td style="text-align: left">asarray</td>
      <td style="text-align: left">将输入转换为 ndarray，若输入本身是 ndarray 就不拷贝</td>
    </tr>
    <tr>
      <td style="text-align: left">arange</td>
      <td style="text-align: left">同内建的range函数，但不返回的不是列表而是一个一维的ndarray</td>
    </tr>
    <tr>
      <td style="text-align: left">ones, ones_like</td>
      <td style="text-align: left">根据提供的shape和dtype产生一个全1的数组；ones_like使用另一个数组为参数，产生一个shape和dtype都相同的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">zeros, zeros_like</td>
      <td style="text-align: left">同ones和ones_like，但是生成一个全0的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">empty, enpty_like</td>
      <td style="text-align: left">创建新数组，但只分配内存空间不赋值</td>
    </tr>
    <tr>
      <td style="text-align: left">eye, identity</td>
      <td style="text-align: left">创建一个NxN的单位方阵（对角线上为1，其余为0）</td>
    </tr>
  </tbody>
</table>

<p>例如，zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
</code></pre>
</div>
<p>在 pandas 中尽量不要使用 np.empty()，这个函数创建的数组里面是有值的，除非你确定创建的这个数组能被完全赋值，否则后面运算起来很麻烦，这些“空值”的布尔类型是 True，而且 dropna() 方法删不掉。想创建空的 Series ，可以使用 Series(np.nan,index=???)。</p>

<p>arange 是python内建 range 函数的数组版本。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
</code></pre>
</div>

<h3 id="ndarray-">ndarray 对象的属性</h3>

<p>.reshape(shape)</p>

<p>此方法用于改变数组的形状。虽然我觉得既然 ndarray 对象的数据块都是线性存储的，按说调用 .reshape() 方法的话只需要改一下数据头中的 shape 属性就可以了啊，但实际上不是这样子的！<strong>a.reshape(shape, order=’C’) 方法会返回一个新数组，而不是直接改变调用者的形状</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.arange(9)
bar = foo.reshape((3,3))
bar
	## array([[0, 1, 2],
	##        [3, 4, 5],
	##        [6, 7, 8]])
foo
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8])
</code></pre>
</div>

<p>.astype(dtype)</p>

<p>这是一个用于转换数组 dtype 的方法，从前面的 ndarray 数据结构可以猜到，这种转换必然需要创建一个新数组。如果转换过程因为某种原因而失败了，就会引发一个 TypeError 异常。另外，如 np.int32() 这样把 dtype 当做函数来用也是可行的，但更推荐 .astype() 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bar.astype(float)
	## array([[ 0.,  1.,  2.],
	##        [ 3.,  4.,  5.],
	##        [ 6.,  7.,  8.]])
</code></pre>
</div>

<p>本例中使用 Python 内建的 float 当做 dtype 传了进去，也是可行的哦，当对数据大小不敏感时就可以这么做。</p>

<p>.transpose(*axes)</p>

<p>转置方法返回的是原数组的视图（不复制）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.arange(8).reshape(2,4)
foo
	## array([[0, 1, 2, 3],
	##        [4, 5, 6, 7]])
foo.transpose()
	## array([[0, 4],
	##        [1, 5],
	##        [2, 6],
	##        [3, 7]])
foo.T
	## array([[0, 4],
	##        [1, 5],
	##        [2, 6],
	##        [3, 7]])
</code></pre>
</div>
<p>因为对多维数组比较麻烦，这里就只先举个例子。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
</code></pre>
</div>

<p>数组的 .T 属性是轴对换的快捷方式。一般在计算矩阵点积时比较方便：np.dot(arr,att.T)。嗯，简单的乘法（星号）是广播运算，点积需要使用 dot() 函数。</p>

<p>.sort()</p>

<p>ndarray 的 .sort(axis=-1, kind=’quicksort’, order=None) 方法可用于给数组在指定轴向上排序。比如一个 （4，3，2）的数组，它的对应轴向分别为（2，1，0），方法默认的 axis=-1 代表最外层维度，如 “表” 里的 “行”。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>a = np.array([[1,4], [3,1]])
a
	## array([[1, 4],
	##        [3, 1]])
np.sort(a,0)
	## array([[1, 1],
	##        [3, 4]])
np.sort(a,1)
	## array([[1, 4],
	##        [1, 3]])
</code></pre>
</div>

<p>这里使用了外部函数 np.sort() 是为了在演示过程中不会影响到原数组。np.sort() 函数总是返回一份拷贝，而 .sort() 方法则会更改原数组。</p>

<h3 id="section">统计方法</h3>

<p>ndarray 对象还有一些统计方法，可以对整个数组或某个轴向上的数据进行统计计算（轴向数字越大代表的维度越高，从 0 开始计数）。这些方法同时也可以当做顶级函数使用。例如：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(12).reshape(3,4)
arr
	## array([[ 0,  1,  2,  3],
	##        [ 4,  5,  6,  7],
	##        [ 8,  9, 10, 11]])
arr.sum()
	## 66
np.sum(arr)
	## 66
arr.mean(0)
	## array([ 4.,  5.,  6.,  7.])
arr.mean(1)
	## array([ 1.5,  5.5,  9.5])
arr.mean(2)
	## Traceback (most recent call last):
	##   File "&lt;pyshell#35&gt;", line 1, in &lt;module&gt;
	##     arr.mean(2)
	##     items *= arr.shape[ax]
	## IndexError: tuple index out of range
</code></pre>
</div>

<p><strong>基本的数组统计方法</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">统计方法</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">sum</td>
      <td style="text-align: left">求和</td>
    </tr>
    <tr>
      <td style="text-align: left">mean</td>
      <td style="text-align: left">均值</td>
    </tr>
    <tr>
      <td style="text-align: left">std，var</td>
      <td style="text-align: left">标准差和方差</td>
    </tr>
    <tr>
      <td style="text-align: left">min，max</td>
      <td style="text-align: left">最小值和最大值</td>
    </tr>
    <tr>
      <td style="text-align: left">argmin，argmax</td>
      <td style="text-align: left">最小值和最大值的索引</td>
    </tr>
    <tr>
      <td style="text-align: left">cumsum</td>
      <td style="text-align: left">累积和</td>
    </tr>
    <tr>
      <td style="text-align: left">cumprod</td>
      <td style="text-align: left">累积积</td>
    </tr>
  </tbody>
</table>

<h3 id="section-1">索引和切片</h3>
<p>ndarray 的索引和切片语法与 Python 的列表相似。都是通过如 [0]，[0:5:2] 这样的方括号和 冒号来完成。比较不同之处在于为了方便对多维数组切片，ndarray 对象还支持使用逗号间隔的多维切片方法：[0,3]，[0,3:9:2]。</p>

<ul>
  <li>普通索引</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.arange(12)
foo
	## array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
foo[:5]
	## array([0, 1, 2, 3, 4])
foo[:5]=0
foo
	## array([ 0,  0,  0,  0,  0,  5,  6,  7,  8,  9, 10, 11])
bar = foo[:5]
bar[0] = 1024
bar
	## array([1024,    1,    2,    3,    4])
foo
	## array([1024,  0,  0,  0,  0,  5,  6,  7,  8,  9, 10, 11])
</code></pre>
</div>
<p>注意这里，为了节省内存，对 ndarray 的切片操作获得的都是对原数组的引用，因此对该引用的更改操作都会反映到原数组上，这也是与Python 的列表的一个重要的区别。如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想复制出一段副本，就应当使用 .copy() 方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>bar = foo[:5].copy()
bar[:] = 1
foo
	## array([1024,  0,  0,  0,  0,  5,  6,  7,  8,  9, 10, 11])
</code></pre>
</div>
<p>也许你会对这里的 foo[:] 感兴趣，这代表切全部的片，不可以使用 foo = 1 这样的赋值语句，这等于给 foo 重新指向一个新的内存地址，而非对切片元素进行操作。</p>

<p>前面提到的使用逗号在多维度下的切片方法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.arange(12).reshape(3,4)
foo
	## array([[ 0,  1,  2,  3],
	##        [ 4,  5,  6,  7],
	##        [ 8,  9, 10, 11]])
foo[0,1]
	## 1
foo[0,::2]
	## array([0, 2])
</code></pre>
</div>
<p>这种切片方法可以看做是一种语法糖『表示不懂』，因为最标准的对多维数组的切片方法应该是下面这样子的，包括 Python 原本对嵌套列表的切片方法也是这样子的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo
	## array([[ 0,  1,  2,  3],
	##        [ 4,  5,  6,  7],
	##        [ 8,  9, 10, 11]])
foo[0][1]
	## 1
foo[0][::2]
	## array([0, 2])
</code></pre>
</div>
<p>即 foo[0,1] 与 foo[0][1] 效果相同，这种实现可以节省时间，但不如原始方法更直观一点。只要记住对多维数组的单层切片总是切的最外层维度这点，操作起来就不容易乱。 例如，在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>arr3d[0] 是一个 2*3 的数组。</p>

<ul>
  <li>布尔型索引</li>
</ul>

<p>布尔型索引指的是使用一个布尔型数组而非 [::] 作为切片手段，操作会将被切片对象中对应于布尔型数组中 True 元素位置的元素返回，并总是返回一个新的副本。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.arange(12).reshape(3,4)
bar = foo.copy()
bar%2==0
	## array([[ True, False,  True, False],
	##        [ True, False,  True, False],
	##        [ True, False,  True, False]], dtype=bool)
foo[bar%2==0]
	## array([ 0,  2,  4,  6,  8, 10])
</code></pre>
</div>
<p>本例中一个值得注意之处在于 bar%2==0 这个表达式，在 Python 的标准语法中对一个列表和一个整型应用取余操作是非法的，你必须使用循环（如 for）遍历列表的单个元素才行。但 numpy 很贴心地通过广播解决了这个问题，吊不吊！
此外，在布尔索引中，你还可以使用 ！= 或 - 对条件表达式取反，使用 &amp; （and） 和 | （or）来结合多个布尔条件。</p>

<ul>
  <li>花式索引</li>
</ul>

<p>花式索引（fancy indexing）是一个 Numpy 术语，它指的是利用整数数组进行索引，这里的整数数组起到了index的作用。
如同布尔索引，花式索引也总是拷贝数据到一个新的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>foo = np.empty((8,4),int)
for i in range(8):
	foo[i] = i
foo
	## array([[0, 0, 0, 0],
	##        [1, 1, 1, 1],
	##        [2, 2, 2, 2],
	##        [3, 3, 3, 3],
	##        [4, 4, 4, 4],
	##        [5, 5, 5, 5],
	##        [6, 6, 6, 6],
	##        [7, 7, 7, 7]])
foo[[7,2,5]]
	## array([[7, 7, 7, 7],
	##        [2, 2, 2, 2],
	##        [5, 5, 5, 5]])
foo[[7,2,5],[0,2,2]]
	## array([7, 2, 5])
</code></pre>
</div>
<p>上例中 foo[[7,2,5],[0,2,2]] 处两个列表索引之间的逗号，所起的作用与上面普通索引处的作用相同，均为在更低一级维度上索引之用。</p>

<p>在花式索引中，使用负数表示从结尾选择行。</p>

<h3 id="section-2">通用函数</h3>
<p>通用函数（即 ufunc）是一种对 ndarray 执行元素级运算的函数。通用函数依据参数的数量不同，可分为一元（unary）函数和二元（binary）函数。（参数一般都是 ndarray 对象）。</p>

<p><strong>一元函数</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">abs，fabs</td>
      <td style="text-align: left">整数、浮点、复数的绝对值，对于非复数，可用更快的 fabs</td>
    </tr>
    <tr>
      <td style="text-align: left">sqrt</td>
      <td style="text-align: left">平方根，等于 arr**0.5</td>
    </tr>
    <tr>
      <td style="text-align: left">square</td>
      <td style="text-align: left">平方，等于 arr**2</td>
    </tr>
    <tr>
      <td style="text-align: left">exp</td>
      <td style="text-align: left">以 e 为底的指数函数</td>
    </tr>
    <tr>
      <td style="text-align: left">log，log10，log2，log1p</td>
      <td style="text-align: left">以 e 为底的对数函数</td>
    </tr>
    <tr>
      <td style="text-align: left">sign</td>
      <td style="text-align: left">计算各元素的正负号，1（正），0（零），-1（负）</td>
    </tr>
    <tr>
      <td style="text-align: left">ceil</td>
      <td style="text-align: left">计算大于等于该值的最小整数</td>
    </tr>
    <tr>
      <td style="text-align: left">floor</td>
      <td style="text-align: left">计算小于等于该值的最大整数</td>
    </tr>
    <tr>
      <td style="text-align: left">rint</td>
      <td style="text-align: left">round int，四舍五入到整数</td>
    </tr>
    <tr>
      <td style="text-align: left">modf</td>
      <td style="text-align: left">将数组的整数和小数部分以两个独立数组的形式返回</td>
    </tr>
    <tr>
      <td style="text-align: left">isnan</td>
      <td style="text-align: left">返回一个 “哪些值是 NaN” 的布尔型数组</td>
    </tr>
    <tr>
      <td style="text-align: left">isfinite，isinf</td>
      <td style="text-align: left">返回是否是有穷（无穷）的布尔型数组</td>
    </tr>
    <tr>
      <td style="text-align: left">cos，cosh，sin，sinh，tan，tanh</td>
      <td style="text-align: left">普通和双曲型三角函数</td>
    </tr>
    <tr>
      <td style="text-align: left">arccos，arccosh…等同上</td>
      <td style="text-align: left">反三角函数</td>
    </tr>
    <tr>
      <td style="text-align: left">logical_not</td>
      <td style="text-align: left">计算各元素 not x 的真值，等于 -arr</td>
    </tr>
    <tr>
      <td style="text-align: left">unique</td>
      <td style="text-align: left">计算元素唯一值并返回排序后的结果</td>
    </tr>
  </tbody>
</table>

<p><strong>二元函数</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">add</td>
      <td style="text-align: left">加法，+</td>
    </tr>
    <tr>
      <td style="text-align: left">subtract</td>
      <td style="text-align: left">减法，-</td>
    </tr>
    <tr>
      <td style="text-align: left">multiply</td>
      <td style="text-align: left">乘法，*</td>
    </tr>
    <tr>
      <td style="text-align: left">divide，floor_divide</td>
      <td style="text-align: left">除法和地板除，/ 和 //</td>
    </tr>
    <tr>
      <td style="text-align: left">power</td>
      <td style="text-align: left">乘方，**</td>
    </tr>
    <tr>
      <td style="text-align: left">maximum，fmax</td>
      <td style="text-align: left">元素级最大值，fmax 将忽略 NaN</td>
    </tr>
    <tr>
      <td style="text-align: left">minimum，fmin</td>
      <td style="text-align: left">同上</td>
    </tr>
    <tr>
      <td style="text-align: left">mod</td>
      <td style="text-align: left">取模，%</td>
    </tr>
    <tr>
      <td style="text-align: left">copysign</td>
      <td style="text-align: left">将第二数组元素的符号复制给第一数组</td>
    </tr>
    <tr>
      <td style="text-align: left">greater（<em>equal），less（_equal），（not</em>）equal</td>
      <td style="text-align: left">字面意义，返回布尔数组</td>
    </tr>
    <tr>
      <td style="text-align: left">logical_and，logical_or，logical_xor</td>
      <td style="text-align: left">字面意义，返回布尔数组</td>
    </tr>
  </tbody>
</table>

<p><strong>三元函数</strong></p>

<p>这里的三元函数只有一个，而且不是接受 3 个数组参数的意思。它其实是一个条件运算函数，即 foo if cond else bar 这个表达式的 numpy 版——where(condition, [x, y])</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(12).reshape(3,4)arr
	## array([[ 0,  1,  2,  3],
	##        [ 4,  5,  6,  7],
	##        [ 8,  9, 10, 11]])
np.where(arr%2==0,1,0)
	## array([[1, 0, 1, 0],
	##        [1, 0, 1, 0],
	##        [1, 0, 1, 0]])
</code></pre>
</div>

<p>- - - - -</p>

<p><strong>参考资料</strong></p>

<ol>
  <li><a href="http://my.oschina.net/lionets/blog/276574">Python 数据分析基础包：Numpy</a></li>
  <li><a href="http://pda.readthedocs.io/en/latest/chp4.html">NumPy Basics: Arrays and Vectorized Computation</a></li>
</ol>

]]></content:encoded>
    </item>
    
    <item>
      <title>实用的R函数</title>
      <link>http://xukuang.github.io/blog/2016/04/dots-in-r/</link>
      <pubDate>2016-04-21T23:46:58+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/dots-in-r</guid>
      <content:encoded><![CDATA[<p>这篇文章记录的是在使用R的过程中偶然遇到的非常实用的函数，然而由于这些函数在自己的学习中太常用特别容易忘记，所以这里记下来以便以后使用的时候可以查看。学无止境，长期更新。</p>

<h2 id="section">场景一</h2>
<p>在查看多个变量之间的两两相关性的时候，可以使用picante包中的cor.table()函数。</p>

<h2 id="section-1">场景二</h2>
<p>在R中加载了多个R包时，希望查看当前环境中都加载了哪些R包的find.package()函数，临时卸载某个R包可以使用函数detach(package:包名)。如要卸载dplyr包，则为detach(package:dplyr)。</p>

<h2 id="section-2">场景三</h2>
<p>expand.grid()用来建立一些factor相乘出来的矩阵或data.frame。<!--more--></p>

<div class="highlighter-rouge"><pre class="highlight"><code>expand.grid(x = c('A', 'B', 'C', 'D'), y = 1:3)
	#    x y
	# 1  A 1
	# 2  B 1
	# 3  C 1
	# 4  D 1
	# 5  A 2
	# 6  B 2
	# 7  C 2
	# 8  D 2
	# 9  A 3
	# 10 B 3
	# 11 C 3
	# 12 D 3
</code></pre>
</div>

<h2 id="section-3">场景四</h2>
<p>使用with()和within()函数对数据框列引用时，可以不用再输入长长的数据框名了。两者的区别在于，with只是生成了一列数据，而within生成一个包含原始数据的数据框。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>with(dat, y + 2)
	# [1] 4 5 6 7
within(dat, {z = y + 2; a = x + 3})
	#   x y a z
	# 1 1 2 4 4
	# 2 2 3 5 5
	# 3 3 4 6 6
	# 4 4 5 7 7
</code></pre>
</div>

<h2 id="section-4">场景五</h2>
<p>cut()函数可以把连续变量离散化，即numeric型的数据转换成factor型，可以与table()函数一起使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(x, breaks, labels = NULL,
    include.lowest = FALSE, right = TRUE, dig.lab = 3,
    ordered_result = FALSE, ...)
</code></pre>
</div>

<p><strong>主要参数</strong></p>

<p>x: 需要离散化的连续型向量</p>

<p>breaks: 向量类型，指定分类指标。默认的情况下，左开右闭合，这里可以结合正无穷(+Inf)和负无穷使用</p>

<p>labels：向量类型，指定分类指标的名称。如果不限定，则默认用分类指标为名称</p>

<p>inlude.lowest: 逻辑类型，指定边界是否闭合，默认的是边界不闭合</p>

<p>right: 逻辑类型，指定左开右闭合还是右开左闭合，默认的是TURE，左开右闭合</p>

<p>dig.lab: 数字，指定分类指标名称的数字位数。默认情况下，当labels为NULL时，指标名称的数字只显示3位</p>

<p>orederd_result: 逻辑类型，指定分类指标是否有序</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf))
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] (2.22,5] (5,Inf]

## 边界闭合，即包含左端的1
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), include.lowest = T)
	#  [1] [1,2.22] (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  [1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] [1,2.22] (5,Inf] 
	# Levels: [1,2.22] (2.22,5] (5,Inf]

## 左闭合右开
cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), right = F)
	#  [1] [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [5,Inf)  [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [2.22,5) [1,2.22) [5,Inf) 
	# Levels: [1,2.22) [2.22,5) [5,Inf)

## 指定分类名称
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), labels = c('small', 'middle', 'big'))
	#  [1] &lt;NA&gt;   middle middle big    big    small  middle big    big    middle &lt;NA&gt;   big   
	# Levels: small middle big

## 分类指标有序
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), ordered_result = T)
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] &lt; (2.22,5] &lt; (5,Inf]
</code></pre>
</div>

<h2 id="section-5">场景六</h2>
<p>求导数的函数。dxy=deriv(f~x^2+y^2,c(‘x’,’y’),func=T)</p>

<h2 id="section-6">场景七</h2>
<p>split()函数能将数据框按某一列分为包含若干个数据框的列表。然后，unsplit()可以将这个列表合并。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>data.table的包的简单介绍</title>
      <link>http://xukuang.github.io/blog/2016/04/data-table-in-R/</link>
      <pubDate>2016-04-13T21:56:01+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-table-in-R</guid>
      <content:encoded><![CDATA[<p>相比dplyr包，data.table包能够更大程度地提高数据的处理速度，这里就简单介绍一下data.tale包的使用方法。</p>

<h2 id="section">数据的读取</h2>
<p>data.table包中数据读取的函数是fread()。</p>

<h2 id="datatable-">data.table 的创建</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>library(data.table)
DT = data.table(x=rep(c("a","b","c"),each=3), y=c(1,3,6), v=1:9)
DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
</code></pre>
</div>
<!--more-->

<h2 id="section-1">基础操作</h2>

<h3 id="section-2">行提取</h3>
<p>行提取分为单行提取和多行提取。</p>

<h4 id="section-3">单行提取</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2]                      # 2nd row
	#    x y v
	# 1: a 3 2
DT[2,]                     # same
	#    x y v
	# 1: a 3 2
</code></pre>
</div>
<p>这里DT[2]和DT[2,]是完全相同的，这里的『,』只是说明还有其他参数可设置，而其他参数按默认值进行计算。下文所有这样的最后一个『,』都不再写出来。</p>

<h4 id="section-4">多行提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[1:2]
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
DT[c(2,5)]
	#   x y v
	#1: a 3 2
	#2: b 3 5
</code></pre>
</div>

<ul>
  <li>逻辑提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[c(FALSE,TRUE)]          # even rows (usual recycling)
	#    x y v
	# 1: a 3 2
	# 2: b 1 4
	# 3: b 6 6
	# 4: c 3 8
</code></pre>
</div>

<p>此时,c(FALSE,TRUE)会自己重复匹配成与DT的行数相同的向量</p>

<h3 id="section-5">列提取</h3>
<p>与行提取相同，列的提取也包含单列提取和多列提取。</p>

<h4 id="section-6">单列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>数字提取时，一定要把wth参数设置为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2,with=FALSE]          # 2nd column
	#    y
	# 1: 1
	# 2: 3
	# 3: 6
	# 4: 1
	# 5: 3
	# 6: 6
	# 7: 1
	# 8: 3
	# 9: 6
</code></pre>
</div>

<ul>
  <li>列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(v)]               # v column (as data.table
	#    v
	# 1: 1
	# 2: 2
	# 3: 3
	# 4: 4
	# 5: 5
	# 6: 6
	# 7: 7
	# 8: 8
	# 9: 9
</code></pre>
</div>

<h3 id="section-7">列名的修改</h3>
<p>列名的修改可以使用setnames()函数，这个函数好像比对data.frame类型数据名更改的names()和colnames()函数也要快一些。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dt = data.table(a=1:2,b=3:4,c=5:6) # compare to data.table
try(tracemem(dt))                  # by reference, no deep or shallow copies
setnames(dt,"b","B")               # by name, no match() needed (warning if "b" is missing)
setnames(dt,3,"C")                 # by position with warning if 3 &gt; ncol(dt)
setnames(dt,2:3,c("D","E"))        # multiple
setnames(dt,c("a","E"),c("A","F")) # multiple by name (warning if either "a" or "E" is missing)
setnames(dt,c("X","Y","Z"))        # replace all (length of names must be == ncol(DT))  
</code></pre>
</div>

<h4 id="section-8">多列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>如同上面对按数字对单列的提取，对多列提取也要设置with参数为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2:3,with=FALSE]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
DT[,c(1,3),with=FALSE] 
	#    x v
	# 1: a 1
	# 2: a 2
	# 3: a 3
	# 4: b 4
	# 5: b 5
	# 6: b 6
	# 7: c 7
	# 8: c 8
	# 9: c 9      
</code></pre>
</div>

<ul>
  <li>按列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(y, v)]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
</code></pre>
</div>

<p>如果按列名提取时，不使用列表，仍然能对列进行提取，只是结果以向量的形式输出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,v]                     # v column (as vector)
	# [1] 1 2 3 4 5 6 7 8 9
DT[,c(v)]                  # same
	# [1] 1 2 3 4 5 6 7 8 9   
DT[, c(y, v)]
	# [1] 1 3 6 1 3 6 1 3 6 1 2 3 4 5 6 7 8 9
</code></pre>
</div>

<h3 id="section-9">列的添加与删除</h3>

<h4 id="section-10">列的添加</h4>

<ul>
  <li>单列添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
DT[, a := 'k']
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
DT[,c:=8]        # add a numeric column, 8 for all rows
DT
	#    x y v a c
	# 1: a 1 1 k 8
	# 2: a 3 2 k 8
	# 3: a 6 3 k 8
	# 4: b 1 4 k 8
	# 5: b 3 5 k 8
	# 6: b 6 6 k 8
	# 7: c 1 7 k 8
	# 8: c 3 8 k 8
	# 9: c 6 9 k 8 
DT[,d:=9L]       # add an integer column, 9L for all rows
DT[2,d:=10L]     # subassign by reference to column d
DT
	#    x y v a c  d
	# 1: a 1 1 k 8  9
	# 2: a 3 2 k 8 10
	# 3: a 6 3 k 8  9
	# 4: b 1 4 k 8  9
	# 5: b 3 5 k 8  9
	# 6: b 6 6 k 8  9
	# 7: c 1 7 k 8  9
	# 8: c 3 8 k 8  9
	# 9: c 6 9 k 8  9
DT[, e := d + 2]
DT
	#    x y v a c  d  e
	# 1: a 1 1 k 8  9 11
	# 2: a 3 2 k 8 10 12
	# 3: a 6 3 k 8  9 11
	# 4: b 1 4 k 8  9 11
	# 5: b 3 5 k 8  9 11
	# 6: b 6 6 k 8  9 11
	# 7: c 1 7 k 8  9 11
	# 8: c 3 8 k 8  9 11
	# 9: c 6 9 k 8  9 11
</code></pre>
</div>
<p>如果添加的列名，数据中已经包含则是对这一列数据的修改。</p>

<ul>
  <li>多列的添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[, c('f', 'g') := list( d + 1, c)]
DT[, ':='( f =  d + 1, g = c)]          # same
DT
	#    x y v a c  d  e  f g
	# 1: a 1 1 k 8  9 11 10 8
	# 2: a 3 2 k 8 10 12 11 8
	# 3: a 6 3 k 8  9 11 10 8
	# 4: b 1 4 k 8  9 11 10 8
	# 5: b 3 5 k 8  9 11 10 8
	# 6: b 6 6 k 8  9 11 10 8
	# 7: c 1 7 k 8  9 11 10 8
	# 8: c 3 8 k 8  9 11 10 8
	# 9: c 6 9 k 8  9 11 10 8
</code></pre>
</div>
<p>此处，需要注意的是新创建的列只能依照原有数据列，而不能依照新创建的列。例如这个例子中，g = c是可以运行，而g = f则会提示错误。</p>

<h4 id="section-11">列的删除</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c:=NULL]     # remove column c
DT
	#    x y v a  d  e  f g
	# 1: a 1 1 k  9 11 10 8
	# 2: a 3 2 k 10 12 11 8
	# 3: a 6 3 k  9 11 10 8
	# 4: b 1 4 k  9 11 10 8
	# 5: b 3 5 k  9 11 10 8
	# 6: b 6 6 k  9 11 10 8
	# 7: c 1 7 k  9 11 10 8
	# 8: c 3 8 k  9 11 10 8
	# 9: c 6 9 k  9 11 10 8
DT[, c('d', 'e', 'f', 'g'):=NULL]     
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h2 id="section-12">列指标的简单操作</h2>
<p>简单操作主要包括求和、平均值、方差和标准差等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2:3,sum(v)]             # sum(v) over rows 2 and 3
# [1] 5
DT[2:3,mean(v)]             # sum(v) over rows 2 and 3
# [1] 2.5
</code></pre>
</div>

<h2 id="key">索引key</h2>

<h3 id="section-13">查看和创建索引</h3>
<p>索引是对列而言的，索引创建后，数据将自动按索引值进行重新排序，所以每个数据最多只能有一个索引，但是索引可以由多列组成，这些列可以是数字、因子、字符串或其他格式。</p>

<h4 id="section-14">单列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>
## methdod first
key(DT)                    # key
	# NULL 
setkey(DT,x)               # set a 1-column key. No quotes, for convenience.
key(DT)
[1] "x"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k

## method second
setkeyv(DT,"y")            # same (v in setkeyv stands for vector)
key(DT)
	# [1] "y"
</code></pre>
</div>
<p>一旦对数据进行新的索引，原有的索引将消失。</p>

<h4 id="section-15">多列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## methdod first                    # key 
setkey(DT,x,v)               # set a 1-column key. No quotes, for convenience.
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k


## method second
setkeyv(DT,c("x", "y"))           # same (v in setkeyv stands for vector)
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h3 id="section-16">通过索引进行数据的提取</h3>
<p>按照索引对数据提取，可以加快提取数据的速度。</p>

<h4 id="section-17">单索引</h4>
<p>正向提取</p>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x)
DT["a"]                    # binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.(x=="a")]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[x=="a"]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[!.("a")]                # not join
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!"a"]                   # same
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!2:4]                   # all rows other than 2:4
	#    x y v a
	# 1: a 1 1 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k

</code></pre>
</div>

<h4 id="section-18">多索引</h4>

<ul>
  <li>正向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x, y)
# Mehtod First
DT["a"]                    # join to 1st column of key
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a")]                 # same, .() is an alias for list()
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a",3)]               # join to 2 columns
    #    x y v a
	# 1: a 3 2 k
DT[.("a",3:6)]             # join 4 rows (2 missing)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[.("a",3:6),nomatch=0]   # remove missing
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[.("a",3:6),roll=TRUE]   # rolling join (locf)
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k

## Method Second
DT[J('a')]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[J("a",3)]               # binary search (fast)
	#    x y v a
	# 1: a 3 2 k
DT[J("a",3:6)]              # same; i.e. binary search (fast)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[J("a",3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[J("a",3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k


## Method Third
DT[list("a")]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[list("a",3)]
    #    x y v a
	# 1: a 3 2 k
DT[list("a", 3:6)]
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[list("a", 3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[list("a", 3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[x!="b" | y!=3]          # not yet optimized, currently vector scans
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k
DT[!.("b",3)]              # same result but much faster
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k

</code></pre>
</div>

<h2 id="section-19">分类汇总</h2>
<p>分类汇总是指按某列的分类指标进行简单操作，这里借助by参数实现。此外，by参数与索引相互没有影响。</p>

<h3 id="section-20">单指标的分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum(v),by=x]
	#    x V1
	# 1: a  6
	# 2: b 15
	# 3: c 24           
DT[,sum(v),by=y] 
	#    y V1
	# 1: 1 12
	# 2: 3 15
	# 3: 6 18          
</code></pre>
</div>
<ul>
  <li>自定义汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(sum.v.x = sum(v)),by=x]
	#    x sum.v.x
	# 1: a       6
	# 2: b      15
	# 3: c      24           
DT[,list(sum.v.y = sum(v)),by=y] 
	#    y sum.v.y
	# 1: 1      12
	# 2: 3      15
	# 3: 6      18 
DT[,sum.v.y := sum(v) ,by=y]
	#    x y v a sum.v.y
	# 1: a 1 1 k      12
	# 2: a 3 2 k      15
	# 3: a 6 3 k      18
	# 4: b 1 4 k      12
	# 5: b 3 5 k      15
	# 6: b 6 6 k      18
	# 7: c 1 7 k      12
	# 8: c 3 8 k      15
	# 9: c 6 9 k      18 	
</code></pre>
</div>

<ul>
  <li>汇总结果与原始数据进行匹配</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum.v.y := sum(v) ,by=y]
	#    x y v a sum.v.y
	# 1: a 1 1 k      12
	# 2: a 3 2 k      15
	# 3: a 6 3 k      18
	# 4: b 1 4 k      12
	# 5: b 3 5 k      15
	# 6: b 6 6 k      18
	# 7: c 1 7 k      12
	# 8: c 3 8 k      15
	# 9: c 6 9 k      18
</code></pre>
</div>

<h3 id="section-21">多指标的多个分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean(v),sum(v)),by=list(x,y)]   # keyed by
	#    x y V1 V2
	# 1: a 1  1  1
	# 2: a 3  2  2
	# 3: a 6  3  3
	# 4: b 1  4  4
	# 5: b 3  5  5
	# 6: b 6  6  6
	# 7: c 1  7  7
	# 8: c 3  8  8
	# 9: c 6  9  9
</code></pre>
</div>

<ul>
  <li>自定义汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean.v = mean(v),sum.v = sum(v)),by=list(x,y)]   # keyed by
	#   x y mean.v sum.v
	#1: a 1      1     1
	#2: a 3      2     2
	#3: a 6      3     3
	#4: b 1      4     4
	#5: b 3      5     5
	#6: b 6      6     6
	#7: c 1      7     7
	#8: c 3      8     8
	#9: c 6      9     9
</code></pre>
</div>

<ul>
  <li>汇总结果与原始数据进行匹配</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c("mean.v", "sum.v.y") := list(mean(v),sum(v)) ,by=list(x,y)]
	#    x y v a sum.v.y mean.v
	# 1: a 1 1 k       1      1
	# 2: a 3 2 k       2      2
	# 3: a 6 3 k       3      3
	# 4: b 1 4 k       4      4
	# 5: b 3 5 k       5      5
	# 6: b 6 6 k       6      6
	# 7: c 1 7 k       7      7
	# 8: c 3 8 k       8      8
	# 9: c 6 9 k       9      9

</code></pre>
</div>

<h2 id="datatabledataframe">data.table与data.frame的转化</h2>
<p>data.table格式加快了处理速度，而data.frame则更为基础。两者的转化可以通过data.table(),setDT()和setDT()来实现，其中data.table()和setDT()函数可以将数据从data.frame转化为data.table，setDF()函数可以将数据从data.table转化为data.frame。注意使用data.table(),setDT()和setDT()时，参数本身的数据类型也会发生变化。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class(DT)
	# [1] "data.table" "data.frame"  
class(setDF(DT))
	# [1] "data.frame"
class(DT)
	# [1] "data.frame"
</code></pre>
</div>
<p>此外，data.table包还可以与基础包中的duplicated()、unique()、subset() 函数结合使用。 不仅如此，data.table包还有一些基础包的替代函数。rbind()升级版的rbindlist()，可以合并列数不同和列位置不同的数据。比dplyr包中arrange()函数更快的setorder()排序函数。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>长宽数据之间的转化(二)</title>
      <link>http://xukuang.github.io/blog/2016/04/data-fomrat/</link>
      <pubDate>2016-04-10T18:32:19+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-fomrat</guid>
      <content:encoded><![CDATA[<p>前面一篇<a href="http://xukuang.github.io/2016/01/18/melt-and-dcast/">文章</a>讲了用reshape2包中的函数实现长宽数据的转化，而tidyr是reshape2的升级版，主要用于数据框。这篇文章将介绍一下如何使用tidyr包中的函数实现长宽数据的转化。</p>

<h2 id="section">1. 宽数据转化为长数据</h2>

<h3 id="gather">gather函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>gather(data, key, value, ..., na.rm = FALSE, convert = FALSE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定转化后数据框的指标列的列名，用于存放原数据中不同的数据指标</p>

<p><strong>value</strong>  指定转化后数据框的数据列的列名，用于存放原数据中不同的数据指标对应的值</p>

<p><strong>…</strong> 指定哪些列聚到一列中。按那些列数据作为标准转化，这个参数接不能有那些列</p>

<p><strong>na.rm</strong> 确定是否去除数据中的NA，默认情况下为FALSE，不去除NA
<!--more--></p>

<h3 id="section-1">实例</h3>

<ul>
  <li>将所有列排成长数据(默认情况下)</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 加载数据
library(reshape2)
head(airquality)
	# 	Month Day variable value
	# 1     5   1    Ozone    41
	# 2     5   2    Ozone    36
	# 3     5   3    Ozone    12
	# 4     5   4    Ozone    18
	# 5     5   5    Ozone    NA
	# 6     5   6    Ozone    28
dim(airquality)
	# [1] 612   4
library(tidyr)
dat1 = gather(airquality, time, value)
head(dat1)
    #    time value
    # 1 Ozone    41
    # 2 Ozone    36
    # 3 Ozone    12
    # 4 Ozone    18
    # 5 Ozone    NA
    # 6 Ozone    28
tail(dat1)
    #         time value
    # 913  Day    25
    # 914  Day    26
    # 915  Day    27
    # 916  Day    28
    # 917  Day    29
    # 918  Day    30
dim(dat1)	
	# [1] 918   2
</code></pre>
</div>

<ul>
  <li>按Month将其他指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 方法一
dat2 = gather(airquality, time, value, Ozone:Temp, Day)
# 方法二
dat2 = gather(airquality, time, value, -Month)
head(dat2)
	#    Month Day  time value
	# 1     5   1 Ozone    41
	# 2     5   2 Ozone    36
	# 3     5   3 Ozone    12
	# 4     5   4 Ozone    18
	# 5     5   5 Ozone    NA
	# 6     5   6 Ozone    28
tail(dat2)
	#     Month Day time value
	# 607     9  25 Temp    63
	# 608     9  26 Temp    70
	# 609     9  27 Temp    77
	# 610     9  28 Temp    75
	# 611     9  29 Temp    76
	# 612     9  30 Temp    68
</code></pre>
</div>

<ul>
  <li>按Month和Day列将其它列指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dat3 = gather(airquality, type, value.type, Ozone:Temp)
dat3 = gather(airquality, type, value.type, -Month, -Day)
head(dat3) 
	# 	 Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 5     5   5 Ozone         NA
	# 6     5   6 Ozone         28
dim(dat3)
	# [1] 612   4
</code></pre>
</div>

<ul>
  <li>去除排列后数据中的NA</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>#　 airquality$Ozone 数的前四列有44 个NA
table(is.na(airquality$Ozone)) # 37
	# FALSE  TRUE 
	#   116    37 
table(is.na(airquality$Solar.R)) # 4
	# FALSE  TRUE 
	#   146     7 
table(is.na(airquality$Temp)) # 0
	# FALSE 
	#   153 
table(is.na(airquality$Wind)) # 0
	# FALSE 
	#   153 
dat4 = gather(airquality, type, value.type, Ozone:Temp, na.rm = TRUE)
head(dat4)
	#   Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 6     5   6 Ozone         28
	# 7     5   7 Ozone         23
dim(dat4)# 比dat3少44行
	# [1] 568   4	
</code></pre>
</div>

<h2 id="section-2">2. 长数据转化为宽数据</h2>

<h3 id="spread">spread函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定需要将变量值拓展为字段的变量</p>

<p><strong>value</strong>  指定要分散的值</p>

<p><strong>fill</strong> 确认不存在的组合值的显示结果。默认的显示为NA。数据类型为数值型向量</p>

<p><strong>drop</strong> 确认不存在分分类组合是否显示，默认情况下显示。当然，如果drop = T，那么fill参数的设置将失去意义</p>

<h3 id="section-3">实例</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">air1</span> <span class="o">=</span>  <span class="n">spread</span><span class="p">(</span><span class="n">dat4</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">value.type</span><span class="p">)</span>
<span class="n">dim</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span>
	<span class="c1"># [1] 153   6
</span><span class="n">head</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span> <span class="c1"># 数据与airquality相同
</span>	<span class="c1"># 	Month Day Ozone Solar.R Wind Temp
</span>	<span class="c1"># 1     5   1    41     190  7.4   67
</span>	<span class="c1"># 2     5   2    36     118  8.0   72
</span>	<span class="c1"># 3     5   3    12     149 12.6   74
</span>	<span class="c1"># 4     5   4    18     313 11.5   62
</span>	<span class="c1"># 5     5   5    NA      NA 14.3   56
</span>	<span class="c1"># 6     5   6    28      NA 14.9   66
</span></code></pre>
</div>

<p>不存在的分类是否显示，以及怎么显示</p>

<div class="highlighter-rouge"><pre class="highlight"><code>air5 = spread(dat4, type, value.type, drop = F) # 组合上存在的结果都显示
tail(air5) # 这里的最后一行只是组合上存在，原数据中并不在
	# 		 Month Day Ozone Solar.R Wind Temp
	# 150      9  26     1       1    1    1
	# 151      9  27     1       1    1    1
	# 152      9  28     1       1    1    1
	# 153      9  29     1       1    1    1
	# 154      9  30     1       1    1    1
	# 155      9  31     0       0    0    0
tail(spread(dat4, type, value.type, drop = F, fill= -1)) # 更改不存在结果的显示值，最后一行显示为-1
	# 		Month Day Ozone Solar.R Wind Temp
	# 150     9  26     1       1    1    1
	# 151     9  27     1       1    1    1
	# 152     9  28     1       1    1    1
	# 153     9  29     1       1    1    1
	# 154     9  30     1       1    1    1
	# 155     9  31    -1      -1   -1   -1
</code></pre>
</div>

<h2 id="tidyr">tidyr包中的其它函数</h2>

<h3 id="seperate">seperate函数</h3>

<p>unite()函数可将多列合并为一列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>unite(data, col, ..., sep = "_", remove = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 被组合的新列名称</p>

<p><strong>…</strong> 指定哪些列需要被组合</p>

<p><strong>sep</strong> 组合列之间的连接符，默认为下划线</p>

<p><strong>remove</strong> 是否删除被组合的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set.seed(10)
date &lt;- as.Date('2016-04-10') + 0:14
hour &lt;- sample(1:24, 15)
min &lt;- sample(1:60, 15)
second &lt;- sample(1:60, 15)
event &lt;- sample(letters, 15)
data &lt;- data.frame(date, hour, min, second, event)
data
	# 			date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n

dataNew &lt;- data %&gt;%
  unite(datehour, date, hour, sep = ' ') %&gt;%
  unite(datetime, datehour, min, second, sep = ':')
	#              datetime event
	#1  2016-04-10 13:26:33     e
	#2     2016-04-11 8:4:6     a
	#3  2016-04-12 10:16:10     l
	#4  2016-04-13 15:23:52     c
	#5   2016-04-14 2:47:24     r
	#6   2016-04-15 5:48:42     h
	#7  2016-04-16 19:34:45     s
	#8  2016-04-17 18:42:51     z
	#9  2016-04-18 22:19:36     i
	#10  2016-04-19 7:21:26     d
	#11 2016-04-20 16:36:14     j
	#12 2016-04-21 23:53:12     g
	#13  2016-04-22 20:12:1     o
	#14 2016-04-23 21:37:35     f
	#15  2016-04-24 4:17:49     n

</code></pre>
</div>
<p>tidyr包中的函数也可使用管道操作符%&gt;%。</p>

<h3 id="seperate-1">seperate函数</h3>
<p>separate()函数可将一列拆分为多列，一般可用于日志数据或日期时间型数据的拆分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 需要被拆分的列</p>

<p><strong>into</strong> 新建的列名，为字符串向量</p>

<p><strong>sep</strong> 被拆分列的分隔符</p>

<p><strong>remove</strong> 是否删除被分割的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dataold &lt;- dataNew %&gt;% 
  separate(datetime, c('date', 'time'), sep = ' ') %&gt;% 
  separate(time, c('hour', 'min', 'second'), sep = ':')
dataold
	# 		date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>简单线性回归中各指标在R中的计算</title>
      <link>http://xukuang.github.io/blog/2016/04/simple-linear-regression/</link>
      <pubDate>2016-04-07T22:50:50+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/simple-linear-regression</guid>
      <content:encoded><![CDATA[<h2 id="section">前话</h2>
<p>简单线性回归用于计算两个连续型变量(如X，Y)之间的线性关系，具体地说就是计算下面公式中的<script type="math/tex">\alpha和\beta</script>。</p>

<script type="math/tex; mode=display">Y = \alpha + \beta X + \varepsilon</script>

<p>其中<script type="math/tex">\varepsilon</script>称为残差,服从从<script type="math/tex">N(0,\sigma^2)</script>的正态分布，自由度为(n-1) - (2-1) = n-2
为了找到这条直线的位置，我们使用最小二乘法(least squares approach)。最小二乘法确保所有点处的残差的平方和最小时计算<script type="math/tex">\alpha和\beta</script>，即下面示意图中<script type="math/tex">\sum_{i=1}^{4}\varepsilon_i^2 = \varepsilon_1^2 + \varepsilon_2^2 + \varepsilon_3^2 + \varepsilon_4^2</script>有最小值。</p>

<p><img src="http://xukuang.github.io/blog/images/y_x_scatter_plot.png" alt="简单线性相关示意图" /><!--more--></p>

<h2 id="section-1">各指标的计算</h2>

<p>运用最小二乘法找出的这条最优直线一定经过点<script type="math/tex">(\overline{x}, \overline{y})</script>。其中</p>

<h3 id="betaalpha">斜率<script type="math/tex">\beta</script>和截距<script type="math/tex">\alpha</script>的估计值</h3>

<p><img src="http://xukuang.github.io/blog/images/beta.png" alt="" /></p>

<h3 id="pearsonr">Pearson相关系数r</h3>

<script type="math/tex; mode=display">r_{xy} = \frac{\overline{xy} - \bar{x}\bar{y} }{ \sqrt{ \left(\overline{x^2} - \bar{x}^2\right)\left(\overline{y^2} - \bar{y}^2\right)}}</script>

<h3 id="section-2">方差分析</h3>
<p>在方差分析(ANOVA)中，总的平方和包含回归平方和残差平方和两部分。</p>

<ul>
  <li>总的平方和</li>
</ul>

<p><script type="math/tex">SS_{tot}=\sum_i (y_i-\bar{y})^2</script>
其自由度为 n - 1，这里n为观测点的个数。</p>

<ul>
  <li>回归的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{reg}=\sum_i (\hat y_i -\bar{y})^2</script>
其自由度为 2 - 1 = 1。</p>

<ul>
  <li>残差的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{res}=\sum_i (y_i - \hat y_i)^2=\sum_i e_i^2</script>
其自由度为 (n -1) - (2 - 1) = n -2。</p>

<h3 id="section-3">决定系数(拟合优势度)</h3>

<p><img src="http://xukuang.github.io/blog/images/error.png" alt="" />
决定系数是用来表示模型的解释度，理论上与相关系数没有关系，只是在简单线性回归中，决定系数$R^2 $值等于Pearson相关系数r的平方。</p>

<h2 id="r">R中的实现</h2>

<h3 id="section-4">线性模拟</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>x = c(0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.23)
y = c(42.0, 43.5, 45.0, 45.5, 45.0, 47.5, 49.0, 53.0, 50.0, 55.0, 55.0, 60.0)
fit = lm(y ~ x)
summary(fit)
	## Call:
	## lm(formula = y ~ x)
	## 
	## Residuals:
	##	 #Min      1Q  Median      3Q     Max 
	## -2.0431 -0.7056  0.1694  0.6633  2.2653 
	## 
	## Coefficients:
	## 				#Estimate Std. Error t value Pr(&gt;|t|)    
	## (Intercept)   28.493      1.580   18.04 5.88e-09 ***
	## x            130.835      9.683   13.51 9.50e-08 ***
	## ---
	## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
	## 
	## Residual standard error: 1.319 on 10 degrees of freedom
	## Multiple R-squared:  0.9481,    Adjusted R-squared:  0.9429 
	## F-statistic: 182.6 on 1 and 10 DF,  p-value: 9.505e-08
anova(fit)
	##Analysis of Variance Table
	##
	##Response: y
	##			#Df Sum Sq Mean Sq F value    Pr(&gt;F)    
	##x          1 317.82  317.82  182.55 9.505e-08 ***
	##Residuals 10  17.41    1.74                      
	##---
	##Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

</code></pre>
</div>

<h3 id="section-5">线性模拟各参数的提取</h3>

<div class="highlighter-rouge"><pre class="highlight"><code># 可以通过names函数查看summary(fit)中个具体参数的提取方法
names(summary(fit))
# 提取R square
summary(fit)$r.squared ## 依照该形式可以提取names(summary(fit))中任意指标
# 其它常用指标的提取
# 提取模型lm或glm提取回归系数
coefficients(fit)
# 还可简化为
coef(fit)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
resid(fit)
# 提取lm或glm对象中残差的平方和
deviance(fit)
# 提取lm或glm对象中的方差分析表
# 其中p值越小，差异越显著, beita1越不可能为0
anova(fit)
# 预测数据
new &lt;- data.frame(x=c(0.16, 2.3))
predict(fit, new)

## 也可以做出预测区间
predict(fit, new, interval = 'prediction', levels = 0.95)
</code></pre>
</div>

<h3 id="section-6">线性模拟各参数中各量的算法</h3>

<h4 id="section-7">五个和的计算</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 预备统计量(Sums of square and sums of producte)
Sx = sum(x)
Sy = sum(y)
Sxx = sum((x - mean(x))^2)
Syy = sum((y - mean(y))^2)
Sxy = sum((x - mean(x)) * (y - mean(y)))

## 这里仅仅作为补充,具体原因不是很清楚
Syy = deviance(lm(y~1))
n = length(x)
</code></pre>
</div>

<h4 id="section-8">回归系数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 回归系数$\alpha$和$beta$（这样计算，residuals有最小值)
beta = Sxy/Sxx
beta
alpha = mean(y) - beta*mean(x)
alpha
# 提取lm或glm对象中的回归系数
coef(fit)
</code></pre>
</div>

<h4 id="section-9">残差及五分位数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>residuals = y - (beta + alpha * x)
residuals
quantile(residuals)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
</code></pre>
</div>

<h4 id="pearsonr-1">Pearson相关系数r</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>r = sqrt(Sxy/(Sxx * Syy))
r
</code></pre>
</div>

<h4 id="r-1">R平方</h4>
<p>决定系数，其值为 回归的平方和/总的平方和。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rsquare = (Syy - sum(residuals^2))/Syy
rsquare
</code></pre>
</div>

<h4 id="adjust-r">adjust R平方</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 考虑到了自变量的个数, 包括截距在内, 本例子中k = 2
n = length(x)
k = 2
adjustrsquare = 1- (1-rsquare)*(n-1)/(n-k)
adjustrsquare
</code></pre>
</div>

<h3 id="f">回归方程的F检验</h3>
<p>在简单线性回归的模型，我们可以在<script type="math/tex">β = 0</script>时，对F统计量进行检验。
在F检验中统计量F</p>

<script type="math/tex; mode=display">F = \frac{(回归的平方和/回归的自由度)}{(误差的平方和/误差的自由度}</script>

<p>对应p值越小，说明此时越小的概率时间发生了，越不能接受原假设。</p>

<h3 id="t">斜率β的t检验</h3>
<p>在简单线性回归的模型，我们可以检验回归系数(斜率)β是否相等于特定的$β_0$(通常使$β_0 = 0$以检验$x_i$对$y_i$是否有关联)。
统计量t</p>

<p><img src="http://xukuang.github.io/blog/images/student_t.png" alt="" />
在零假设为$β = β_0$的情况下服从自由度为n − 2之t分布，其中</p>

<p><img src="http://xukuang.github.io/blog/images/student_se.png" alt="" />
同F检验一样，p值越小，说明此时越小的概率事件发生了，越不能接受原假设。</p>

<h2 id="section-10">话外篇</h2>
<p>在R中，lm(y ~ x)和lm(y ~ x + 1)的效果是相同的。此外，lm(y ~ 1)中截距的估计值为y的平均值，残差为每个y与均值的离差。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>离散型随机变量的常用统计指标</title>
      <link>http://xukuang.github.io/blog/2016/04/moment-in_statistics/</link>
      <pubDate>2016-04-07T06:25:50+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/moment-in_statistics</guid>
      <content:encoded><![CDATA[<h2 id="section">期望</h2>

<script type="math/tex; mode=display">E[X] = \sum_{i=1}^n x_i</script>

<p>期望存在一下特性:</p>

<p>1.<script type="math/tex">E[aX + bY] = aE[X] + bE(Y)</script></p>

<p>2.一般情况下，<script type="math/tex">E[X Y] \neq E[X]E(Y)</script>；当X和Y相互独立时，才有<script type="math/tex">E[X Y] = E[X]E(Y)</script></p>

<h2 id="section-1">方差</h2>
<p>方差描述的是随机变量的离散程度，也就是该变量离其期望值的距离。</p>

<script type="math/tex; mode=display">Var(X) = E[(X -E[X])^2] = E[X^{2} - 2X E[X] + (E[X])^{2}] = E[X^{2}] - (E[X])^{2}</script>

<p>此外，方差还可以看作是随机变量和自身的协方差<script type="math/tex">Var(X) = Cov(X, X)</script>。</p>

<h2 id="section-2">标准差</h2>
<p>标准差是一组数值自平均值分散开来的程度的一种测量观念。</p>

<p>总体的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N}}</script>

<p>样本的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N - 1}}</script>

<h2 id="section-3">标准误</h2>
<p>标准误差针对样本统计量而言，是某个样本统计量的标准差。当谈及标准误差时，一般须指明对应的样本统计量才有意义。以下以样本均值（样本均值是一种样本统计量）作为例子。于是，假设可以从总体中随机选取无限的大小相同的样本，那每个样本都可以有一个样本均值。依此法可以到一个由无限多样本均值组成的总体，该总体的标准差即为标准误差。</p>

<script type="math/tex; mode=display">SE = \frac{SD}{\sqrt{N}}</script>

<h2 id="section-4">协方差</h2>
<p>协方差用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</p>

<script type="math/tex; mode=display">Cov(X, Y) = E((X - E[X])(Y - E(Y)) = E[XY] - E[X] E[Y]</script>

<p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。如果X与Y是统计独立的，那么二者之间的协方差就是0，但是反过来并不成立，即如果X与Y的协方差为0，二者并不一定是统计独立的。</p>

<h2 id="section-5">协方差的相关性η(线性相关)</h2>

<script type="math/tex; mode=display">\eta =  \frac{cov(X, Y)}{\sqrt{var(X) \cdot var(Y)}}</script>

<p>协方差的相关性η更准确地说是线性相关的相关系数r，是一个衡量线性独立的无量纲数，其取值在[－1,+1]之间。相关性η = 1时称为“完全线性相关”(相关性η = -1时称为“完全线性负相关”)，此时将<script type="math/tex">Y_{i}</script>对<script type="math/tex">X_{i}</script>作Y-X散点图，将得到一组精确排列在直线上的点；相关性数值介于－1到1之间时，其绝对值越接近1表明线性相关性越好，作散点图得到的点的排布越接近一条直线。相关性为0(因而协方差也为0)的两个随机变量又被称为是不相关的，或者更准确地说叫作“线性无关”、“线性不相关”，这仅仅表明X 与Y两随机变量之间没有线性相关性，并非表示它们之间一定没有任何内在的（非线性）函数关系，和前面所说的“X、Y二者并不一定是统计独立的”说法一致。</p>

<p>-—–</p>

<p><strong>本篇文章整理自维基百科。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>用R进行文件系统管理</title>
      <link>http://xukuang.github.io/blog/2016/03/document-mangement/</link>
      <pubDate>2016-03-02T01:24:47+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/03/document-mangement</guid>
      <content:encoded><![CDATA[<p>学习中，已经体会到了R在数据处理方面的厉害，偶然看到张丹的博文<a href="http://blog.fens.me/r-file-folder/">《用R进行文件系统管理》</a>，发现R居然还可以进行文件系统的管理，又一次全新的认识了世界（其实主要是R）。这里基本上是把张丹的文章照搬过来了，只是加了少许自己学习时心得。本文中提到的文件系统管理主要是指文件和目录（即文件夹）的创建、查看、重命名、复制、删除和文件权限处理。</p>

<h2 id="section">文件操作</h2>

<ul>
  <li>创建文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 创建一个空文件 A.txt
file.create("A.txt")
# 查看当前目录下的子目录和文件
list.files()

# 创建多个空文件 A1.txt，A2.txt，A3.txt
file.create("A1.txt", "A2.txt", "A3.txt")
# 查看当前目录下的子目录和文件
list.files()

# 创建一个有内容的文件 B.txt
cat("文件测试\n", file = "B.txt")
list.files()
</code></pre>
</div>

<ul>
  <li>查看文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 显示当前目录中的目录和文件

## 下面两句结果相同
list.files() # 建议使用该命令，方便记忆
dir()


## 参数full.names = TRUE，确定文件显示全名

## 参数recursive = TRUE，递归显示，即把目录下的目录和文件都以文件的形式显示
list.files(, full.names = TRUE, recursive = TRUE)

# 检查文件是否存在

## 存在的文件
file.exists("A.txt")

## 不存在的文件
file.exists("readme.txt")

# 判断是否是文件
file_test("-f", "A.txt")
</code></pre>
</div>
<!--more-->

<ul>
  <li>读取文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 文件A.txt读取
readLines("A.txt")

# 文件B.txt读取
readLines("B.txt")
</code></pre>
</div>

<ul>
  <li>文件重命名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 给文件A.txt重命名为AA.txt
file.rename("A.txt","AA.txt")
list.files()
</code></pre>
</div>

<ul>
  <li>复制文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.copy("B.txt", "C.txt")
# 查看文件内容
readLines("C.txt")
</code></pre>
</div>

<ul>
  <li>追加文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.append("A.txt", rep("B.txt", 10))
# 查看文件内容
readLines("A.txt") 
</code></pre>
</div>

<ul>
  <li>删除文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 新建文件
file.create("tempa1", "tempa2", "tempa3", "tempa4")
list.files()
# 删除文件
file.remove("tempa1", "tempa2", "tempa3", "tempa4")
list.files()
</code></pre>
</div>

<ul>
  <li>文件权限</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看文件完整信息
file.info("A.txt")

# 查看文件访问权限
# 0表示有相关权限
# 1表示没有相关权限

## 是否存在
file.access("A.txt",0)

## 是否可执行
file.access("A.txt",1)

## 是否可写
file.access("A.txt",2)

## 是否可读
file.access("A.txt",4)

# 文件权限修改

## 查看文件信息
file.info("A.txt")

## 修改文件权限，创建者可读可写可执行，其他人无权限
Sys.chmod("A.txt", mode = "0400", use_umask = TRUE)

## 查看文件信息
file.info("A.txt")
</code></pre>
</div>

<h2 id="section-1">目录操作</h2>

<ul>
  <li>创建目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 新建一个目录
dir.create("test") # 不能同时创建多个目录
list.dirs()

# 递归创建
dir.create("test/test",recursive = TRUE)
list.dirs()
</code></pre>
</div>

<ul>
  <li>查看目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看当前默认目录的一级目录和文件
list.files() # 同时会显示目录下的文件
dir()

# 查看当前默认目录的子目录

## 默认递归显示各级子目录
list.dirs()

## 只显示一级子目录
list.dirs(recursive= FALSE)

# 通过系统命令查看目录结构
system("tree")

# 检查目录是否存在
# 存在的目录
file.exists(".")
file.exists("./test")

# 不存在的目录
file.exists("./test1")

# 判断是否是目录

## 下面两个语句结果相同
file_test("-d", "./test")
file_test("-d", "test")
</code></pre>
</div>

<ul>
  <li>目录重命名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看目录
dir()

# 对test目录重命名
file.rename("test", "test1")

# 查看目录
dir()

# 目录重命名
file.rename("test1", "test")
</code></pre>
</div>

<ul>
  <li>删除目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dir.create('temp')
dir.create('temp1/temp1', recursive = TRUE)
dir()

# 删除temp目录
unlink("temp", recursive = TRUE) # unlink也可用来删除文件，此时不需要设置参数recursive
dir()

unlink("temp1", recursive = TRUE) # 
dir()
</code></pre>
</div>

<ul>
  <li>目录的权限</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看目录完整信息
file.info(".")

# 检查目录的权限
df&lt;-dir(full.names = TRUE)

# 检查文件或目录是否存在，mode=0
file.access(df, 0) == 0

# 检查文件或目录是否可执行，mode=1，目录为可以执行
file.access(df, 1) == 0

# 检查文件或目录是否可写，mode=2
file.access(df, 2) == 0

# 检查文件或目录是否可读，mode=4
file.access(df, 4) == 0

# 修改目录权限，所有用户只读
Sys.chmod("./test", mode = "0555", use_umask = TRUE)
file.info("./test")
</code></pre>
</div>

<h2 id="section-2">其他功能函数</h2>

<ul>
  <li>拼接目录字符串</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.path("p1","p2","p3")
</code></pre>
</div>

<ul>
  <li>所在目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dirname("/home/conan/R/fs/readme.txt")
</code></pre>
</div>

<ul>
  <li>最底层子目录或文件名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>basename("/home/conan/R/fs/readme.txt")
basename("/home/conan/R/fs")
</code></pre>
</div>

<ul>
  <li>win下标准路径转化</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>normalizePath(c(R.home(), tempdir()))
</code></pre>
</div>

<ul>
  <li>短路径，缩减路径的显示长度，只在win中运行</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>shortPathName(c(R.home(), tempdir()))
</code></pre>
</div>

<h2 id="section-3">几个特殊的目录</h2>

<p><strong>R.home()</strong> 查看R软件的相关目录</p>

<p><strong>.Library</strong> 查看R核心包的目录</p>

<p>**.libPaths() ** 查看R所有包的存放目录</p>

<p><strong>ystem.file()</strong> 查看指定包所在的目录</p>

<ul>
  <li>R软件的相关目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># R.home() 查看R软件的相关目录

## 打印R软件安装目录
R.home()

## 打印R软件bin的目录
R.home(component="bin")

## 打印R软件文件的目录
R.home(component="doc")
</code></pre>
</div>

<ul>
  <li>R软件的包目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 打印核心包的目录
.Library
# 打印所有包的存放目录
.libPaths()
</code></pre>
</div>

<ul>
  <li>查看指定包所在的目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># base包的存放目录
system.file()
# dplyr包的存放目录
system.file(package = "dplyr")
</code></pre>
</div>

<h2 id="section-4">小结</h2>
<p>正如张丹所说，用R语言操作文件系统还是很方便的，但其对于函数命名不太规范,比如文件和目录的操作函数名有时区分，有时又不区分。最后，对文件和目录的操作进行简单的小结以方便自己的记忆。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">操作名称</th>
      <th style="text-align: center">文件操作</th>
      <th style="text-align: right">目录操作</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">创建</td>
      <td style="text-align: center">file.create()</td>
      <td style="text-align: right">dir.create()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">查看</td>
      <td style="text-align: center">list.files()</td>
      <td style="text-align: right">list.dirs()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">读取</td>
      <td style="text-align: center">readLines()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">重命名</td>
      <td style="text-align: center">file.rename()</td>
      <td style="text-align: right">file.rename()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">复制</td>
      <td style="text-align: center">file.copy()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">追加</td>
      <td style="text-align: center">file.append()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">删除</td>
      <td style="text-align: center">file.remove()</td>
      <td style="text-align: right">unlink()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限查看</td>
      <td style="text-align: center">file.info()</td>
      <td style="text-align: right">file.info()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限查看</td>
      <td style="text-align: center">file.access()</td>
      <td style="text-align: right">file.access()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限修改</td>
      <td style="text-align: center">Sys.chomod()</td>
      <td style="text-align: right">Sys.chomod()</td>
      <td> </td>
    </tr>
  </tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>R中的文本处理</title>
      <link>http://xukuang.github.io/blog/2016/02/char-in-R/</link>
      <pubDate>2016-02-28T01:14:59+08:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/02/char-in-R</guid>
      <content:encoded><![CDATA[<!--
* 目录{:toc}
-->
<blockquote>
  <p>处理文本是每一种计算机语言都应该具备的功能，但不是每一种语言都侧重于处理文本。R语言是统计的语言，处理文本不是它的强项。尽管R语言处理文本的能力不够强，但适当使用可以大幅提高工作效率的，而且有些文本操作还不得不用。高效处理文本少不了正则表达式（regular expression），虽然R在这方面先天不高效，但其中处理文本的绝大多数函数都支持正则表达式。</p>
</blockquote>

<h2 class="no_toc" id="section">正则表达式</h2>

<p>正则表达式是用于描述和匹配一个文本集合的表达式。它不是R的专属内容，这里也只简单介绍，更详细的内容请查阅其他文章。<!--more--></p>

<ol>
  <li>所有英文字母、数字和很多可显示的字符本身就是正则表达式，用于匹配它们自己。比如 ‘a’ 就是匹配字母 ‘a’ 的正则表达式</li>
  <li>一些特殊的字符在正则表达式中被“转义”不在用来描述它自身，这些字符称为“元字符”。常见元字符的意义如下:
    <ul>
      <li>\^放在表达式开始处表示匹配文本开始位置，放在方括号内开始处表示非方括号内的任一字符</li>
      <li>$ 匹配一个字符串的结尾</li>
      <li>点号. 表示除了换行符以外的任一字符</li>
      <li>* 表示将其前的字符进行0个或多个的匹配</li>
      <li>.* 可以匹配任意字符</li>
      <li>+ 匹配1或多个正好在它之前的那个字符</li>
      <li>? 匹配0或1个正好在它之前的那个字符</li>
      <li>大括号{}表示前面的字符或表达式的重复次数</li>
      <li>方括号[]表示选择方括号中的任意一个（如[a-z] 表示任意一个小写字符）</li>
      <li>| 表示可选项，即| 前后的表达式任选一个</li>
    </ul>
  </li>
  <li>
    <p>如果要在正则表达式中表示元字符本身，比如我就要在文本中查找问号‘?’，那么就要使用引用符号（或称换码符号），一般是反斜杠 ‘'。需要注意的是，在R语言中得用两个反斜杠即 ‘\\’，如要匹配括号就要写成 ’\\(\\)‘</p>
  </li>
  <li>不同语言或应用程序（事实上很多规则都通用）定义了一些特殊的元字符用于表示某类字符，如 :
    <ul>
      <li>\d 表示数字0-9，\D 表示非数字</li>
      <li>\s 表示空白字符（包括空格、制表符、换行符等），\S 表示非空白字符，</li>
      <li>\w 表示字（字母和数字），\W 表示非字</li>
      <li>\&lt; 和 \&gt; 分别表示以空白字符开始和结束的文本
 需要注意的是，反斜杠 ‘\‘在R语言中得用两个反斜杠即 ‘\\’，如’\s’就要写成 ’\\s‘。</li>
    </ul>
  </li>
  <li>正则表达式符号运算顺序：圆括号括起来的表达式最优先，然后是表示重复次数的操作(即：* + {} )，接下来是连接运算（其实就是几个字符放在一起，如abc），最后是表示可选项的运算(|)。所以’foot|bar’ 可以匹配’foot‘或者’bar‘，但是 ‘foot|ba{2}r’匹配的是’foot‘或者’baar‘。</li>
  <li>“贪婪”和“懒惰”的匹配规则。默认情况下是匹配尽可能多的字符，是为贪婪匹配，比如 “a.*b”默认匹配最长的a开头b结尾的字串，也就是整个字符串。如果要进行懒惰匹配，也就是匹配最短的字串，只需要在后面加个 ?，比如 “a.*?b”，就会匹配最开始找到的最短的a开头b结尾的字串</li>
</ol>

<h2 id="section-1">文本处理</h2>

<h3 id="section-2">字符数统计</h3>
<p>函数nchar，统计向量中每个元素的字符个数，注意这个函数和length函数的差别：length是向量长度（向量元素的个数）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x &lt;- c("Hellow", "World", "!") 
nchar(x); length(x)
	# [1] 6 5 1 
	# [1] 3
length(''); nchar('') 
	# [1] 1 
	# [1] 0 
</code></pre>
</div>

<h3 id="section-3">字符大小写转化</h3>

<ul>
  <li>函数tolower，将向量中的元素转化为小写字母</li>
  <li>函数toupper，将向量中的元素转化为大写字母</li>
  <li>函数casefold，将向量中的元素转化为小或大写字母（upper = F，转化为小写；upper = T，转化为大写）</li>
  <li>函数chartr，按指定的规则进行转换</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>tolower(x)
	# [1] "hellow" "world"  "!"  
toupper(x)
	# [1] "HELLOW" "WORLD"  "!" 
casefold(x) # 默认upper = F
	# [1] "hellow" "world"  "!" 
casefold(x, upper = T)
	# [1] "HELLOW" "WORLD"  "!"  

chartr('ol', 'pm', x) # o转化为p，l转化为m
	# "Hemmpw" "Wprmd"  "!"
	
DNA &lt;- "AtGCtttACC" # DNA为长度为1的字符向量
tolower(DNA) 
	# [1] "atgctttacc" 
toupper(DNA) 
	# [1] "ATGCTTTACC" 
chartr("Tt", "Uu", DNA) # T转化为U，t转化为u
	# [1] "AuGCuuuACC" 
chartr("Tt", "UU", DNA) 
	# [1] "AUGCUUUACC"
</code></pre>
</div>

<h3 id="section-4">字符串连接</h3>
<p>函数paste应该是R中最常用字符串函数了，也是R字符串处理函数里面非常纯的不使用正则表达式的函数（因为用不着）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>paste("CK", 1:6, sep = "")
	# [1] "CK1" "CK2" "CK3" "CK4" "CK5" "CK6"
x &lt;- list(a = "aaa", b = "bbb", c = "ccc")
y &lt;- list(d = 1, e = 2)
paste(x, y, sep = "-")  #较短的向量被循环使用
	# [1] "aaa-1" "bbb-2" "ccc-1"
</code></pre>
</div>
<p>paste函数还有一个用法，设置collapse参数，连成一个字符串。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>paste(x, y, sep = "-", collapse = "; ")
	# [1] "aaa-1; bbb-2; ccc-1"
paste(x, collapse = "; ")
	# [1] "aaa; bbb; ccc"
</code></pre>
</div>

<h3 id="section-5">字符串拆分</h3>

<p>strsplit函数使用正则表达式，使用格式为:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)
</code></pre>
</div>

<ul>
  <li>参数x为字串向量，每个元素都将单独进行拆分。</li>
  <li>参数split为拆分位置的字串向量，</li>
  <li>默认为正则表达式匹配（fixed=FALSE）。如果你没接触过正则表达式，设置fixed=TRUE，表示使用普通文本匹配或正则表达式的精确匹配。普通文本的运算速度快。</li>
  <li>参数perl=TRUE/FALSE的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度。</li>
  <li>参数useBytes设置是否逐个字节进行匹配，默认为FALSE，即按字符而不是字节进行匹配。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>text &lt;- "Hello Adam!\nHello Ava!"
strsplit(text, " ") # R语言的字符串事实上也是正则表达式，文本中的\n在图形输出中是被解释为换行符的。
	# [[1]]
	# [1] "Hello"        "Adam!\nHello" "Ava!"
strsplit(text, "\\s")
	# [[1]]
	# [1] "Hello" "Adam!" "Hello" "Ava!"
</code></pre>
</div>

<p>strsplit得到的结果是列表，后面要怎么处理就得看情况而定了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class(strsplit(text, "\\s"))
	# [1] "list"
</code></pre>
</div>
<p>有一种情况很特殊，如果split参数的字符长度为0，得到的结果就是一个个的字符。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strsplit(text, "")
	# [[1]]
	#  [1] "H"  "e"  "l"  "l"  "o"  " "  "A"  "d"  "a"  "m"  "!"  "\n" "H"  "e" 
	# [15] "l"  "l"  "o"  " "  "A"  "v"  "a"  "!"
</code></pre>
</div>
<p>从这里也可以看到R把 \n 是当成一个字符来处理的。</p>

<h3 id="section-6">字符串查询和替换</h3>
<p>R中字符串的查询函数有：grep、grepl、regexpr、gregexpr和regexpr，字符串的替换函数有sub和gsub。</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 字符串查询
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)

grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
      fixed = FALSE, useBytes = FALSE)

regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)

gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
         fixed = FALSE, useBytes = FALSE)

regexec(pattern, text, ignore.case = FALSE,
        fixed = FALSE, useBytes = FALSE)
# 字符串替换
sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
    fixed = FALSE, useBytes = FALSE)
## sub函数会根据pattern的规则对x中各元素进行搜索，遇到符合条件的第一个子字符串的位置，用replacement替换该子字符串，返回替换后的结果，和x的结构相同
gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
     fixed = FALSE, useBytes = FALSE)
## gsub函数会根据pattern的规则对x中各元素进行搜索，找出所有符合条件的子字符串的位置，用replacement替换该子字符串，返回替换后的结果，和x的结构相同	 
</code></pre>
</div>

<p>这几个函数有相似的格式，都使用正则表达式的规则进行匹配。默认是egrep的规则，也可以选用Perl语言的规则。</p>

<ul>
  <li>pattern为字符串表示正则表达式</li>
  <li>replacement也是字符串表示替换的内容</li>
  <li>x为字符型向量表示被替换的字符向量</li>
  <li>参数ignore.case = FALSE，表示大小写敏感</li>
  <li>参数extended = TRUE，表示使用egrep规则</li>
  <li>perl = FALSE，表示不使用Perl规则</li>
  <li>fixed = FALSE，表示不使用精确匹配</li>
  <li>useBytes = FALSE，表示按字符匹配</li>
</ul>

<h4 id="section-7">字符串查询</h4>
<p>grep和grepl函数这两个函数返回向量水平的匹配结果，不涉及匹配字符串的详细位置信息。此外，尽管这两个函数的参数看起来差不多，但是返回结果的形式并不一样。	
regexpr、gregexpr和regexpr这三个函数返回的结果包均含了匹配的具体位置和字符串长度信息，只是他们的结果显示方式不同。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text &lt;- c("Hellow, Adam!", "Hi, Paul!", "How are you, Adam.")
grep("Adam", text)
	# [1] 1 3
grepl("Adam", text)
	# [1]  TRUE FALSE  TRUE
regexpr("Adam", text)
	# [1]  9  -1 14
	# attr(,"match.length")
	# [1] 4 -1 4
	# attr(,"useBytes")
	# [1] TRUE
gregexpr("Adam", text)
	# [[1]]
	# [1] 9
	# attr(,"match.length")
	# [1] 4
	# attr(,"useBytes")
	# [1] TRUE
	# 
	# [[2]]
	# [1] -1
	# attr(,"match.length")
	# [1] -1
	# attr(,"useBytes")
	# [1] TRUE
	# 
	# [[3]]
	# [1] 14
	# attr(,"match.length")
	# [1] 4
	# attr(,"useBytes")
	# [1] TRUE
regexec("Adam", text)
	# [[1]]
	# [1] 9
	# attr(,"match.length")
	# [1] 4
	# 
	# [[2]]
	# [1] -1
	# attr(,"match.length")
	# [1] -1
	# 
	# [[3]]
	# [1] 14
	# attr(,"match.length")
	# [1] 4
</code></pre>
</div>

<h4 id="section-8">字符串替换</h4>
<p>尽管sub和gsub是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为R语言不管什么操作对参数都是传值不传址。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text
	# [1] "Hellow, Adam!"      "Hi, Paul!"          "How are you, Adam."
sub(pattern = "Adam", replacement = "world", text)
	# [1] "Hellow, world!"      "Hi, Paul!"          "How are you, world."
text
	# [1] "Hellow, Adam!"      "Hi, Paul!"          "How are you, Adam."
</code></pre>
</div>
<p>可以看到：虽然说是“替换”，但原字符串并没有改变，要改变原变量我们只能通过再赋值的方式。 sub和gsub的区别是前者只做一次替换（不管有几次匹配），而gsub把满足条件的匹配都做替换。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text1 = c("Hellow, Adam!", "Hi, Paul!", "How are you, Adam, Ava.")
sub(pattern = "Adam|Ava", replacement = "world", text1)
	# [1] "Hellow, world!"      "Hi, Paul!"          "How are you, world, Ava."
gsub(pattern = "Adam|Ava", replacement = "world", text1)
	# [1] "Hellow, world!"      "Hi, Paul"          "How are you, world, world."
</code></pre>
</div>

<p>sub和gsub函数可以使用提取表达式（转义字符+数字）让部分变成全部：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sub(pattern = ".*(Adam).*", replacement = "Hi, \\1", text)
	# [1] "Hi, Adam"  "Hi, Paul!" "Hi, Adam" 
</code></pre>
</div>

<h2 id="section-9">字符串提取</h2>
<p>substr和substring函数通过位置进行字符串拆分或提取，它们本身并不使用正则表达式，但是结合正则表达式函数regexpr、gregexpr或regexec使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同，但它们的返回值的长度（个数）有差别：substr返回的字串个数等于第一个参数的长度，而substring返回字串个数等于三个参数中最长向量长度，短向量循环使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>substr(x, start, stop)
substring(text, first, last = 1000000L)
</code></pre>
</div>

<ul>
  <li>x均为要拆分的字串向量</li>
  <li>start/first 为截取的起始位置向量</li>
  <li>stop/last 为截取字串的终止位置向量</li>
</ul>

<p>先看第1参数（要拆分的字符向量）长度为1例子。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x &lt;- "123456789"
substr(x, c(2, 4), c(4, 5, 8))
	# [1] "234"
substring(x, c(2, 4), c(4, 5, 8))
	# [1] "234"     "45"      "2345678"
</code></pre>
</div>
<p>因为x的向量长度为1，所以substr获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。 而substring的语句三个参数中最长的向量为c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。</p>

<h3 id="section-10">字符串的整理</h3>

<ul>
  <li>strtrim 函数</li>
</ul>

<p>该函数用于将字符串修剪到特定的显示宽度，其用法为，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strtrim(x,width)
</code></pre>
</div>
<p>返回字符串向量的长度等于x的长度。因为是“修剪”，所以只能去掉多余的字符不能增加其他额外的字符：如果字符串本身的长度小于width，得到的是原字符串，别指望它会用空格或其他什么字符补齐。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strtrim(c("abcdef", "abcdef", "abcdef"), c(1, 5, 10))
	# [1] "a"      "abcde"  "abcdef"
strtrim(c(1, 123, 1234567), 4)
	# [1] "1"    "123"  "1234"
</code></pre>
</div>

<ul>
  <li>strwrap函数</li>
</ul>

<p>该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>str1 &lt;- "Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."
str2 &lt;- rep(str1, 2)
strwrap(str2, width = 80, indent = 2)
	#  [1] "  Each character string in the input is first split into paragraphs (or lines"
	#  [2] "containing whitespace only).  The paragraphs are then formatted by breaking"  
	#  [3] "lines at word boundaries.  The target columns for wrapping lines and the"     
	#  [4] "indentation of the first and all subsequent lines of a paragraph can be"      
	#  [5] "controlled independently."                                                    
	#  [6] "  Each character string in the input is first split into paragraphs (or lines"
	#  [7] "containing whitespace only).  The paragraphs are then formatted by breaking"  
	#  [8] "lines at word boundaries.  The target columns for wrapping lines and the"     
	#  [9] "indentation of the first and all subsequent lines of a paragraph can be"      
	# [10] "controlled independently."
</code></pre>
</div>

<p>simplify参数用于指定结果的返回样式，默认为TRUE，即结果中所有的字符串都按顺序放在一个字符串向量中（如上）；如果为FALSE，那么结果将是列表。另外一个参数exdent用于指定除第一行以外的行缩进。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strwrap(str1, width = 80, indent = 0, exdent = 2)
	# [1] "Each character string in the input is first split into paragraphs (or lines"  
	# [2] "  containing whitespace only).  The paragraphs are then formatted by breaking"
	# [3] "  lines at word boundaries.  The target columns for wrapping lines and the"   
	# [4] "  indentation of the first and all subsequent lines of a paragraph can be"    
	# [5] "  controlled independently."
</code></pre>
</div>

<ul>
  <li>match和charmatch函数</li>
</ul>

<p>这两个函数用于字符的匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>match("xx", c("abc", "xx", "xxx", "xx"))
	# [1] 2
match(2, c(3, 1, 2, 4))
	# [1] 3
charmatch("xx", "xx")
	# [1] 1
charmatch("xx", "xxa")
	# [1] 1
charmatch("xx", "axx")
	# [1] NA
</code></pre>
</div>
<p>match按向量进行运算，返回第一次匹配的元素的位置（如果有），非字符向量也可用。正如原作者说的那样，charmatch函数真太坑爹了，不建议使用。</p>

<p>-—–</p>

<p><strong>参考文章</strong></p>

<ol>
  <li>R语言进阶之二：文本（字符串）处理与正则表达式（这篇文章在许多网站都有转载，然而原创链接失效了）</li>
  <li><a href="http://jianl.org/2010/02/14/2010-02-14-R%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B/">R中正则表达式简介</a></li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
