<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Xu Kuang</title>
    <atom:link href="http://xukuang.github.io/blog/feed/" rel="self" type="application/rss+xml" />
    <link>http://xukuang.github.io</link>
    <lastBuildDate>2016-05-03T11:15:23-06:00</lastBuildDate>
    <webMaster>kuang_xu@126.com</webMaster>
    
    <item>
      <title>k12</title>
      <link>http://xukuang.github.io/blog/2016/05/k12/</link>
      <pubDate>2016-05-03T11:04:16-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/05/k12</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>new-post</title>
      <link>http://xukuang.github.io/blog/2016/05/new-post/</link>
      <pubDate>2016-05-03T00:00:00-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/05/new-post</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>k1</title>
      <link>http://xukuang.github.io/blog/2016/05/k1/</link>
      <pubDate>2016-05-03T00:00:00-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/05/k1</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>k</title>
      <link>http://xukuang.github.io/blog/2016/05/k/</link>
      <pubDate>2016-05-03T00:00:00-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/05/k</guid>
      <content:encoded><![CDATA[
]]></content:encoded>
    </item>
    
    <item>
      <title>Numpy包的学习</title>
      <link>http://xukuang.github.io/blog/2016/04/numpy/</link>
      <pubDate>2016-04-27T07:04:53-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/numpy</guid>
      <content:encoded><![CDATA[<p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。</p>

<ul>
  <li>ndarray，快速和节省空间的多维数组，提供数组化的算术运算和高级的广播功能『广播功能是个什么东东啊』</li>
  <li>使用标准数学函数对整个数组的数据进行快速运算，而不需要编写循环</li>
  <li>读取/写入磁盘上的阵列数据和操作存储器映像文件的工具</li>
  <li>线性代数，随机数生成，和傅里叶变换的能力</li>
  <li>集成C，C++，Fortran代码的工具</li>
</ul>

<p>从生态系统的角度看，最后一点是最为重要的。因为Numpy提供了易用的CApI，它可以很容易的将数据传递到使用低级语言编写的外部库，也可以使外部库返回Numpy数组数据到python。这一特性使得python成为包装传统的C/C++/Fortran代码库，并给它们一个动态的、易于使用的接口的首选语言。『完全不懂啊』</p>

<p>虽然Numpy本身并没有提供非常高级的数据分析功能，但是了解Numpy的数组和面向数组的计算将会帮助你高效的使用类似于pandas这样的工具。
对于大多数的数据分析应用来说，我关注的主要功能是:</p>

<ul>
  <li>快速的矢量化数组操作：数据切割和清除，子集和过滤，转化和任何其它类型的计算</li>
  <li>通用的数组算法，例如：sorting，unique和set操作</li>
  <li>有效的描述性统计和聚集/汇总数据</li>
  <li>数据对齐、关系数据的合并操作、异构数据的拼接操作</li>
  <li>使用数组表达式来表示条件逻辑，而不是用带有 if-elif-else 分支的循环来表示</li>
  <li>组间数据的操作（聚合，转换，功能应用）。</li>
</ul>

<p>虽然Numpy提供了这些操作的计算功能，但你或许希望使用pandas作为大多数数据分析的基础（特别是结构化或表格数据），因为pandas提供了一个丰富的，高级的接口使得常见的数据任务非常简洁和简单。此外，pandas还提供了更多的一些特定领域的功能，如时间数组操作，这是Numpy所没有的。</p>

<h3 id="numpy-ndarray">Numpy ndarray：多维数组对象</h3>
<p>Numpy的一个关键特性是它的N维数组对象(ndarray)，它在python中是一个大型数据集的快速的，灵活的容器。 数组使你能够在整个数据块上进行数学运算，且与对应的纯量元素间操作有相似的语法。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>array1 = np.array([[ 0.9526, -0.246 , -0.8856], [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
</code></pre>
</div>

<p>ndarray是一个同种类数据的多维容器，也就是说，它的所有元素都是同类型的。每一个数组都有一个 shape （表示它每一维大小的元组）和 dtype （一个描述数组数据类型的对象）的属性。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
</code></pre>
</div>

<h4 id="ndarray">创建ndarray对象</h4>
<p>最简单的创建数组的方式是使用array函数。它接受任何数组对象（包括其它数组），产生一个包含所传递的数据的新Numpy数组。例如，列表就是一个很好的用于转换的候选。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
</code></pre>
</div>

<p>嵌套序列，如等长列表的列表，将会转化为一个多维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
</code></pre>
</div>
<p>除 np.array 之外，还有许多函数来创建新的数组。例如， zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。empty 会创建一个没有使用特定值来初始化的数组。给这些方法传递一个元组作为形状来创建高维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
</code></pre>
</div>
<p>arange 是python内建 range 函数的数组版本。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
</code></pre>
</div>

<h4 id="section">数组和纯量间的操作</h4>
<p>数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
	## array([[ 1.,  2.,  3.],
	##        [ 4.,  5.,  6.]])
arr * arr                 
	## array([[  1.,   4.,   9.],       
	##        [ 16.,  25.,  36.]])
</code></pre>
</div>

<p>纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 / arr                       
	## array([[ 1. , 0.5 , 0.3333],            
	##        [ 0.25 , 0.2 , 0.1667]])
</code></pre>
</div>

<h4 id="section-1">基本的索引和切片</h4>
<p>Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(10)
arr
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[5]
	## 5
arr[5:8]
	## array([5, 6, 7])
arr[5:8] = 12
arr
	## array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code></pre>
</div>
<p>如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr_slice = arr[5:8]
arr_slice[1] = 12345
arr_slice
	## array([   12, 12345,    12])
arr
	## array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
arr_slice[:] = 64
arr_slice
	## array([64, 64, 64])
arr
	## array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
</code></pre>
</div>
<p>如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。</p>

<p>对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
	## array([7, 8, 9])
</code></pre>
</div>
<p>因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[0][2]
	## 3
arr2d[0, 2]
	## 3
</code></pre>
</div>
<p>在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>arr3d[0] 是一个 2*3 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[0]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>纯量值和数组都可以给 arr3d[0] 赋值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
	## array([[[42, 42, 42],
	##         [42, 42, 42]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
arr3d[0] = old_values
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[1, 0]
	## array([7, 8, 9])
</code></pre>
</div>
<p>请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。
如同一维对象，ndarrys可以使用熟悉的语法来切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[1:6]
	## array([ 1, 2, 3, 4, 64])
</code></pre>
</div>
<p>较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d
	## array([[1, 2, 3],          
	##        [4, 5, 6],                 
	##        [7, 8, 9]])
arr2d[:2]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:]
	## array([[2, 3],
	##        [5, 6]])
</code></pre>
</div>
<p>像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[1, :2] 
	## array([4, 5])
</code></pre>
</div>
<p>注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:, :1]
	## array([[1],
	##        [4],
	##        [7]])
</code></pre>
</div>
<p>当然，给一个切片表达式赋值会对整个选择赋值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:] = 0
</code></pre>
</div>

<h2 id="section-2">布尔索引</h2>
<p>让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import numpy.random as np_rd
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np_rd.randn(7, 4)
names
	## array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	##       dtype='|S4')
data
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names == 'Bob'
	## array([ True, False, False, True, False, False, False], dtype=bool)
</code></pre>
</div>
<p>当索引数组时可以传递这一布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob']
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672]])
</code></pre>
</div>
<p>布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob', 2:]
	## array([[-0.2349, 1.2792],
	##        [-0.0523, 0.0672]])
</code></pre>
</div>
<p>为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names != 'Bob'
	## array([False, True, True, False, True, True, True], dtype=bool)
data[-(names == 'Bob')]
	## array([[-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>使用布尔算术操作符如 &amp; （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mask = (names == 'Bob') | (names == 'Will')
mask
array([True, False, True, True, True, False, False], dtype=bool)
data[mask]
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289]])
</code></pre>
</div>
<p>通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。
为了设置 data 中所有的负值为0，我们只需要。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[data &lt; 0] = 0
data
	## array([[ 0. , 0.5433, 0. , 1.2792],
	##        [ 0. , 0.5465, 0.0939, 0. ],
	##        [ 0. , 0. , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, 0. , 0.0672],
	##        [ 0. , 0. , 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>
<p>使用一维布尔数组设置整行或列也非常简单：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names != 'Joe'] = 7
data
array([[ 7. , 7. , 7. , 7. ],
       [ 0. , 0.5465, 0.0939, 0. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 0.1913, 0.4544, 0.4519, 0.5535],
       [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>

<h4 id="fancy">Fancy索引</h4>
<p>Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8*4 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
	## array([[ 0., 0., 0., 0.],
	##        [ 1., 1., 1., 1.],
	##        [ 2., 2., 2., 2.],
	##        [ 3., 3., 3., 3.],
	##        [ 4., 4., 4., 4.],
	##        [ 5., 5., 5., 5.],
	##        [ 6., 6., 6., 6.],
	##        [ 7., 7., 7., 7.]])
</code></pre>
</div>
<p>为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[4, 3, 0, 6]]
	## array([[ 4., 4., 4., 4.],
	##        [ 3., 3., 3., 3.],
	##        [ 0., 0., 0., 0.],
	##        [ 6., 6., 6., 6.]])
</code></pre>
</div>
<p>很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[-3, -5, -7]]
	## array([[ 5., 5., 5., 5.],
	##        [ 3., 3., 3., 3.],
	##        [ 1., 1., 1., 1.]])
</code></pre>
</div>
<p>传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(32).reshape((8, 4))
arr
	## array([[ 0, 1, 2, 3],
	##        [ 4, 5, 6, 7],
	##        [ 8, 9, 10, 11],
	##        [12, 13, 14, 15],
	##        [16, 17, 18, 19],
	##        [20, 21, 22, 23],
	##        [24, 25, 26, 27],
	##        [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
	## array([ 4, 23, 29, 10])
</code></pre>
</div>
<p>花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。
### 转置数组和交换坐标轴
转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(15).reshape((3, 5))
arr                  
	## array([[ 0, 1, 2, 3, 4],               
	##        [ 5, 6, 7, 8, 9],               
	##        [10, 11, 12, 13, 14]])          
arr.T
	## array([[ 0, 5, 10],
	##        [ 1, 6, 11],
	##        [ 2, 7, 12],
	##        [ 3, 8, 13],
	##        [ 4, 9, 14]])
</code></pre>
</div>
<p>当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX` 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.random.randn(6, 3)
np.dot(arr.T, arr)
	## array([[ 2.584 , 1.8753, 0.8888],
	##        [ 1.8753, 6.6636, 0.3884],
	##        [ 0.8888, 0.3884, 3.9781]])
</code></pre>
</div>
<p>对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
</code></pre>
</div>
<p>使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr                            			                   
	## array([[[ 0, 1, 2, 3],            
	##         [ 4, 5, 6, 7]],                                     
	##        [[ 8, 9, 10, 11],          
	##         [12, 13, 14, 15]]])                                      
arr.swapaxes(1, 2)          
    ## array([[[ 0, 4],
    ##         [ 1, 5],
    ##         [ 2, 6],
    ##         [ 3, 7]],
    ##        [[ 8, 12],
    ##        [ 9, 13],
    ##        [10, 14],
    ##        [11, 15]]])
</code></pre>
</div>
<p>类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。</p>

<h3 id="section-3">通用函数：快速的基于元素的数组函数</h3>
<p>一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。
许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Iarr = np.arange(10)
Inp.sqrt(arr)
	## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,
	##         2.6458, 2.8284, 3. ])
np.exp(arr)
	## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,
	##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])
</code></pre>
</div>
<p>这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x = randn(8)
y = randn(8)
x
	## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,
	##        -0.9337])
y
	## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,
	##        -0.7147])
np.maximum(x, y) # element-wise maximum
	## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,
	##        -0.7147])
</code></pre>
</div>
<p>虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = randn(7) * 5
np.modf(arr)
	##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),
	## array([-2., 4., -3., 5., -3., 3., -6.]))
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>实用的R函数</title>
      <link>http://xukuang.github.io/blog/2016/04/dots-in-r/</link>
      <pubDate>2016-04-21T09:46:58-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/dots-in-r</guid>
      <content:encoded><![CDATA[<p>这篇文章记录的是在使用R的过程中偶然遇到的非常实用的函数，然而由于这些函数在自己的学习中太常用特别容易忘记，所以这里记下来以便以后使用的时候可以查看。学无止境，长期更新。</p>

<h2 id="section">场景一</h2>
<p>在查看多个变量之间的两两相关性的时候，可以使用picante包中的cor.table()函数。</p>

<h2 id="section-1">场景二</h2>
<p>在R中加载了多个R包时，希望查看当前环境中都加载了哪些R包的find.package()函数，临时卸载某个R包可以使用函数detach(package:包名)。如要卸载dplyr包，则为detach(package:dplyr)。</p>

<h2 id="section-2">场景三</h2>
<p>expand.grid()用来建立一些factor相乘出来的矩阵或data.frame。<!--more--></p>

<div class="highlighter-rouge"><pre class="highlight"><code>expand.grid(x = c('A', 'B', 'C', 'D'), y = 1:3)
	#    x y
	# 1  A 1
	# 2  B 1
	# 3  C 1
	# 4  D 1
	# 5  A 2
	# 6  B 2
	# 7  C 2
	# 8  D 2
	# 9  A 3
	# 10 B 3
	# 11 C 3
	# 12 D 3
</code></pre>
</div>

<h2 id="section-3">场景四</h2>
<p>使用with()和within()函数对数据框列引用时，可以不用再输入长长的数据框名了。两者的区别在于，with只是生成了一列数据，而within生成一个包含原始数据的数据框。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>with(dat, y + 2)
	# [1] 4 5 6 7
within(dat, {z = y + 2; a = x + 3})
	#   x y a z
	# 1 1 2 4 4
	# 2 2 3 5 5
	# 3 3 4 6 6
	# 4 4 5 7 7
</code></pre>
</div>

<h2 id="section-4">场景五</h2>
<p>cut()函数可以把连续变量离散化，即numeric型的数据转换成factor型，可以与table()函数一起使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(x, breaks, labels = NULL,
    include.lowest = FALSE, right = TRUE, dig.lab = 3,
    ordered_result = FALSE, ...)
</code></pre>
</div>

<p><strong>主要参数</strong></p>

<p>x: 需要离散化的连续型向量</p>

<p>breaks: 向量类型，指定分类指标。默认的情况下，左开右闭合，这里可以结合正无穷(+Inf)和负无穷使用</p>

<p>labels：向量类型，指定分类指标的名称。如果不限定，则默认用分类指标为名称</p>

<p>inlude.lowest: 逻辑类型，指定边界是否闭合，默认的是边界不闭合</p>

<p>right: 逻辑类型，指定左开右闭合还是右开左闭合，默认的是TURE，左开右闭合</p>

<p>dig.lab: 数字，指定分类指标名称的数字位数。默认情况下，当labels为NULL时，指标名称的数字只显示3位</p>

<p>orederd_result: 逻辑类型，指定分类指标是否有序</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf))
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] (2.22,5] (5,Inf]

## 边界闭合，即包含左端的1
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), include.lowest = T)
	#  [1] [1,2.22] (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  [1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] [1,2.22] (5,Inf] 
	# Levels: [1,2.22] (2.22,5] (5,Inf]

## 左闭合右开
cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), right = F)
	#  [1] [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [5,Inf)  [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [2.22,5) [1,2.22) [5,Inf) 
	# Levels: [1,2.22) [2.22,5) [5,Inf)

## 指定分类名称
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), labels = c('small', 'middle', 'big'))
	#  [1] &lt;NA&gt;   middle middle big    big    small  middle big    big    middle &lt;NA&gt;   big   
	# Levels: small middle big

## 分类指标有序
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), ordered_result = T)
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] &lt; (2.22,5] &lt; (5,Inf]
</code></pre>
</div>

<h2 id="section-5">场景六</h2>
<p>求导数的函数。dxy=deriv(f~x^2+y^2,c(‘x’,’y’),func=T)</p>

<h2 id="section-6">场景七</h2>
<p>split()函数能将数据框按某一列分为包含若干个数据框的列表。然后，unsplit()可以将这个列表合并。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>data.table的包的简单介绍</title>
      <link>http://xukuang.github.io/blog/2016/04/data-table-in-R/</link>
      <pubDate>2016-04-13T07:56:01-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-table-in-R</guid>
      <content:encoded><![CDATA[<p>相比dplyr包，data.table包能够更大程度地提高数据的处理速度，这里就简单介绍一下data.tale包的使用方法。</p>

<h2 id="section">数据的读取</h2>
<p>data.table包中数据读取的函数是fread()。</p>

<h2 id="datatable-">data.table 的创建</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>library(data.table)
DT = data.table(x=rep(c("a","b","c"),each=3), y=c(1,3,6), v=1:9)
DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
</code></pre>
</div>
<!--more-->

<h2 id="section-1">基础操作</h2>

<h3 id="section-2">行提取</h3>
<p>行提取分为单行提取和多行提取。</p>

<h4 id="section-3">单行提取</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2]                      # 2nd row
	#    x y v
	# 1: a 3 2
DT[2,]                     # same
	#    x y v
	# 1: a 3 2
</code></pre>
</div>
<p>这里DT[2]和DT[2,]是完全相同的，这里的『,』只是说明还有其他参数可设置，而其他参数按默认值进行计算。下文所有这样的最后一个『,』都不再写出来。</p>

<h4 id="section-4">多行提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[1:2]
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
DT[c(2,5)]
	#   x y v
	#1: a 3 2
	#2: b 3 5
</code></pre>
</div>

<ul>
  <li>逻辑提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[c(FALSE,TRUE)]          # even rows (usual recycling)
	#    x y v
	# 1: a 3 2
	# 2: b 1 4
	# 3: b 6 6
	# 4: c 3 8
</code></pre>
</div>

<p>此时,c(FALSE,TRUE)会自己重复匹配成与DT的行数相同的向量</p>

<h3 id="section-5">列提取</h3>
<p>与行提取相同，列的提取也包含单列提取和多列提取。</p>

<h4 id="section-6">单列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>数字提取时，一定要把wth参数设置为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2,with=FALSE]          # 2nd column
	#    y
	# 1: 1
	# 2: 3
	# 3: 6
	# 4: 1
	# 5: 3
	# 6: 6
	# 7: 1
	# 8: 3
	# 9: 6
</code></pre>
</div>

<ul>
  <li>列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(v)]               # v column (as data.table
	#    v
	# 1: 1
	# 2: 2
	# 3: 3
	# 4: 4
	# 5: 5
	# 6: 6
	# 7: 7
	# 8: 8
	# 9: 9
</code></pre>
</div>

<h3 id="section-7">列名的修改</h3>
<p>列名的修改可以使用setnames()函数，这个函数好像比对data.frame类型数据名更改的names()和colnames()函数也要快一些。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dt = data.table(a=1:2,b=3:4,c=5:6) # compare to data.table
try(tracemem(dt))                  # by reference, no deep or shallow copies
setnames(dt,"b","B")               # by name, no match() needed (warning if "b" is missing)
setnames(dt,3,"C")                 # by position with warning if 3 &gt; ncol(dt)
setnames(dt,2:3,c("D","E"))        # multiple
setnames(dt,c("a","E"),c("A","F")) # multiple by name (warning if either "a" or "E" is missing)
setnames(dt,c("X","Y","Z"))        # replace all (length of names must be == ncol(DT))  
</code></pre>
</div>

<h4 id="section-8">多列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>如同上面对按数字对单列的提取，对多列提取也要设置with参数为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2:3,with=FALSE]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
DT[,c(1,3),with=FALSE] 
	#    x v
	# 1: a 1
	# 2: a 2
	# 3: a 3
	# 4: b 4
	# 5: b 5
	# 6: b 6
	# 7: c 7
	# 8: c 8
	# 9: c 9      
</code></pre>
</div>

<ul>
  <li>按列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(y, v)]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
</code></pre>
</div>

<p>如果按列名提取时，不使用列表，仍然能对列进行提取，只是结果以向量的形式输出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,v]                     # v column (as vector)
	# [1] 1 2 3 4 5 6 7 8 9
DT[,c(v)]                  # same
	# [1] 1 2 3 4 5 6 7 8 9   
DT[, c(y, v)]
	# [1] 1 3 6 1 3 6 1 3 6 1 2 3 4 5 6 7 8 9
</code></pre>
</div>

<h3 id="section-9">列的添加与删除</h3>

<h4 id="section-10">列的添加</h4>

<ul>
  <li>单列添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
DT[, a := 'k']
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
DT[,c:=8]        # add a numeric column, 8 for all rows
DT
	#    x y v a c
	# 1: a 1 1 k 8
	# 2: a 3 2 k 8
	# 3: a 6 3 k 8
	# 4: b 1 4 k 8
	# 5: b 3 5 k 8
	# 6: b 6 6 k 8
	# 7: c 1 7 k 8
	# 8: c 3 8 k 8
	# 9: c 6 9 k 8 
DT[,d:=9L]       # add an integer column, 9L for all rows
DT[2,d:=10L]     # subassign by reference to column d
DT
	#    x y v a c  d
	# 1: a 1 1 k 8  9
	# 2: a 3 2 k 8 10
	# 3: a 6 3 k 8  9
	# 4: b 1 4 k 8  9
	# 5: b 3 5 k 8  9
	# 6: b 6 6 k 8  9
	# 7: c 1 7 k 8  9
	# 8: c 3 8 k 8  9
	# 9: c 6 9 k 8  9
DT[, e := d + 2]
DT
	#    x y v a c  d  e
	# 1: a 1 1 k 8  9 11
	# 2: a 3 2 k 8 10 12
	# 3: a 6 3 k 8  9 11
	# 4: b 1 4 k 8  9 11
	# 5: b 3 5 k 8  9 11
	# 6: b 6 6 k 8  9 11
	# 7: c 1 7 k 8  9 11
	# 8: c 3 8 k 8  9 11
	# 9: c 6 9 k 8  9 11
</code></pre>
</div>
<p>如果添加的列名，数据中已经包含则是对这一列数据的修改。</p>

<ul>
  <li>多列的添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[, c('f', 'g') := list( d + 1, c)]
DT[, ':='( f =  d + 1, g = c)]          # same
DT
	#    x y v a c  d  e  f g
	# 1: a 1 1 k 8  9 11 10 8
	# 2: a 3 2 k 8 10 12 11 8
	# 3: a 6 3 k 8  9 11 10 8
	# 4: b 1 4 k 8  9 11 10 8
	# 5: b 3 5 k 8  9 11 10 8
	# 6: b 6 6 k 8  9 11 10 8
	# 7: c 1 7 k 8  9 11 10 8
	# 8: c 3 8 k 8  9 11 10 8
	# 9: c 6 9 k 8  9 11 10 8
</code></pre>
</div>
<p>此处，需要注意的是新创建的列只能依照原有数据列，而不能依照新创建的列。例如这个例子中，g = c是可以运行，而g = f则会提示错误。</p>

<h4 id="section-11">列的删除</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c:=NULL]     # remove column c
DT
	#    x y v a  d  e  f g
	# 1: a 1 1 k  9 11 10 8
	# 2: a 3 2 k 10 12 11 8
	# 3: a 6 3 k  9 11 10 8
	# 4: b 1 4 k  9 11 10 8
	# 5: b 3 5 k  9 11 10 8
	# 6: b 6 6 k  9 11 10 8
	# 7: c 1 7 k  9 11 10 8
	# 8: c 3 8 k  9 11 10 8
	# 9: c 6 9 k  9 11 10 8
DT[, c('d', 'e', 'f', 'g'):=NULL]     
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h2 id="section-12">列指标的简单操作</h2>
<p>简单操作主要包括求和、平均值、方差和标准差等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2:3,sum(v)]             # sum(v) over rows 2 and 3
# [1] 5
DT[2:3,mean(v)]             # sum(v) over rows 2 and 3
# [1] 2.5
</code></pre>
</div>

<h2 id="key">索引key</h2>

<h3 id="section-13">查看和创建索引</h3>
<p>索引是对列而言的，索引创建后，数据将自动按索引值进行重新排序，所以每个数据最多只能有一个索引，但是索引可以由多列组成，这些列可以是数字、因子、字符串或其他格式。</p>

<h4 id="section-14">单列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>
## methdod first
key(DT)                    # key
	# NULL 
setkey(DT,x)               # set a 1-column key. No quotes, for convenience.
key(DT)
[1] "x"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k

## method second
setkeyv(DT,"y")            # same (v in setkeyv stands for vector)
key(DT)
	# [1] "y"
</code></pre>
</div>
<p>一旦对数据进行新的索引，原有的索引将消失。</p>

<h4 id="section-15">多列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## methdod first                    # key 
setkey(DT,x,v)               # set a 1-column key. No quotes, for convenience.
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k


## method second
setkeyv(DT,c("x", "y"))           # same (v in setkeyv stands for vector)
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h3 id="section-16">通过索引进行数据的提取</h3>
<p>按照索引对数据提取，可以加快提取数据的速度。</p>

<h4 id="section-17">单索引</h4>
<p>正向提取</p>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x)
DT["a"]                    # binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.(x=="a")]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[x=="a"]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[!.("a")]                # not join
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!"a"]                   # same
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!2:4]                   # all rows other than 2:4
	#    x y v a
	# 1: a 1 1 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k

</code></pre>
</div>

<h4 id="section-18">多索引</h4>

<ul>
  <li>正向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x, y)
# Mehtod First
DT["a"]                    # join to 1st column of key
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a")]                 # same, .() is an alias for list()
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a",3)]               # join to 2 columns
    #    x y v a
	# 1: a 3 2 k
DT[.("a",3:6)]             # join 4 rows (2 missing)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[.("a",3:6),nomatch=0]   # remove missing
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[.("a",3:6),roll=TRUE]   # rolling join (locf)
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k

## Method Second
DT[J('a')]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[J("a",3)]               # binary search (fast)
	#    x y v a
	# 1: a 3 2 k
DT[J("a",3:6)]              # same; i.e. binary search (fast)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[J("a",3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[J("a",3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k


## Method Third
DT[list("a")]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[list("a",3)]
    #    x y v a
	# 1: a 3 2 k
DT[list("a", 3:6)]
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[list("a", 3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[list("a", 3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[x!="b" | y!=3]          # not yet optimized, currently vector scans
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k
DT[!.("b",3)]              # same result but much faster
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k

</code></pre>
</div>

<h2 id="section-19">分类汇总</h2>
<p>分类汇总是指按某列的分类指标进行简单操作，这里借助by参数实现。此外，by参数与索引相互没有影响。</p>

<h3 id="section-20">单指标的分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum(v),by=x]
	#    x V1
	# 1: a  6
	# 2: b 15
	# 3: c 24           
DT[,sum(v),by=y] 
	#    y V1
	# 1: 1 12
	# 2: 3 15
	# 3: 6 18          
</code></pre>
</div>
<ul>
  <li>
    <p>自定义汇总名称
<code class="highlighter-rouge">
DT[,list(sum.v.x = sum(v)),by=x]
  #    x sum.v.x
  # 1: a       6
  # 2: b      15
  # 3: c      24           
DT[,list(sum.v.y = sum(v)),by=y] 
  #    y sum.v.y
  # 1: 1      12
  # 2: 3      15
  # 3: 6      18 
DT[,sum.v.y := sum(v) ,by=y]
  #    x y v a sum.v.y
  # 1: a 1 1 k      12
  # 2: a 3 2 k      15
  # 3: a 6 3 k      18
  # 4: b 1 4 k      12
  # 5: b 3 5 k      15
  # 6: b 6 6 k      18
  # 7: c 1 7 k      12
  # 8: c 3 8 k      15
  # 9: c 6 9 k      18 	
</code></p>
  </li>
  <li>
    <p>汇总结果与原始数据进行匹配</p>
  </li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum.v.y := sum(v) ,by=y]
	#    x y v a sum.v.y
	# 1: a 1 1 k      12
	# 2: a 3 2 k      15
	# 3: a 6 3 k      18
	# 4: b 1 4 k      12
	# 5: b 3 5 k      15
	# 6: b 6 6 k      18
	# 7: c 1 7 k      12
	# 8: c 3 8 k      15
	# 9: c 6 9 k      18
</code></pre>
</div>

<h3 id="section-21">多指标的多个分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean(v),sum(v)),by=list(x,y)]   # keyed by
	#    x y V1 V2
	# 1: a 1  1  1
	# 2: a 3  2  2
	# 3: a 6  3  3
	# 4: b 1  4  4
	# 5: b 3  5  5
	# 6: b 6  6  6
	# 7: c 1  7  7
	# 8: c 3  8  8
	# 9: c 6  9  9
</code></pre>
</div>

<ul>
  <li>自定义汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean.v = mean(v),sum.v = sum(v)),by=list(x,y)]   # keyed by
	#   x y mean.v sum.v
	#1: a 1      1     1
	#2: a 3      2     2
	#3: a 6      3     3
	#4: b 1      4     4
	#5: b 3      5     5
	#6: b 6      6     6
	#7: c 1      7     7
	#8: c 3      8     8
	#9: c 6      9     9
</code></pre>
</div>

<ul>
  <li>汇总结果与原始数据进行匹配</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c("mean.v", "sum.v.y") := list(mean(v),sum(v)) ,by=list(x,y)]
	#    x y v a sum.v.y mean.v
	# 1: a 1 1 k       1      1
	# 2: a 3 2 k       2      2
	# 3: a 6 3 k       3      3
	# 4: b 1 4 k       4      4
	# 5: b 3 5 k       5      5
	# 6: b 6 6 k       6      6
	# 7: c 1 7 k       7      7
	# 8: c 3 8 k       8      8
	# 9: c 6 9 k       9      9

</code></pre>
</div>

<h2 id="datatabledataframe">data.table与data.frame的转化</h2>
<p>data.table格式加快了处理速度，而data.frame则更为基础。两者的转化可以通过data.table(),setDT()和setDT()来实现，其中data.table()和setDT()函数可以将数据从data.frame转化为data.table，setDF()函数可以将数据从data.table转化为data.frame。注意使用data.table(),setDT()和setDT()时，参数本身的数据类型也会发生变化。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class(DT)
	# [1] "data.table" "data.frame"  
class(setDF(DT))
	# [1] "data.frame"
class(DT)
	# [1] "data.frame"
</code></pre>
</div>
<p>此外，data.table包还可以与基础包中的duplicated()、unique()、subset() 函数结合使用。 不仅如此，data.table包还有一些基础包的替代函数。rbind()升级版的rbindlist()，可以合并列数不同和列位置不同的数据。比dplyr包中arrange()函数更快的setorder()排序函数。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>长宽数据之间的转化(二)</title>
      <link>http://xukuang.github.io/blog/2016/04/data-fomrat/</link>
      <pubDate>2016-04-10T04:32:19-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-fomrat</guid>
      <content:encoded><![CDATA[<p>前面一篇<a href="http://xukuang.github.io/2016/01/18/melt-and-dcast/">文章</a>讲了用reshape2包中的函数实现长宽数据的转化，而tidyr是reshape2的升级版，主要用于数据框。这篇文章将介绍一下如何使用tidyr包中的函数实现长宽数据的转化。</p>

<h2 id="section">1. 宽数据转化为长数据</h2>

<h3 id="gather">gather函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>gather(data, key, value, ..., na.rm = FALSE, convert = FALSE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定转化后数据框的指标列的列名，用于存放原数据中不同的数据指标</p>

<p><strong>value</strong>  指定转化后数据框的数据列的列名，用于存放原数据中不同的数据指标对应的值</p>

<p><strong>…</strong> 指定哪些列聚到一列中。按那些列数据作为标准转化，这个参数接不能有那些列</p>

<p><strong>na.rm</strong> 确定是否去除数据中的NA，默认情况下为FALSE，不去除NA
<!--more--></p>

<h3 id="section-1">实例</h3>

<ul>
  <li>将所有列排成长数据(默认情况下)</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 加载数据
library(reshape2)
head(airquality)
	# 	Month Day variable value
	# 1     5   1    Ozone    41
	# 2     5   2    Ozone    36
	# 3     5   3    Ozone    12
	# 4     5   4    Ozone    18
	# 5     5   5    Ozone    NA
	# 6     5   6    Ozone    28
dim(airquality)
	# [1] 612   4
library(tidyr)
dat1 = gather(airquality, time, value)
head(dat1)
    #    time value
    # 1 Ozone    41
    # 2 Ozone    36
    # 3 Ozone    12
    # 4 Ozone    18
    # 5 Ozone    NA
    # 6 Ozone    28
tail(dat1)
    #         time value
    # 913  Day    25
    # 914  Day    26
    # 915  Day    27
    # 916  Day    28
    # 917  Day    29
    # 918  Day    30
dim(dat1)	
	# [1] 918   2
</code></pre>
</div>

<ul>
  <li>按Month将其他指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 方法一
dat2 = gather(airquality, time, value, Ozone:Temp, Day)
# 方法二
dat2 = gather(airquality, time, value, -Month)
head(dat2)
	#    Month Day  time value
	# 1     5   1 Ozone    41
	# 2     5   2 Ozone    36
	# 3     5   3 Ozone    12
	# 4     5   4 Ozone    18
	# 5     5   5 Ozone    NA
	# 6     5   6 Ozone    28
tail(dat2)
	#     Month Day time value
	# 607     9  25 Temp    63
	# 608     9  26 Temp    70
	# 609     9  27 Temp    77
	# 610     9  28 Temp    75
	# 611     9  29 Temp    76
	# 612     9  30 Temp    68
</code></pre>
</div>

<ul>
  <li>按Month和Day列将其它列指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dat3 = gather(airquality, type, value.type, Ozone:Temp)
dat3 = gather(airquality, type, value.type, -Month, -Day)
head(dat3) 
	# 	 Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 5     5   5 Ozone         NA
	# 6     5   6 Ozone         28
dim(dat3)
	# [1] 612   4
</code></pre>
</div>

<ul>
  <li>去除排列后数据中的NA</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>#　 airquality$Ozone 数的前四列有44 个NA
table(is.na(airquality$Ozone)) # 37
	# FALSE  TRUE 
	#   116    37 
table(is.na(airquality$Solar.R)) # 4
	# FALSE  TRUE 
	#   146     7 
table(is.na(airquality$Temp)) # 0
	# FALSE 
	#   153 
table(is.na(airquality$Wind)) # 0
	# FALSE 
	#   153 
dat4 = gather(airquality, type, value.type, Ozone:Temp, na.rm = TRUE)
head(dat4)
	#   Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 6     5   6 Ozone         28
	# 7     5   7 Ozone         23
dim(dat4)# 比dat3少44行
	# [1] 568   4	
</code></pre>
</div>

<h2 id="section-2">2. 长数据转化为宽数据</h2>

<h3 id="spread">spread函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定需要将变量值拓展为字段的变量</p>

<p><strong>value</strong>  指定要分散的值</p>

<p><strong>fill</strong> 确认不存在的组合值的显示结果。默认的显示为NA。数据类型为数值型向量</p>

<p><strong>drop</strong> 确认不存在分分类组合是否显示，默认情况下显示。当然，如果drop = T，那么fill参数的设置将失去意义</p>

<h3 id="section-3">实例</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">air1</span> <span class="o">=</span>  <span class="n">spread</span><span class="p">(</span><span class="n">dat4</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">value.type</span><span class="p">)</span>
<span class="n">dim</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span>
	<span class="c1"># [1] 153   6
</span><span class="n">head</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span> <span class="c1"># 数据与airquality相同
</span>	<span class="c1"># 	Month Day Ozone Solar.R Wind Temp
</span>	<span class="c1"># 1     5   1    41     190  7.4   67
</span>	<span class="c1"># 2     5   2    36     118  8.0   72
</span>	<span class="c1"># 3     5   3    12     149 12.6   74
</span>	<span class="c1"># 4     5   4    18     313 11.5   62
</span>	<span class="c1"># 5     5   5    NA      NA 14.3   56
</span>	<span class="c1"># 6     5   6    28      NA 14.9   66
</span></code></pre>
</div>

<p>不存在的分类是否显示，以及怎么显示</p>

<div class="highlighter-rouge"><pre class="highlight"><code>air5 = spread(dat4, type, value.type, drop = F) # 组合上存在的结果都显示
tail(air5) # 这里的最后一行只是组合上存在，原数据中并不在
	# 		 Month Day Ozone Solar.R Wind Temp
	# 150      9  26     1       1    1    1
	# 151      9  27     1       1    1    1
	# 152      9  28     1       1    1    1
	# 153      9  29     1       1    1    1
	# 154      9  30     1       1    1    1
	# 155      9  31     0       0    0    0
tail(spread(dat4, type, value.type, drop = F, fill= -1)) # 更改不存在结果的显示值，最后一行显示为-1
	# 		Month Day Ozone Solar.R Wind Temp
	# 150     9  26     1       1    1    1
	# 151     9  27     1       1    1    1
	# 152     9  28     1       1    1    1
	# 153     9  29     1       1    1    1
	# 154     9  30     1       1    1    1
	# 155     9  31    -1      -1   -1   -1
</code></pre>
</div>

<h2 id="tidyr">tidyr包中的其它函数</h2>

<h3 id="seperate">seperate函数</h3>

<p>unite()函数可将多列合并为一列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>unite(data, col, ..., sep = "_", remove = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 被组合的新列名称</p>

<p><strong>…</strong> 指定哪些列需要被组合</p>

<p><strong>sep</strong> 组合列之间的连接符，默认为下划线</p>

<p><strong>remove</strong> 是否删除被组合的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set.seed(10)
date &lt;- as.Date('2016-04-10') + 0:14
hour &lt;- sample(1:24, 15)
min &lt;- sample(1:60, 15)
second &lt;- sample(1:60, 15)
event &lt;- sample(letters, 15)
data &lt;- data.frame(date, hour, min, second, event)
data
	# 			date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n

dataNew &lt;- data %&gt;%
  unite(datehour, date, hour, sep = ' ') %&gt;%
  unite(datetime, datehour, min, second, sep = ':')
	#              datetime event
	#1  2016-04-10 13:26:33     e
	#2     2016-04-11 8:4:6     a
	#3  2016-04-12 10:16:10     l
	#4  2016-04-13 15:23:52     c
	#5   2016-04-14 2:47:24     r
	#6   2016-04-15 5:48:42     h
	#7  2016-04-16 19:34:45     s
	#8  2016-04-17 18:42:51     z
	#9  2016-04-18 22:19:36     i
	#10  2016-04-19 7:21:26     d
	#11 2016-04-20 16:36:14     j
	#12 2016-04-21 23:53:12     g
	#13  2016-04-22 20:12:1     o
	#14 2016-04-23 21:37:35     f
	#15  2016-04-24 4:17:49     n

</code></pre>
</div>
<p>tidyr包中的函数也可使用管道操作符%&gt;%。</p>

<h3 id="seperate-1">seperate函数</h3>
<p>separate()函数可将一列拆分为多列，一般可用于日志数据或日期时间型数据的拆分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 需要被拆分的列</p>

<p><strong>into</strong> 新建的列名，为字符串向量</p>

<p><strong>sep</strong> 被拆分列的分隔符</p>

<p><strong>remove</strong> 是否删除被分割的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dataold &lt;- dataNew %&gt;% 
  separate(datetime, c('date', 'time'), sep = ' ') %&gt;% 
  separate(time, c('hour', 'min', 'second'), sep = ':')
dataold
	# 		date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>简单线性回归中各指标在R中的计算</title>
      <link>http://xukuang.github.io/blog/2016/04/simple-linear-regression/</link>
      <pubDate>2016-04-07T08:50:50-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/simple-linear-regression</guid>
      <content:encoded><![CDATA[<h2 id="section">前话</h2>
<p>简单线性回归用于计算两个连续型变量(如X，Y)之间的线性关系，具体地说就是计算下面公式中的<script type="math/tex">\alpha和\beta</script>。</p>

<script type="math/tex; mode=display">Y = \alpha + \beta X + \varepsilon</script>

<p>其中<script type="math/tex">\varepsilon</script>称为残差,服从从<script type="math/tex">N(0,\sigma^2)</script>的正态分布，自由度为(n-1) - (2-1) = n-2
为了找到这条直线的位置，我们使用最小二乘法(least squares approach)。最小二乘法确保所有点处的残差的平方和最小时计算<script type="math/tex">\alpha和\beta</script>，即下面示意图中<script type="math/tex">\sum_{i=1}^{4}\varepsilon_i^2 = \varepsilon_1^2 + \varepsilon_2^2 + \varepsilon_3^2 + \varepsilon_4^2</script>有最小值。</p>

<p><img src="http://xukuang.github.io/blog/images/y_x_scatter_plot.png" alt="简单线性相关示意图" /><!--more--></p>

<h2 id="section-1">各指标的计算</h2>

<p>运用最小二乘法找出的这条最优直线一定经过点<script type="math/tex">(\overline{x}, \overline{y})</script>。其中</p>

<h3 id="betaalpha">斜率<script type="math/tex">\beta</script>和截距<script type="math/tex">\alpha</script>的估计值</h3>

<p><img src="http://xukuang.github.io/blog/images/beta.png" alt="" /></p>

<h3 id="pearsonr">Pearson相关系数r</h3>

<script type="math/tex; mode=display">r_{xy} = \frac{\overline{xy} - \bar{x}\bar{y} }{ \sqrt{ \left(\overline{x^2} - \bar{x}^2\right)\left(\overline{y^2} - \bar{y}^2\right)}}</script>

<h3 id="section-2">方差分析</h3>
<p>在方差分析(ANOVA)中，总的平方和包含回归平方和残差平方和两部分。</p>

<ul>
  <li>总的平方和</li>
</ul>

<p><script type="math/tex">SS_{tot}=\sum_i (y_i-\bar{y})^2</script>
其自由度为 n - 1，这里n为观测点的个数。</p>

<ul>
  <li>回归的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{reg}=\sum_i (\hat y_i -\bar{y})^2</script>
其自由度为 2 - 1 = 1。</p>

<ul>
  <li>残差的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{res}=\sum_i (y_i - \hat y_i)^2=\sum_i e_i^2</script>
其自由度为 (n -1) - (2 - 1) = n -2。</p>

<h3 id="section-3">决定系数(拟合优势度)</h3>

<p><img src="http://xukuang.github.io/blog/images/error.png" alt="" />
决定系数是用来表示模型的解释度，理论上与相关系数没有关系，只是在简单线性回归中，决定系数$R^2 $值等于Pearson相关系数r的平方。</p>

<h2 id="r">R中的实现</h2>

<h3 id="section-4">线性模拟</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>x = c(0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.23)
y = c(42.0, 43.5, 45.0, 45.5, 45.0, 47.5, 49.0, 53.0, 50.0, 55.0, 55.0, 60.0)
fit = lm(y ~ x)
summary(fit)
	## Call:
	## lm(formula = y ~ x)
	## 
	## Residuals:
	##	 #Min      1Q  Median      3Q     Max 
	## -2.0431 -0.7056  0.1694  0.6633  2.2653 
	## 
	## Coefficients:
	## 				#Estimate Std. Error t value Pr(&gt;|t|)    
	## (Intercept)   28.493      1.580   18.04 5.88e-09 ***
	## x            130.835      9.683   13.51 9.50e-08 ***
	## ---
	## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
	## 
	## Residual standard error: 1.319 on 10 degrees of freedom
	## Multiple R-squared:  0.9481,    Adjusted R-squared:  0.9429 
	## F-statistic: 182.6 on 1 and 10 DF,  p-value: 9.505e-08
anova(fit)
	##Analysis of Variance Table
	##
	##Response: y
	##			#Df Sum Sq Mean Sq F value    Pr(&gt;F)    
	##x          1 317.82  317.82  182.55 9.505e-08 ***
	##Residuals 10  17.41    1.74                      
	##---
	##Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

</code></pre>
</div>

<h3 id="section-5">线性模拟各参数的提取</h3>

<div class="highlighter-rouge"><pre class="highlight"><code># 可以通过names函数查看summary(fit)中个具体参数的提取方法
names(summary(fit))
# 提取R square
summary(fit)$r.squared ## 依照该形式可以提取names(summary(fit))中任意指标
# 其它常用指标的提取
# 提取模型lm或glm提取回归系数
coefficients(fit)
# 还可简化为
coef(fit)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
resid(fit)
# 提取lm或glm对象中残差的平方和
deviance(fit)
# 提取lm或glm对象中的方差分析表
# 其中p值越小，差异越显著, beita1越不可能为0
anova(fit)
# 预测数据
new &lt;- data.frame(x=c(0.16, 2.3))
predict(fit, new)

## 也可以做出预测区间
predict(fit, new, interval = 'prediction', levels = 0.95)
</code></pre>
</div>

<h3 id="section-6">线性模拟各参数中各量的算法</h3>

<h4 id="section-7">五个和的计算</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 预备统计量(Sums of square and sums of producte)
Sx = sum(x)
Sy = sum(y)
Sxx = sum((x - mean(x))^2)
Syy = sum((y - mean(y))^2)
Sxy = sum((x - mean(x)) * (y - mean(y)))

## 这里仅仅作为补充,具体原因不是很清楚
Syy = deviance(lm(y~1))
n = length(x)
</code></pre>
</div>

<h4 id="section-8">回归系数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 回归系数$\alpha$和$beta$（这样计算，residuals有最小值)
beta = Sxy/Sxx
beta
alpha = mean(y) - beta*mean(x)
alpha
# 提取lm或glm对象中的回归系数
coef(fit)
</code></pre>
</div>

<h4 id="section-9">残差及五分位数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>residuals = y - (beta + alpha * x)
residuals
quantile(residuals)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
</code></pre>
</div>

<h4 id="pearsonr-1">Pearson相关系数r</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>r = sqrt(Sxy/(Sxx * Syy))
r
</code></pre>
</div>

<h4 id="r-1">R平方</h4>
<p>决定系数，其值为 回归的平方和/总的平方和。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rsquare = (Syy - sum(residuals^2))/Syy
rsquare
</code></pre>
</div>

<h4 id="adjust-r">adjust R平方</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 考虑到了自变量的个数, 包括截距在内, 本例子中k = 2
n = length(x)
k = 2
adjustrsquare = 1- (1-rsquare)*(n-1)/(n-k)
adjustrsquare
</code></pre>
</div>

<h3 id="f">回归方程的F检验</h3>
<p>在简单线性回归的模型，我们可以在<script type="math/tex">β = 0</script>时，对F统计量进行检验。
在F检验中统计量F</p>

<script type="math/tex; mode=display">F = \frac{(回归的平方和/回归的自由度)}{(误差的平方和/误差的自由度}</script>

<p>对应p值越小，说明此时越小的概率时间发生了，越不能接受原假设。</p>

<h3 id="t">斜率β的t检验</h3>
<p>在简单线性回归的模型，我们可以检验回归系数(斜率)β是否相等于特定的$β_0$(通常使$β_0 = 0$以检验$x_i$对$y_i$是否有关联)。
统计量t</p>

<p><img src="http://xukuang.github.io/blog/images/student_t.png" alt="" />
在零假设为$β = β_0$的情况下服从自由度为n − 2之t分布，其中</p>

<p><img src="http://xukuang.github.io/blog/images/student_se.png" alt="" />
同F检验一样，p值越小，说明此时越小的概率事件发生了，越不能接受原假设。</p>

<h2 id="section-10">话外篇</h2>
<p>在R中，lm(y ~ x)和lm(y ~ x + 1)的效果是相同的。此外，lm(y ~ 1)中截距的估计值为y的平均值，残差为每个y与均值的离差。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>离散型随机变量的常用统计指标</title>
      <link>http://xukuang.github.io/blog/2016/04/moment-in_statistics/</link>
      <pubDate>2016-04-06T16:25:50-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/moment-in_statistics</guid>
      <content:encoded><![CDATA[<h2 id="section">期望</h2>

<script type="math/tex; mode=display">E[X] = \sum_{i=1}^n x_i</script>

<p>期望存在一下特性:</p>

<p>1.<script type="math/tex">E[aX + bY] = aE[X] + bE(Y)</script></p>

<p>2.一般情况下，<script type="math/tex">E[X Y] \neq E[X]E(Y)</script>；当X和Y相互独立时，才有<script type="math/tex">E[X Y] = E[X]E(Y)</script></p>

<h2 id="section-1">方差</h2>
<p>方差描述的是随机变量的离散程度，也就是该变量离其期望值的距离。</p>

<script type="math/tex; mode=display">Var(X) = E[(X -E[X])^2] = E[X^{2} - 2X E[X] + (E[X])^{2}] = E[X^{2}] - (E[X])^{2}</script>

<p>此外，方差还可以看作是随机变量和自身的协方差<script type="math/tex">Var(X) = Cov(X, X)</script>。</p>

<h2 id="section-2">标准差</h2>
<p>标准差是一组数值自平均值分散开来的程度的一种测量观念。</p>

<p>总体的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N}}</script>

<p>样本的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N - 1}}</script>

<h2 id="section-3">标准误</h2>
<p>标准误差针对样本统计量而言，是某个样本统计量的标准差。当谈及标准误差时，一般须指明对应的样本统计量才有意义。以下以样本均值（样本均值是一种样本统计量）作为例子。于是，假设可以从总体中随机选取无限的大小相同的样本，那每个样本都可以有一个样本均值。依此法可以到一个由无限多样本均值组成的总体，该总体的标准差即为标准误差。</p>

<script type="math/tex; mode=display">SE = \frac{SD}{\sqrt{N}}</script>

<h2 id="section-4">协方差</h2>
<p>协方差用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</p>

<script type="math/tex; mode=display">Cov(X, Y) = E((X - E[X])(Y - E(Y)) = E[XY] - E[X] E[Y]</script>

<p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。如果X与Y是统计独立的，那么二者之间的协方差就是0，但是反过来并不成立，即如果X与Y的协方差为0，二者并不一定是统计独立的。</p>

<h2 id="section-5">协方差的相关性η(线性相关)</h2>

<script type="math/tex; mode=display">\eta =  \frac{cov(X, Y)}{\sqrt{var(X) \cdot var(Y)}}</script>

<p>协方差的相关性η更准确地说是线性相关的相关系数r，是一个衡量线性独立的无量纲数，其取值在[－1,+1]之间。相关性η = 1时称为“完全线性相关”(相关性η = -1时称为“完全线性负相关”)，此时将<script type="math/tex">Y_{i}</script>对<script type="math/tex">X_{i}</script>作Y-X散点图，将得到一组精确排列在直线上的点；相关性数值介于－1到1之间时，其绝对值越接近1表明线性相关性越好，作散点图得到的点的排布越接近一条直线。相关性为0(因而协方差也为0)的两个随机变量又被称为是不相关的，或者更准确地说叫作“线性无关”、“线性不相关”，这仅仅表明X 与Y两随机变量之间没有线性相关性，并非表示它们之间一定没有任何内在的（非线性）函数关系，和前面所说的“X、Y二者并不一定是统计独立的”说法一致。</p>

<p>-—–</p>

<p><strong>本篇文章整理自维基百科。</strong></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
