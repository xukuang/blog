<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
        xmlns:content="http://purl.org/rss/1.0/modules/content/"
        xmlns:atom="http://www.w3.org/2005/Atom"
  >
  <channel>
    <title>Xu Kuang</title>
    <atom:link href="http://xukuang.github.io/blog/feed/" rel="self" type="application/rss+xml" />
    <link>http://xukuang.github.io</link>
    <lastBuildDate>2016-05-04T17:52:37-06:00</lastBuildDate>
    <webMaster>kuang_xu@126.com</webMaster>
    
    <item>
      <title>Numpy包的学习</title>
      <link>http://xukuang.github.io/blog/2016/04/numpy/</link>
      <pubDate>2016-04-27T07:04:53-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/numpy</guid>
      <content:encoded><![CDATA[<p>Numpy 是 Numerical python 的简称，是高性能计算和数据分析的基础包。其实它 本身并没有提供多么高级的数据结构和分析功能，但它是很多高级工具（如 pandas）构建的基础，在结构和操作上具有统一性，因此理解 Numpy 的数组及面向数组的计算有助于更加高效地使用诸如 pandas 之类的工具。</p>

<p>Numpy 的核心内容是它的多维数组对象——ndarray（N-Dimensions Array），整个包几乎都是围绕这个对象展开。</p>

<h3 id="ndarray">ndarray：多维数组对象</h3>
<p>Numpy 的 ndarray 提供了一种将同质数据块解释为多维数组对象的方式。同质，表示数组的元素必须都是相同的数据类型（如 int，float 等）；解释，表示 ndarray 的数据块其实是线性存储的，并通过额外的元信息解释为多维数组结构。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import pandas as pd
array1 = np.array([[ 0.9526, -0.246 , -0.8856], 
				   [ 0.5639, 0.2379, 0.9104]])
array1
	## array([[ 0.9526, -0.246 , -0.8856],
	## 		[ 0.5639,  0.2379,  0.9104]])
array1 * 10
	## array([[ 9.526, -2.46 , -8.856],
	##        [ 5.639,  2.379,  9.104]])
array1 + array1
	## array([[ 1.9052, -0.492 , -1.7712],
	##        [ 1.1278,  0.4758,  1.8208]])
</code></pre>
</div>

<p>上面是一个 2×3 的矩阵。在使用类似 2×3×4…这种格式表示多维数组的结构时，从左向右的数字对应表示由表及里的维度，或称为轴，按索引给轴编号后可称为“轴 0”、“轴 1”和“轴2”等）</p>

<div class="highlighter-rouge"><pre class="highlight"><code>array1.shape
	## (2, 3)
array1.dtype
	## dtype('float64')
array1.strides
	## (24, 8)
</code></pre>
</div>
<p>这个矩阵的形状（shape）是（2,3）或 2×3，即它有 2 个长度为 3 的一维数组；它的 dtype 是 float64 表示它的单位元素是占 8 字节的浮点型；跨度（strides）元组指的是在某一维度下为了获取到下一个元素需要“跨过”的字节数。可见跨度是可以由 形状+dtype 来确定的。显然这种同质的静态数据结构在进行数值运算时效率要比 Python 内建的可以混杂动态类型的列表要快得多。</p>

<h3 id="ndarray-1">ndarray对象的创建</h3>
<p>创建数组的方法是使用array( )函数。它接受一切序列对象，产生一个包含所传递的数据的新ndarry数组，维度视序列的嵌套深度而定。首先，列表就是一个很好的用于转换的候选。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data1 = [6, 7.5, 8, 0, 1]
arr1 = np.array(data1)
arr1
	## array([ 6. , 7.5, 8. , 0. , 1. ])
</code></pre>
</div>

<p>嵌套序列，如等长列表的列表，将会转化为一个多维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data2 = [[1, 2, 3, 4], [5, 6, 7, 8]]
arr2 = np.array(data2)
arr2
	## array([[1, 2, 3, 4],
	##        [5, 6, 7, 8]])
arr2.ndim
	## 2
arr2.shape
	## (2, 4)
</code></pre>
</div>
<p>数组的 dtype 会由系统自动推定，除非你显式传递一个参数进去。系统一般会默认使用 int32 或 float64。
除 array() 之外，还有许多函数来创建新的数组。</p>

<p><strong>数组构建函数</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">函数</th>
      <th style="text-align: left">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">array</td>
      <td style="text-align: left">转换输入数据（列表，数组或其它序列类型）为ndarray，可以推断一个dtype或明确的设置一个dtype，默认拷贝输入数据</td>
    </tr>
    <tr>
      <td style="text-align: left">asarray</td>
      <td style="text-align: left">将输入转换为 ndarray，若输入本身是 ndarray 就不拷贝</td>
    </tr>
    <tr>
      <td style="text-align: left">arange</td>
      <td style="text-align: left">同内建的range函数，但不返回的不是列表而是一个一维的ndarray</td>
    </tr>
    <tr>
      <td style="text-align: left">ones, ones_like</td>
      <td style="text-align: left">根据提供的shape和dtype产生一个全1的数组；ones_like使用另一个数组为参数，产生一个shape和dtype都相同的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">zeros, zeros_like</td>
      <td style="text-align: left">同ones和ones_like，但是生成一个全0的数组</td>
    </tr>
    <tr>
      <td style="text-align: left">empty, enpty_like</td>
      <td style="text-align: left">创建新数组，但只分配内存空间不赋值</td>
    </tr>
    <tr>
      <td style="text-align: left">eye, identity</td>
      <td style="text-align: left">创建一个NxN的单位方阵（对角线上为1，其余为0）</td>
    </tr>
  </tbody>
</table>

<p>例如，zeros 和 ones 使用给定的长度或形状分别的创建0‘s 和 1‘s数组。
<code class="highlighter-rouge">
np.zeros(10)
	## array([ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])
np.zeros((3, 6))
	## array([[ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.],
	##        [ 0., 0., 0., 0., 0., 0.]])
np.empty((2, 3, 2))
	## array([[[ 4.94065646e-324, 4.94065646e-324],
	##         [ 3.87491056e-297, 2.46845796e-130],
	##         [ 4.94065646e-324, 4.94065646e-324]],
	##        [[ 1.90723115e+083, 5.73293533e-053],
	##         [ -2.33568637e+124, -6.70608105e-012],
	##         [ 4.42786966e+160, 1.27100354e+025]]])
</code>
在 pandas 中尽量不要使用 np.empty()，这个函数创建的数组里面是有值的，除非你确定创建的这个数组能被完全赋值，否则后面运算起来很麻烦，这些“空值”的布尔类型是 True，而且 dropna() 方法删不掉。想创建空的 Series ，可以使用 Series(np.nan,index=???)。</p>

<p>arange 是python内建 range 函数的数组版本。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>np.arange(15)
	## array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])
</code></pre>
</div>

<h3 id="ndarray-">ndarray 对象的属性</h3>
<p>.reshape(shape)</p>

<p>此方法用于改变数组的形状。虽然我觉得既然 ndarray 对象的数据块都是线性存储的，按说调用 .reshape() 方法的话只需要改一下数据头中的 shape 属性就可以了啊，但实际上不是这样子的！a.reshape(shape, order=’C’) 方法会返回一个新数组，而不是直接改变调用者的形状。</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>foo = np.arange(9)
bar = foo.reshape((3,3))
bar
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
foo
array([0, 1, 2, 3, 4, 5, 6, 7, 8])</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.astype(dtype)</p>

<p>这是一个用于转换数组 dtype 的方法，从前面的 ndarray 数据结构可以猜到，这种转换必然需要创建一个新数组。如果转换过程因为某种原因而失败了，就会引发一个 TypeError 异常。另外，如 np.int32() 这样把 dtype 当做函数来用也是可行的，但更推荐 .astype() 方法：</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>bar.astype(float)
array([[ 0.,  1.,  2.],
       [ 3.,  4.,  5.],
       [ 6.,  7.,  8.]])
本例中使用 Python 内建的 float 当做 dtype 传了进去，也是可行的哦，当对数据大小不敏感时就可以这么做。</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.transpose(*axes)</p>

<p>转置方法返回的是原数组的视图（不复制）。因为我对多维数组也搞不太懂，就只举个二维数组的例子吧（不给 axes 参数）：</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>foo = np.arange(8).reshape(2,4)
foo
array([[0, 1, 2, 3],
       [4, 5, 6, 7]])
foo.transpose()
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
foo.T
array([[0, 4],
       [1, 5],
       [2, 6],
       [3, 7]])
数组的 .T 属性是轴对换的快捷方式。一般在计算矩阵点积时比较方便：np.dot(arr,att.T)。嗯，简单的乘法（星号）是广播运算，点积需要使用 dot() 函数。</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>.sort()</p>

<p>ndarray 的 .sort(axis=-1, kind=’quicksort’, order=None) 方法可用于给数组在指定轴向上排序。比如一个 （4，3，2）的数组，它的对应轴向分别为（2，1，0），方法默认的 axis=-1 代表最外层维度，如 “表” 里的 “行”。</p>

<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([[1,4], [3,1]])
a
array([[1, 4],
       [3, 1]])
np.sort(a,0)
array([[1, 1],
       [3, 4]])
np.sort(a,1)
array([[1, 4],
       [1, 3]])
这里使用了外部函数 np.sort() 是为了在演示过程中不会影响到原数组。np.sort() 函数总是返回一份拷贝，而 .sort() 方法则会更改原数组。</p>
    </blockquote>
  </blockquote>
</blockquote>

<h4 id="section">数组和纯量间的操作</h4>

<p>数组非常重要，因为它们使你不使用循环就可以在数据上进行一系列操作。这通常被叫做矢量化。相同大小的数组间的算术运算，其操作作用在对应的元素上。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.array([[1., 2., 3.], [4., 5., 6.]])
arr
	## array([[ 1.,  2.,  3.],
	##        [ 4.,  5.,  6.]])
arr * arr                 
	## array([[  1.,   4.,   9.],       
	##        [ 16.,  25.,  36.]])
</code></pre>
</div>

<p>纯量的算术操作正如你期望的一样，把操作值作用于每一个元素：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 / arr                       
	## array([[ 1. , 0.5 , 0.3333],            
	##        [ 0.25 , 0.2 , 0.1667]])
</code></pre>
</div>

<h4 id="section-1">基本的索引和切片</h4>
<p>Numpy的索引是一个内容丰富的主题，因为有许多方法可以使你在你的数据中选取一个子集或单个元素。一维的数组很简单，表面上它们的行为类似于python的列表。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(10)
arr
	## array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
arr[5]
	## 5
arr[5:8]
	## array([5, 6, 7])
arr[5:8] = 12
arr
	## array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])
</code></pre>
</div>
<p>如你所见，当你给一个切片赋一纯量值，如 arr[5:8] = 12 所示，该值被传送(或传播)到整个选择区域。与列表的第一个重要的区别是数组的切片在原来的数组上（不生成新的数组）。这意味着数据不会被拷贝，且对切片的任何修改都会影响源数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr_slice = arr[5:8]
arr_slice[1] = 12345
arr_slice
	## array([   12, 12345,    12])
arr
	## array([ 0, 1, 2, 3, 4, 12, 12345, 12, 8, 9])
arr_slice[:] = 64
arr_slice
	## array([64, 64, 64])
arr
	## array([ 0, 1, 2, 3, 4, 64, 64, 64, 8, 9])
</code></pre>
</div>
<p>如果你是使用Numpy的新手，这一点会使你感到惊讶『真的惊讶到我了』，尤其当你使用过其它数组编程语言，它们非常热衷于拷贝数据。请记住，Numpy是设计用来处理大数据的情况，你可以想象如果Numpy坚持使用拷贝数据将会出现的性能和内存问题。如果你想有数组切片的一个拷贝，你需要明显的拷贝数组；例如 arr[5:8].copy() 。</p>

<p>对于高维数组，你会有更多选项。在两维的数组，每一个索引的元素将不再是一个纯量，而是一个一维数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
arr2d[2]
	## array([7, 8, 9])
</code></pre>
</div>
<p>因此，单个元素可以递归的访问，但是这会做多一点的工作。不过，你可以使用一个逗号分隔的索引列表来选择单个元素。因此，下面的操作是等价的。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[0][2]
	## 3
arr2d[0, 2]
	## 3
</code></pre>
</div>
<p>在多维数组中，如果你省略了后面的索引，返回的对象将会是一个较低维的ndarray，它包括较高维度的所有数据。因此，在 2*\2*3 的数组 arr3d 中</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>arr3d[0] 是一个 2*3 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[0]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>纯量值和数组都可以给 arr3d[0] 赋值。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>old_values = arr3d[0].copy()
arr3d[0] = 42
arr3d
	## array([[[42, 42, 42],
	##         [42, 42, 42]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
arr3d[0] = old_values
arr3d
	## array([[[ 1, 2, 3],
	##         [ 4, 5, 6]],
	##        [[ 7, 8, 9],
	##         [10, 11, 12]]])
</code></pre>
</div>
<p>类似的， arr3d[1, 0] 给出那些索引以 (1, 0) 开始的值，形成了一个1维数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr3d[1, 0]
	## array([7, 8, 9])
</code></pre>
</div>
<p>请注意，在所有的情况下，被选中的子节返回的数组总是数组视窗。
如同一维对象，ndarrys可以使用熟悉的语法来切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[1:6]
	## array([ 1, 2, 3, 4, 64])
</code></pre>
</div>
<p>较高维的对象给你更多的选择，你可以切割一个或多个坐标坐标轴，并且可以混合整数。对上面的2维数组，arr2d ，对它的切片有些不同。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d
	## array([[1, 2, 3],          
	##        [4, 5, 6],                 
	##        [7, 8, 9]])
arr2d[:2]
	## array([[1, 2, 3],
	##        [4, 5, 6]])
</code></pre>
</div>
<p>正如你所见，它沿着0坐标坐标轴（第一个坐标坐标轴）切片。因此，一个切片沿着一个坐标坐标轴向选择一个范围的元素。你可以传递多个切片，就像你传递多个索引一样。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:]
	## array([[2, 3],
	##        [5, 6]])
</code></pre>
</div>
<p>像这样这样切片时，你得到的总是相同维数的数组视窗。通过混合整形索引和切片，你可以得到较低维的切片。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[1, :2] 
	## array([4, 5])
</code></pre>
</div>
<p>注意，一个单一的冒号意味着取整个坐标/坐标轴，因此，你可以只切割更高维的坐标轴，做法如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:, :1]
	## array([[1],
	##        [4],
	##        [7]])
</code></pre>
</div>
<p>当然，给一个切片表达式赋值会对整个选择赋值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr2d[:2, 1:] = 0
</code></pre>
</div>

<h2 id="section-2">布尔索引</h2>
<p>让我们来考虑一个例子，我们有一些数据在一个数组中和一个有重复名字的数组。我将会在这使用 numpy.random 中的 randn 函数来产生一些随机的正态分布的数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import numpy.random as np_rd
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
data = np_rd.randn(7, 4)
names
	## array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'],
	##       dtype='|S4')
data
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>假设每一个名字都和data数组中的一行对应。如果我们想要选择与‘Bob’名字对应的所有行。象算术运算一样，数组的比较操作（例如 == ）也可以矢量化。因此，names和Bob字符窜的比较会产生一个布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names == 'Bob'
	## array([ True, False, False, True, False, False, False], dtype=bool)
</code></pre>
</div>
<p>当索引数组时可以传递这一布尔数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob']
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672]])
</code></pre>
</div>
<p>布尔数组必须和它索引的坐标轴的长度相同。你甚至可以把布尔数组和切片或整数（或者整数序列）混合和匹配起来。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names == 'Bob', 2:]
	## array([[-0.2349, 1.2792],
	##        [-0.0523, 0.0672]])
</code></pre>
</div>
<p>为了选择除了 ‘Bob’ 之外的所有东西，你可以使用 ！= 或用 - 对条件表达式取反：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>names != 'Bob'
	## array([False, True, True, False, True, True, True], dtype=bool)
data[-(names == 'Bob')]
	## array([[-0.268 , 0.5465, 0.0939, -2.0445],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [-1.0023, -0.1698, 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, -0.9297, -1.2564]])
</code></pre>
</div>
<p>使用布尔算术操作符如 &amp; （and） 和 | （or）来结合多个布尔条件，下面是从三个名字中选取两个的操作。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mask = (names == 'Bob') | (names == 'Will')
mask
array([True, False, True, True, True, False, False], dtype=bool)
data[mask]
	## array([[-0.048 , 0.5433, -0.2349, 1.2792],
	##        [-0.047 , -2.026 , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, -0.0523, 0.0672],
	##        [-1.0023, -0.1698, 1.1503, 1.7289]])
</code></pre>
</div>
<p>通过布尔索引从一个数组中选取数据总是会创建数据的一份拷贝，即使是返回的数组没有改变。
为了设置 data 中所有的负值为0，我们只需要。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[data &lt; 0] = 0
data
	## array([[ 0. , 0.5433, 0. , 1.2792],
	##        [ 0. , 0.5465, 0.0939, 0. ],
	##        [ 0. , 0. , 0.7719, 0.3103],
	##        [ 2.1452, 0.8799, 0. , 0.0672],
	##        [ 0. , 0. , 1.1503, 1.7289],
	##        [ 0.1913, 0.4544, 0.4519, 0.5535],
	##        [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>
<p>使用一维布尔数组设置整行或列也非常简单：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>data[names != 'Joe'] = 7
data
array([[ 7. , 7. , 7. , 7. ],
       [ 0. , 0.5465, 0.0939, 0. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 7. , 7. , 7. , 7. ],
       [ 0.1913, 0.4544, 0.4519, 0.5535],
       [ 0.5994, 0.8174, 0. , 0. ]])
</code></pre>
</div>

<h4 id="fancy">Fancy索引</h4>
<p>Fancy索引是一个术语，被Numpy用来描述使用整形数组索引。假如我们有一个 8*4 的数组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.empty((8, 4))
for i in range(8):
    arr[i] = i
arr
	## array([[ 0., 0., 0., 0.],
	##        [ 1., 1., 1., 1.],
	##        [ 2., 2., 2., 2.],
	##        [ 3., 3., 3., 3.],
	##        [ 4., 4., 4., 4.],
	##        [ 5., 5., 5., 5.],
	##        [ 6., 6., 6., 6.],
	##        [ 7., 7., 7., 7.]])
</code></pre>
</div>
<p>为了选出一个有特定顺序行的子集，你可以传递一个列表或整形ndarray来指定想要的顺序。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[4, 3, 0, 6]]
	## array([[ 4., 4., 4., 4.],
	##        [ 3., 3., 3., 3.],
	##        [ 0., 0., 0., 0.],
	##        [ 6., 6., 6., 6.]])
</code></pre>
</div>
<p>很庆幸这个代码做了你所期望的！使用负的索引从结尾选择行。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[-3, -5, -7]]
	## array([[ 5., 5., 5., 5.],
	##        [ 3., 3., 3., 3.],
	##        [ 1., 1., 1., 1.]])
</code></pre>
</div>
<p>传递多个索引数组有些微的不同，它选取一个一维数组，元素对应与索引的每一个元组。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(32).reshape((8, 4))
arr
	## array([[ 0, 1, 2, 3],
	##        [ 4, 5, 6, 7],
	##        [ 8, 9, 10, 11],
	##        [12, 13, 14, 15],
	##        [16, 17, 18, 19],
	##        [20, 21, 22, 23],
	##        [24, 25, 26, 27],
	##        [28, 29, 30, 31]])
arr[[1, 5, 7, 2], [0, 3, 1, 2]]
	## array([ 4, 23, 29, 10])
</code></pre>
</div>
<p>花一点儿时间来看看刚刚发生了什么：元素 (1, 0), (5, 3), (7, 1), 和(2, 2)被选择了。 fancy索引的行为与一些用户可能期望的有所不同，它因该是一个矩形区域，由选取的矩形的行和列组成。这里有一个方法来得到它。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>另一种方法是使用 np.ix_ 函数，将两个以为整形数组转换为位标，来选取一个正方形区域：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]
	## array([[ 4, 7, 5, 6],
	##        [20, 23, 21, 22],
	##        [28, 31, 29, 30],
	##        [ 8, 11, 9, 10]])
</code></pre>
</div>
<p>注意，fancy索引，不像切片，它总是拷贝数据到一个新的数组。
### 转置数组和交换坐标轴
转置是一种特殊形式的变形，类似的它会返回基础数据的一个视窗，而不会拷贝任何东西。数组有 transpose 方法和专门的 T 属性：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(15).reshape((3, 5))
arr                  
	## array([[ 0, 1, 2, 3, 4],               
	##        [ 5, 6, 7, 8, 9],               
	##        [10, 11, 12, 13, 14]])          
arr.T
	## array([[ 0, 5, 10],
	##        [ 1, 6, 11],
	##        [ 2, 7, 12],
	##        [ 3, 8, 13],
	##        [ 4, 9, 14]])
</code></pre>
</div>
<p>当进行矩阵运算时，你常常会这样做，像下面的例子一样，使用 np.dot 计算内部矩阵来产生 XTX` 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.random.randn(6, 3)
np.dot(arr.T, arr)
	## array([[ 2.584 , 1.8753, 0.8888],
	##        [ 1.8753, 6.6636, 0.3884],
	##        [ 0.8888, 0.3884, 3.9781]])
</code></pre>
</div>
<p>对于更高维的数组， transpose 接受用于转置的坐标轴的号码的一个元组（for extra mind bending）：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = np.arange(16).reshape((2, 2, 4))
arr
	## array([[[ 0, 1, 2, 3],
	##         [ 4, 5, 6, 7]],
	##        [[ 8, 9, 10, 11],
	##         [12, 13, 14, 15]]])
arr.transpose((1, 0, 2))
	## array([[[ 0, 1, 2, 3],
	##         [ 8, 9, 10, 11]],
	##        [[ 4, 5, 6, 7],
	##         [12, 13, 14, 15]]])
</code></pre>
</div>
<p>使用 .T 的转置，仅仅是交换坐标轴的一个特殊的情况。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr                            			                   
	## array([[[ 0, 1, 2, 3],            
	##         [ 4, 5, 6, 7]],                                     
	##        [[ 8, 9, 10, 11],          
	##         [12, 13, 14, 15]]])                                      
arr.swapaxes(1, 2)          
    ## array([[[ 0, 4],
    ##         [ 1, 5],
    ##         [ 2, 6],
    ##         [ 3, 7]],
    ##        [[ 8, 12],
    ##        [ 9, 13],
    ##        [10, 14],
    ##        [11, 15]]])
</code></pre>
</div>
<p>类似的 swapaxes 返回在数据上的一个视窗，而不进行拷贝。</p>

<h3 id="section-3">通用函数：快速的基于元素的数组函数</h3>
<p>一个通用的函数，是一个在ndarrays的数据上进行基于元素的操作的函数。你可以认为它们是对简单函数的一个快速矢量化封装，它们接受一个或多个标量值并产生一个或多个标量值。
许多 ufuncs 都是基于元素的简单变换，像 sqrt 或 exp 。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Iarr = np.arange(10)
Inp.sqrt(arr)
	## array([ 0. , 1. , 1.4142, 1.7321, 2. , 2.2361, 2.4495,
	##         2.6458, 2.8284, 3. ])
np.exp(arr)
	## array([ 1. , 2.7183, 7.3891, 20.0855, 54.5982,
	##        148.4132, 403.4288, 1096.6332, 2980.958 , 8103.0839])
</code></pre>
</div>
<p>这些归诸于unary ufuncs。其它的，例如add或maximum ，接受两个数组(因此，叫做binary ufuncs)且返回一个数组：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x = randn(8)
y = randn(8)
x
	## array([ 0.0749, 0.0974, 0.2002, -0.2551, 0.4655, 0.9222, 0.446 ,
	##        -0.9337])
y
	## array([ 0.267 , -1.1131, -0.3361, 0.6117, -1.2323, 0.4788, 0.4315,
	##        -0.7147])
np.maximum(x, y) # element-wise maximum
	## array([ 0.267 , 0.0974, 0.2002, 0.6117, 0.4655, 0.9222, 0.446 ,
	##        -0.7147])
</code></pre>
</div>
<p>虽然不常见，一个ufunc可以返回多个数组。 nodf 就是一个例子，它是python内建 divmod 的矢量化的版本：它返回一个 浮点数数组的分数和整数部分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>arr = randn(7) * 5
np.modf(arr)
	##(array([-0.6808, 0.0636, -0.386 , 0.1393, -0.8806, 0.9363, -0.883 ]),
	## array([-2., 4., -3., 5., -3., 3., -6.]))
</code></pre>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>实用的R函数</title>
      <link>http://xukuang.github.io/blog/2016/04/dots-in-r/</link>
      <pubDate>2016-04-21T09:46:58-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/dots-in-r</guid>
      <content:encoded><![CDATA[<p>这篇文章记录的是在使用R的过程中偶然遇到的非常实用的函数，然而由于这些函数在自己的学习中太常用特别容易忘记，所以这里记下来以便以后使用的时候可以查看。学无止境，长期更新。</p>

<h2 id="section">场景一</h2>
<p>在查看多个变量之间的两两相关性的时候，可以使用picante包中的cor.table()函数。</p>

<h2 id="section-1">场景二</h2>
<p>在R中加载了多个R包时，希望查看当前环境中都加载了哪些R包的find.package()函数，临时卸载某个R包可以使用函数detach(package:包名)。如要卸载dplyr包，则为detach(package:dplyr)。</p>

<h2 id="section-2">场景三</h2>
<p>expand.grid()用来建立一些factor相乘出来的矩阵或data.frame。<!--more--></p>

<div class="highlighter-rouge"><pre class="highlight"><code>expand.grid(x = c('A', 'B', 'C', 'D'), y = 1:3)
	#    x y
	# 1  A 1
	# 2  B 1
	# 3  C 1
	# 4  D 1
	# 5  A 2
	# 6  B 2
	# 7  C 2
	# 8  D 2
	# 9  A 3
	# 10 B 3
	# 11 C 3
	# 12 D 3
</code></pre>
</div>

<h2 id="section-3">场景四</h2>
<p>使用with()和within()函数对数据框列引用时，可以不用再输入长长的数据框名了。两者的区别在于，with只是生成了一列数据，而within生成一个包含原始数据的数据框。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>with(dat, y + 2)
	# [1] 4 5 6 7
within(dat, {z = y + 2; a = x + 3})
	#   x y a z
	# 1 1 2 4 4
	# 2 2 3 5 5
	# 3 3 4 6 6
	# 4 4 5 7 7
</code></pre>
</div>

<h2 id="section-4">场景五</h2>
<p>cut()函数可以把连续变量离散化，即numeric型的数据转换成factor型，可以与table()函数一起使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(x, breaks, labels = NULL,
    include.lowest = FALSE, right = TRUE, dig.lab = 3,
    ordered_result = FALSE, ...)
</code></pre>
</div>

<p><strong>主要参数</strong></p>

<p>x: 需要离散化的连续型向量</p>

<p>breaks: 向量类型，指定分类指标。默认的情况下，左开右闭合，这里可以结合正无穷(+Inf)和负无穷使用</p>

<p>labels：向量类型，指定分类指标的名称。如果不限定，则默认用分类指标为名称</p>

<p>inlude.lowest: 逻辑类型，指定边界是否闭合，默认的是边界不闭合</p>

<p>right: 逻辑类型，指定左开右闭合还是右开左闭合，默认的是TURE，左开右闭合</p>

<p>dig.lab: 数字，指定分类指标名称的数字位数。默认情况下，当labels为NULL时，指标名称的数字只显示3位</p>

<p>orederd_result: 逻辑类型，指定分类指标是否有序</p>

<div class="highlighter-rouge"><pre class="highlight"><code>cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf))
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] (2.22,5] (5,Inf]

## 边界闭合，即包含左端的1
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), include.lowest = T)
	#  [1] [1,2.22] (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  [1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] [1,2.22] (5,Inf] 
	# Levels: [1,2.22] (2.22,5] (5,Inf]

## 左闭合右开
cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), right = F)
	#  [1] [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [5,Inf)  [1,2.22) [2.22,5) [5,Inf)  [5,Inf)  [2.22,5) [1,2.22) [5,Inf) 
	# Levels: [1,2.22) [2.22,5) [5,Inf)

## 指定分类名称
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), labels = c('small', 'middle', 'big'))
	#  [1] &lt;NA&gt;   middle middle big    big    small  middle big    big    middle &lt;NA&gt;   big   
	# Levels: small middle big

## 分类指标有序
 cut(c(1,4, 5, 7, 9, 2, 4, 6, 8, 3, 1,7), breaks = c(1, 2.224, 5, Inf), ordered_result = T)
	#  [1] &lt;NA&gt;     (2.22,5] (2.22,5] (5,Inf]  (5,Inf]  (1,2.22] (2.22,5] (5,Inf]  (5,Inf]  (2.22,5] &lt;NA&gt;     (5,Inf] 
	# Levels: (1,2.22] &lt; (2.22,5] &lt; (5,Inf]
</code></pre>
</div>

<h2 id="section-5">场景六</h2>
<p>求导数的函数。dxy=deriv(f~x^2+y^2,c(‘x’,’y’),func=T)</p>

<h2 id="section-6">场景七</h2>
<p>split()函数能将数据框按某一列分为包含若干个数据框的列表。然后，unsplit()可以将这个列表合并。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>data.table的包的简单介绍</title>
      <link>http://xukuang.github.io/blog/2016/04/data-table-in-R/</link>
      <pubDate>2016-04-13T07:56:01-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-table-in-R</guid>
      <content:encoded><![CDATA[<p>相比dplyr包，data.table包能够更大程度地提高数据的处理速度，这里就简单介绍一下data.tale包的使用方法。</p>

<h2 id="section">数据的读取</h2>
<p>data.table包中数据读取的函数是fread()。</p>

<h2 id="datatable-">data.table 的创建</h2>

<div class="highlighter-rouge"><pre class="highlight"><code>library(data.table)
DT = data.table(x=rep(c("a","b","c"),each=3), y=c(1,3,6), v=1:9)
DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
</code></pre>
</div>
<!--more-->

<h2 id="section-1">基础操作</h2>

<h3 id="section-2">行提取</h3>
<p>行提取分为单行提取和多行提取。</p>

<h4 id="section-3">单行提取</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2]                      # 2nd row
	#    x y v
	# 1: a 3 2
DT[2,]                     # same
	#    x y v
	# 1: a 3 2
</code></pre>
</div>
<p>这里DT[2]和DT[2,]是完全相同的，这里的『,』只是说明还有其他参数可设置，而其他参数按默认值进行计算。下文所有这样的最后一个『,』都不再写出来。</p>

<h4 id="section-4">多行提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[1:2]
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
DT[c(2,5)]
	#   x y v
	#1: a 3 2
	#2: b 3 5
</code></pre>
</div>

<ul>
  <li>逻辑提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[c(FALSE,TRUE)]          # even rows (usual recycling)
	#    x y v
	# 1: a 3 2
	# 2: b 1 4
	# 3: b 6 6
	# 4: c 3 8
</code></pre>
</div>

<p>此时,c(FALSE,TRUE)会自己重复匹配成与DT的行数相同的向量</p>

<h3 id="section-5">列提取</h3>
<p>与行提取相同，列的提取也包含单列提取和多列提取。</p>

<h4 id="section-6">单列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>数字提取时，一定要把wth参数设置为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2,with=FALSE]          # 2nd column
	#    y
	# 1: 1
	# 2: 3
	# 3: 6
	# 4: 1
	# 5: 3
	# 6: 6
	# 7: 1
	# 8: 3
	# 9: 6
</code></pre>
</div>

<ul>
  <li>列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(v)]               # v column (as data.table
	#    v
	# 1: 1
	# 2: 2
	# 3: 3
	# 4: 4
	# 5: 5
	# 6: 6
	# 7: 7
	# 8: 8
	# 9: 9
</code></pre>
</div>

<h3 id="section-7">列名的修改</h3>
<p>列名的修改可以使用setnames()函数，这个函数好像比对data.frame类型数据名更改的names()和colnames()函数也要快一些。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dt = data.table(a=1:2,b=3:4,c=5:6) # compare to data.table
try(tracemem(dt))                  # by reference, no deep or shallow copies
setnames(dt,"b","B")               # by name, no match() needed (warning if "b" is missing)
setnames(dt,3,"C")                 # by position with warning if 3 &gt; ncol(dt)
setnames(dt,2:3,c("D","E"))        # multiple
setnames(dt,c("a","E"),c("A","F")) # multiple by name (warning if either "a" or "E" is missing)
setnames(dt,c("X","Y","Z"))        # replace all (length of names must be == ncol(DT))  
</code></pre>
</div>

<h4 id="section-8">多列提取</h4>

<ul>
  <li>数字提取</li>
</ul>

<p>如同上面对按数字对单列的提取，对多列提取也要设置with参数为FALSE。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,2:3,with=FALSE]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
DT[,c(1,3),with=FALSE] 
	#    x v
	# 1: a 1
	# 2: a 2
	# 3: a 3
	# 4: b 4
	# 5: b 5
	# 6: b 6
	# 7: c 7
	# 8: c 8
	# 9: c 9      
</code></pre>
</div>

<ul>
  <li>按列名提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(y, v)]
	#    y v
	# 1: 1 1
	# 2: 3 2
	# 3: 6 3
	# 4: 1 4
	# 5: 3 5
	# 6: 6 6
	# 7: 1 7
	# 8: 3 8
	# 9: 6 9
</code></pre>
</div>

<p>如果按列名提取时，不使用列表，仍然能对列进行提取，只是结果以向量的形式输出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,v]                     # v column (as vector)
	# [1] 1 2 3 4 5 6 7 8 9
DT[,c(v)]                  # same
	# [1] 1 2 3 4 5 6 7 8 9   
DT[, c(y, v)]
	# [1] 1 3 6 1 3 6 1 3 6 1 2 3 4 5 6 7 8 9
</code></pre>
</div>

<h3 id="section-9">列的添加与删除</h3>

<h4 id="section-10">列的添加</h4>

<ul>
  <li>单列添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT
	#    x y v
	# 1: a 1 1
	# 2: a 3 2
	# 3: a 6 3
	# 4: b 1 4
	# 5: b 3 5
	# 6: b 6 6
	# 7: c 1 7
	# 8: c 3 8
	# 9: c 6 9
DT[, a := 'k']
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
DT[,c:=8]        # add a numeric column, 8 for all rows
DT
	#    x y v a c
	# 1: a 1 1 k 8
	# 2: a 3 2 k 8
	# 3: a 6 3 k 8
	# 4: b 1 4 k 8
	# 5: b 3 5 k 8
	# 6: b 6 6 k 8
	# 7: c 1 7 k 8
	# 8: c 3 8 k 8
	# 9: c 6 9 k 8 
DT[,d:=9L]       # add an integer column, 9L for all rows
DT[2,d:=10L]     # subassign by reference to column d
DT
	#    x y v a c  d
	# 1: a 1 1 k 8  9
	# 2: a 3 2 k 8 10
	# 3: a 6 3 k 8  9
	# 4: b 1 4 k 8  9
	# 5: b 3 5 k 8  9
	# 6: b 6 6 k 8  9
	# 7: c 1 7 k 8  9
	# 8: c 3 8 k 8  9
	# 9: c 6 9 k 8  9
DT[, e := d + 2]
DT
	#    x y v a c  d  e
	# 1: a 1 1 k 8  9 11
	# 2: a 3 2 k 8 10 12
	# 3: a 6 3 k 8  9 11
	# 4: b 1 4 k 8  9 11
	# 5: b 3 5 k 8  9 11
	# 6: b 6 6 k 8  9 11
	# 7: c 1 7 k 8  9 11
	# 8: c 3 8 k 8  9 11
	# 9: c 6 9 k 8  9 11
</code></pre>
</div>
<p>如果添加的列名，数据中已经包含则是对这一列数据的修改。</p>

<ul>
  <li>多列的添加</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[, c('f', 'g') := list( d + 1, c)]
DT[, ':='( f =  d + 1, g = c)]          # same
DT
	#    x y v a c  d  e  f g
	# 1: a 1 1 k 8  9 11 10 8
	# 2: a 3 2 k 8 10 12 11 8
	# 3: a 6 3 k 8  9 11 10 8
	# 4: b 1 4 k 8  9 11 10 8
	# 5: b 3 5 k 8  9 11 10 8
	# 6: b 6 6 k 8  9 11 10 8
	# 7: c 1 7 k 8  9 11 10 8
	# 8: c 3 8 k 8  9 11 10 8
	# 9: c 6 9 k 8  9 11 10 8
</code></pre>
</div>
<p>此处，需要注意的是新创建的列只能依照原有数据列，而不能依照新创建的列。例如这个例子中，g = c是可以运行，而g = f则会提示错误。</p>

<h4 id="section-11">列的删除</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c:=NULL]     # remove column c
DT
	#    x y v a  d  e  f g
	# 1: a 1 1 k  9 11 10 8
	# 2: a 3 2 k 10 12 11 8
	# 3: a 6 3 k  9 11 10 8
	# 4: b 1 4 k  9 11 10 8
	# 5: b 3 5 k  9 11 10 8
	# 6: b 6 6 k  9 11 10 8
	# 7: c 1 7 k  9 11 10 8
	# 8: c 3 8 k  9 11 10 8
	# 9: c 6 9 k  9 11 10 8
DT[, c('d', 'e', 'f', 'g'):=NULL]     
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h2 id="section-12">列指标的简单操作</h2>
<p>简单操作主要包括求和、平均值、方差和标准差等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[2:3,sum(v)]             # sum(v) over rows 2 and 3
# [1] 5
DT[2:3,mean(v)]             # sum(v) over rows 2 and 3
# [1] 2.5
</code></pre>
</div>

<h2 id="key">索引key</h2>

<h3 id="section-13">查看和创建索引</h3>
<p>索引是对列而言的，索引创建后，数据将自动按索引值进行重新排序，所以每个数据最多只能有一个索引，但是索引可以由多列组成，这些列可以是数字、因子、字符串或其他格式。</p>

<h4 id="section-14">单列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>
## methdod first
key(DT)                    # key
	# NULL 
setkey(DT,x)               # set a 1-column key. No quotes, for convenience.
key(DT)
[1] "x"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k

## method second
setkeyv(DT,"y")            # same (v in setkeyv stands for vector)
key(DT)
	# [1] "y"
</code></pre>
</div>
<p>一旦对数据进行新的索引，原有的索引将消失。</p>

<h4 id="section-15">多列索引的创建</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## methdod first                    # key 
setkey(DT,x,v)               # set a 1-column key. No quotes, for convenience.
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k


## method second
setkeyv(DT,c("x", "y"))           # same (v in setkeyv stands for vector)
key(DT)
	# [1] "x" "v"
DT
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 3 5 k
	# 6: b 6 6 k
	# 7: c 1 7 k
	# 8: c 3 8 k
	# 9: c 6 9 k
</code></pre>
</div>

<h3 id="section-16">通过索引进行数据的提取</h3>
<p>按照索引对数据提取，可以加快提取数据的速度。</p>

<h4 id="section-17">单索引</h4>
<p>正向提取</p>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x)
DT["a"]                    # binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.(x=="a")]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[x=="a"]                 # same; i.e. binary search (fast)
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[!.("a")]                # not join
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!"a"]                   # same
	#    x y v a
	# 1: b 1 4 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k
DT[!2:4]                   # all rows other than 2:4
	#    x y v a
	# 1: a 1 1 k
	# 2: b 3 5 k
	# 3: b 6 6 k
	# 4: c 1 7 k
	# 5: c 3 8 k
	# 6: c 6 9 k

</code></pre>
</div>

<h4 id="section-18">多索引</h4>

<ul>
  <li>正向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>setkey(DT, x, y)
# Mehtod First
DT["a"]                    # join to 1st column of key
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a")]                 # same, .() is an alias for list()
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[.("a",3)]               # join to 2 columns
    #    x y v a
	# 1: a 3 2 k
DT[.("a",3:6)]             # join 4 rows (2 missing)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[.("a",3:6),nomatch=0]   # remove missing
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[.("a",3:6),roll=TRUE]   # rolling join (locf)
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k

## Method Second
DT[J('a')]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[J("a",3)]               # binary search (fast)
	#    x y v a
	# 1: a 3 2 k
DT[J("a",3:6)]              # same; i.e. binary search (fast)
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[J("a",3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[J("a",3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k


## Method Third
DT[list("a")]
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
DT[list("a",3)]
    #    x y v a
	# 1: a 3 2 k
DT[list("a", 3:6)]
	#    x y  v  a
	# 1: a 3  2  k
	# 2: a 4 NA NA
	# 3: a 5 NA NA
	# 4: a 6  3  k
DT[list("a", 3:6), nomatch = 0]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 6 3 k
DT[list("a", 3:6), roll = T]
	#    x y v a
	# 1: a 3 2 k
	# 2: a 4 2 k
	# 3: a 5 2 k
	# 4: a 6 3 k
</code></pre>
</div>

<ul>
  <li>反向提取</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[x!="b" | y!=3]          # not yet optimized, currently vector scans
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k
DT[!.("b",3)]              # same result but much faster
	#    x y v a
	# 1: a 1 1 k
	# 2: a 3 2 k
	# 3: a 6 3 k
	# 4: b 1 4 k
	# 5: b 6 6 k
	# 6: c 1 7 k
	# 7: c 3 8 k
	# 8: c 6 9 k

</code></pre>
</div>

<h2 id="section-19">分类汇总</h2>
<p>分类汇总是指按某列的分类指标进行简单操作，这里借助by参数实现。此外，by参数与索引相互没有影响。</p>

<h3 id="section-20">单指标的分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum(v),by=x]
	#    x V1
	# 1: a  6
	# 2: b 15
	# 3: c 24           
DT[,sum(v),by=y] 
	#    y V1
	# 1: 1 12
	# 2: 3 15
	# 3: 6 18          
</code></pre>
</div>
<ul>
  <li>
    <p>自定义汇总名称
<code class="highlighter-rouge">
DT[,list(sum.v.x = sum(v)),by=x]
  #    x sum.v.x
  # 1: a       6
  # 2: b      15
  # 3: c      24           
DT[,list(sum.v.y = sum(v)),by=y] 
  #    y sum.v.y
  # 1: 1      12
  # 2: 3      15
  # 3: 6      18 
DT[,sum.v.y := sum(v) ,by=y]
  #    x y v a sum.v.y
  # 1: a 1 1 k      12
  # 2: a 3 2 k      15
  # 3: a 6 3 k      18
  # 4: b 1 4 k      12
  # 5: b 3 5 k      15
  # 6: b 6 6 k      18
  # 7: c 1 7 k      12
  # 8: c 3 8 k      15
  # 9: c 6 9 k      18 	
</code></p>
  </li>
  <li>
    <p>汇总结果与原始数据进行匹配</p>
  </li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,sum.v.y := sum(v) ,by=y]
	#    x y v a sum.v.y
	# 1: a 1 1 k      12
	# 2: a 3 2 k      15
	# 3: a 6 3 k      18
	# 4: b 1 4 k      12
	# 5: b 3 5 k      15
	# 6: b 6 6 k      18
	# 7: c 1 7 k      12
	# 8: c 3 8 k      15
	# 9: c 6 9 k      18
</code></pre>
</div>

<h3 id="section-21">多指标的多个分类汇总</h3>

<ul>
  <li>默认汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean(v),sum(v)),by=list(x,y)]   # keyed by
	#    x y V1 V2
	# 1: a 1  1  1
	# 2: a 3  2  2
	# 3: a 6  3  3
	# 4: b 1  4  4
	# 5: b 3  5  5
	# 6: b 6  6  6
	# 7: c 1  7  7
	# 8: c 3  8  8
	# 9: c 6  9  9
</code></pre>
</div>

<ul>
  <li>自定义汇总名称</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,list(mean.v = mean(v),sum.v = sum(v)),by=list(x,y)]   # keyed by
	#   x y mean.v sum.v
	#1: a 1      1     1
	#2: a 3      2     2
	#3: a 6      3     3
	#4: b 1      4     4
	#5: b 3      5     5
	#6: b 6      6     6
	#7: c 1      7     7
	#8: c 3      8     8
	#9: c 6      9     9
</code></pre>
</div>

<ul>
  <li>汇总结果与原始数据进行匹配</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>DT[,c("mean.v", "sum.v.y") := list(mean(v),sum(v)) ,by=list(x,y)]
	#    x y v a sum.v.y mean.v
	# 1: a 1 1 k       1      1
	# 2: a 3 2 k       2      2
	# 3: a 6 3 k       3      3
	# 4: b 1 4 k       4      4
	# 5: b 3 5 k       5      5
	# 6: b 6 6 k       6      6
	# 7: c 1 7 k       7      7
	# 8: c 3 8 k       8      8
	# 9: c 6 9 k       9      9

</code></pre>
</div>

<h2 id="datatabledataframe">data.table与data.frame的转化</h2>
<p>data.table格式加快了处理速度，而data.frame则更为基础。两者的转化可以通过data.table(),setDT()和setDT()来实现，其中data.table()和setDT()函数可以将数据从data.frame转化为data.table，setDF()函数可以将数据从data.table转化为data.frame。注意使用data.table(),setDT()和setDT()时，参数本身的数据类型也会发生变化。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class(DT)
	# [1] "data.table" "data.frame"  
class(setDF(DT))
	# [1] "data.frame"
class(DT)
	# [1] "data.frame"
</code></pre>
</div>
<p>此外，data.table包还可以与基础包中的duplicated()、unique()、subset() 函数结合使用。 不仅如此，data.table包还有一些基础包的替代函数。rbind()升级版的rbindlist()，可以合并列数不同和列位置不同的数据。比dplyr包中arrange()函数更快的setorder()排序函数。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>长宽数据之间的转化(二)</title>
      <link>http://xukuang.github.io/blog/2016/04/data-fomrat/</link>
      <pubDate>2016-04-10T04:32:19-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/data-fomrat</guid>
      <content:encoded><![CDATA[<p>前面一篇<a href="http://xukuang.github.io/2016/01/18/melt-and-dcast/">文章</a>讲了用reshape2包中的函数实现长宽数据的转化，而tidyr是reshape2的升级版，主要用于数据框。这篇文章将介绍一下如何使用tidyr包中的函数实现长宽数据的转化。</p>

<h2 id="section">1. 宽数据转化为长数据</h2>

<h3 id="gather">gather函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>gather(data, key, value, ..., na.rm = FALSE, convert = FALSE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定转化后数据框的指标列的列名，用于存放原数据中不同的数据指标</p>

<p><strong>value</strong>  指定转化后数据框的数据列的列名，用于存放原数据中不同的数据指标对应的值</p>

<p><strong>…</strong> 指定哪些列聚到一列中。按那些列数据作为标准转化，这个参数接不能有那些列</p>

<p><strong>na.rm</strong> 确定是否去除数据中的NA，默认情况下为FALSE，不去除NA
<!--more--></p>

<h3 id="section-1">实例</h3>

<ul>
  <li>将所有列排成长数据(默认情况下)</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 加载数据
library(reshape2)
head(airquality)
	# 	Month Day variable value
	# 1     5   1    Ozone    41
	# 2     5   2    Ozone    36
	# 3     5   3    Ozone    12
	# 4     5   4    Ozone    18
	# 5     5   5    Ozone    NA
	# 6     5   6    Ozone    28
dim(airquality)
	# [1] 612   4
library(tidyr)
dat1 = gather(airquality, time, value)
head(dat1)
    #    time value
    # 1 Ozone    41
    # 2 Ozone    36
    # 3 Ozone    12
    # 4 Ozone    18
    # 5 Ozone    NA
    # 6 Ozone    28
tail(dat1)
    #         time value
    # 913  Day    25
    # 914  Day    26
    # 915  Day    27
    # 916  Day    28
    # 917  Day    29
    # 918  Day    30
dim(dat1)	
	# [1] 918   2
</code></pre>
</div>

<ul>
  <li>按Month将其他指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 方法一
dat2 = gather(airquality, time, value, Ozone:Temp, Day)
# 方法二
dat2 = gather(airquality, time, value, -Month)
head(dat2)
	#    Month Day  time value
	# 1     5   1 Ozone    41
	# 2     5   2 Ozone    36
	# 3     5   3 Ozone    12
	# 4     5   4 Ozone    18
	# 5     5   5 Ozone    NA
	# 6     5   6 Ozone    28
tail(dat2)
	#     Month Day time value
	# 607     9  25 Temp    63
	# 608     9  26 Temp    70
	# 609     9  27 Temp    77
	# 610     9  28 Temp    75
	# 611     9  29 Temp    76
	# 612     9  30 Temp    68
</code></pre>
</div>

<ul>
  <li>按Month和Day列将其它列指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dat3 = gather(airquality, type, value.type, Ozone:Temp)
dat3 = gather(airquality, type, value.type, -Month, -Day)
head(dat3) 
	# 	 Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 5     5   5 Ozone         NA
	# 6     5   6 Ozone         28
dim(dat3)
	# [1] 612   4
</code></pre>
</div>

<ul>
  <li>去除排列后数据中的NA</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>#　 airquality$Ozone 数的前四列有44 个NA
table(is.na(airquality$Ozone)) # 37
	# FALSE  TRUE 
	#   116    37 
table(is.na(airquality$Solar.R)) # 4
	# FALSE  TRUE 
	#   146     7 
table(is.na(airquality$Temp)) # 0
	# FALSE 
	#   153 
table(is.na(airquality$Wind)) # 0
	# FALSE 
	#   153 
dat4 = gather(airquality, type, value.type, Ozone:Temp, na.rm = TRUE)
head(dat4)
	#   Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 6     5   6 Ozone         28
	# 7     5   7 Ozone         23
dim(dat4)# 比dat3少44行
	# [1] 568   4	
</code></pre>
</div>

<h2 id="section-2">2. 长数据转化为宽数据</h2>

<h3 id="spread">spread函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>spread(data, key, value, fill = NA, convert = FALSE, drop = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>key</strong>  指定需要将变量值拓展为字段的变量</p>

<p><strong>value</strong>  指定要分散的值</p>

<p><strong>fill</strong> 确认不存在的组合值的显示结果。默认的显示为NA。数据类型为数值型向量</p>

<p><strong>drop</strong> 确认不存在分分类组合是否显示，默认情况下显示。当然，如果drop = T，那么fill参数的设置将失去意义</p>

<h3 id="section-3">实例</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">air1</span> <span class="o">=</span>  <span class="n">spread</span><span class="p">(</span><span class="n">dat4</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">value.type</span><span class="p">)</span>
<span class="n">dim</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span>
	<span class="c1"># [1] 153   6
</span><span class="n">head</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span> <span class="c1"># 数据与airquality相同
</span>	<span class="c1"># 	Month Day Ozone Solar.R Wind Temp
</span>	<span class="c1"># 1     5   1    41     190  7.4   67
</span>	<span class="c1"># 2     5   2    36     118  8.0   72
</span>	<span class="c1"># 3     5   3    12     149 12.6   74
</span>	<span class="c1"># 4     5   4    18     313 11.5   62
</span>	<span class="c1"># 5     5   5    NA      NA 14.3   56
</span>	<span class="c1"># 6     5   6    28      NA 14.9   66
</span></code></pre>
</div>

<p>不存在的分类是否显示，以及怎么显示</p>

<div class="highlighter-rouge"><pre class="highlight"><code>air5 = spread(dat4, type, value.type, drop = F) # 组合上存在的结果都显示
tail(air5) # 这里的最后一行只是组合上存在，原数据中并不在
	# 		 Month Day Ozone Solar.R Wind Temp
	# 150      9  26     1       1    1    1
	# 151      9  27     1       1    1    1
	# 152      9  28     1       1    1    1
	# 153      9  29     1       1    1    1
	# 154      9  30     1       1    1    1
	# 155      9  31     0       0    0    0
tail(spread(dat4, type, value.type, drop = F, fill= -1)) # 更改不存在结果的显示值，最后一行显示为-1
	# 		Month Day Ozone Solar.R Wind Temp
	# 150     9  26     1       1    1    1
	# 151     9  27     1       1    1    1
	# 152     9  28     1       1    1    1
	# 153     9  29     1       1    1    1
	# 154     9  30     1       1    1    1
	# 155     9  31    -1      -1   -1   -1
</code></pre>
</div>

<h2 id="tidyr">tidyr包中的其它函数</h2>

<h3 id="seperate">seperate函数</h3>

<p>unite()函数可将多列合并为一列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>unite(data, col, ..., sep = "_", remove = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 被组合的新列名称</p>

<p><strong>…</strong> 指定哪些列需要被组合</p>

<p><strong>sep</strong> 组合列之间的连接符，默认为下划线</p>

<p><strong>remove</strong> 是否删除被组合的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>set.seed(10)
date &lt;- as.Date('2016-04-10') + 0:14
hour &lt;- sample(1:24, 15)
min &lt;- sample(1:60, 15)
second &lt;- sample(1:60, 15)
event &lt;- sample(letters, 15)
data &lt;- data.frame(date, hour, min, second, event)
data
	# 			date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n

dataNew &lt;- data %&gt;%
  unite(datehour, date, hour, sep = ' ') %&gt;%
  unite(datetime, datehour, min, second, sep = ':')
	#              datetime event
	#1  2016-04-10 13:26:33     e
	#2     2016-04-11 8:4:6     a
	#3  2016-04-12 10:16:10     l
	#4  2016-04-13 15:23:52     c
	#5   2016-04-14 2:47:24     r
	#6   2016-04-15 5:48:42     h
	#7  2016-04-16 19:34:45     s
	#8  2016-04-17 18:42:51     z
	#9  2016-04-18 22:19:36     i
	#10  2016-04-19 7:21:26     d
	#11 2016-04-20 16:36:14     j
	#12 2016-04-21 23:53:12     g
	#13  2016-04-22 20:12:1     o
	#14 2016-04-23 21:37:35     f
	#15  2016-04-24 4:17:49     n

</code></pre>
</div>
<p>tidyr包中的函数也可使用管道操作符%&gt;%。</p>

<h3 id="seperate-1">seperate函数</h3>
<p>separate()函数可将一列拆分为多列，一般可用于日志数据或日期时间型数据的拆分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>separate(data, col, into, sep = "[^[:alnum:]]+", remove = TRUE,
  convert = FALSE, extra = "warn", fill = "warn", ...)
</code></pre>
</div>

<p><strong>data</strong> 要处理的数据框</p>

<p><strong>col</strong> 需要被拆分的列</p>

<p><strong>into</strong> 新建的列名，为字符串向量</p>

<p><strong>sep</strong> 被拆分列的分隔符</p>

<p><strong>remove</strong> 是否删除被分割的列，默认删除</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dataold &lt;- dataNew %&gt;% 
  separate(datetime, c('date', 'time'), sep = ' ') %&gt;% 
  separate(time, c('hour', 'min', 'second'), sep = ':')
dataold
	# 		date hour min second event
	# 1  2016-04-10   13  26     33     e
	# 2  2016-04-11    8   4      6     a
	# 3  2016-04-12   10  16     10     l
	# 4  2016-04-13   15  23     52     c
	# 5  2016-04-14    2  47     24     r
	# 6  2016-04-15    5  48     42     h
	# 7  2016-04-16   19  34     45     s
	# 8  2016-04-17   18  42     51     z
	# 9  2016-04-18   22  19     36     i
	# 10 2016-04-19    7  21     26     d
	# 11 2016-04-20   16  36     14     j
	# 12 2016-04-21   23  53     12     g
	# 13 2016-04-22   20  12      1     o
	# 14 2016-04-23   21  37     35     f
	# 15 2016-04-24    4  17     49     n
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>简单线性回归中各指标在R中的计算</title>
      <link>http://xukuang.github.io/blog/2016/04/simple-linear-regression/</link>
      <pubDate>2016-04-07T08:50:50-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/simple-linear-regression</guid>
      <content:encoded><![CDATA[<h2 id="section">前话</h2>
<p>简单线性回归用于计算两个连续型变量(如X，Y)之间的线性关系，具体地说就是计算下面公式中的<script type="math/tex">\alpha和\beta</script>。</p>

<script type="math/tex; mode=display">Y = \alpha + \beta X + \varepsilon</script>

<p>其中<script type="math/tex">\varepsilon</script>称为残差,服从从<script type="math/tex">N(0,\sigma^2)</script>的正态分布，自由度为(n-1) - (2-1) = n-2
为了找到这条直线的位置，我们使用最小二乘法(least squares approach)。最小二乘法确保所有点处的残差的平方和最小时计算<script type="math/tex">\alpha和\beta</script>，即下面示意图中<script type="math/tex">\sum_{i=1}^{4}\varepsilon_i^2 = \varepsilon_1^2 + \varepsilon_2^2 + \varepsilon_3^2 + \varepsilon_4^2</script>有最小值。</p>

<p><img src="http://xukuang.github.io/blog/images/y_x_scatter_plot.png" alt="简单线性相关示意图" /><!--more--></p>

<h2 id="section-1">各指标的计算</h2>

<p>运用最小二乘法找出的这条最优直线一定经过点<script type="math/tex">(\overline{x}, \overline{y})</script>。其中</p>

<h3 id="betaalpha">斜率<script type="math/tex">\beta</script>和截距<script type="math/tex">\alpha</script>的估计值</h3>

<p><img src="http://xukuang.github.io/blog/images/beta.png" alt="" /></p>

<h3 id="pearsonr">Pearson相关系数r</h3>

<script type="math/tex; mode=display">r_{xy} = \frac{\overline{xy} - \bar{x}\bar{y} }{ \sqrt{ \left(\overline{x^2} - \bar{x}^2\right)\left(\overline{y^2} - \bar{y}^2\right)}}</script>

<h3 id="section-2">方差分析</h3>
<p>在方差分析(ANOVA)中，总的平方和包含回归平方和残差平方和两部分。</p>

<ul>
  <li>总的平方和</li>
</ul>

<p><script type="math/tex">SS_{tot}=\sum_i (y_i-\bar{y})^2</script>
其自由度为 n - 1，这里n为观测点的个数。</p>

<ul>
  <li>回归的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{reg}=\sum_i (\hat y_i -\bar{y})^2</script>
其自由度为 2 - 1 = 1。</p>

<ul>
  <li>残差的平方和</li>
</ul>

<p><script type="math/tex">SS_\text{res}=\sum_i (y_i - \hat y_i)^2=\sum_i e_i^2</script>
其自由度为 (n -1) - (2 - 1) = n -2。</p>

<h3 id="section-3">决定系数(拟合优势度)</h3>

<p><img src="http://xukuang.github.io/blog/images/error.png" alt="" />
决定系数是用来表示模型的解释度，理论上与相关系数没有关系，只是在简单线性回归中，决定系数$R^2 $值等于Pearson相关系数r的平方。</p>

<h2 id="r">R中的实现</h2>

<h3 id="section-4">线性模拟</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>x = c(0.10, 0.11, 0.12, 0.13, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.23)
y = c(42.0, 43.5, 45.0, 45.5, 45.0, 47.5, 49.0, 53.0, 50.0, 55.0, 55.0, 60.0)
fit = lm(y ~ x)
summary(fit)
	## Call:
	## lm(formula = y ~ x)
	## 
	## Residuals:
	##	 #Min      1Q  Median      3Q     Max 
	## -2.0431 -0.7056  0.1694  0.6633  2.2653 
	## 
	## Coefficients:
	## 				#Estimate Std. Error t value Pr(&gt;|t|)    
	## (Intercept)   28.493      1.580   18.04 5.88e-09 ***
	## x            130.835      9.683   13.51 9.50e-08 ***
	## ---
	## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1
	## 
	## Residual standard error: 1.319 on 10 degrees of freedom
	## Multiple R-squared:  0.9481,    Adjusted R-squared:  0.9429 
	## F-statistic: 182.6 on 1 and 10 DF,  p-value: 9.505e-08
anova(fit)
	##Analysis of Variance Table
	##
	##Response: y
	##			#Df Sum Sq Mean Sq F value    Pr(&gt;F)    
	##x          1 317.82  317.82  182.55 9.505e-08 ***
	##Residuals 10  17.41    1.74                      
	##---
	##Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

</code></pre>
</div>

<h3 id="section-5">线性模拟各参数的提取</h3>

<div class="highlighter-rouge"><pre class="highlight"><code># 可以通过names函数查看summary(fit)中个具体参数的提取方法
names(summary(fit))
# 提取R square
summary(fit)$r.squared ## 依照该形式可以提取names(summary(fit))中任意指标
# 其它常用指标的提取
# 提取模型lm或glm提取回归系数
coefficients(fit)
# 还可简化为
coef(fit)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
resid(fit)
# 提取lm或glm对象中残差的平方和
deviance(fit)
# 提取lm或glm对象中的方差分析表
# 其中p值越小，差异越显著, beita1越不可能为0
anova(fit)
# 预测数据
new &lt;- data.frame(x=c(0.16, 2.3))
predict(fit, new)

## 也可以做出预测区间
predict(fit, new, interval = 'prediction', levels = 0.95)
</code></pre>
</div>

<h3 id="section-6">线性模拟各参数中各量的算法</h3>

<h4 id="section-7">五个和的计算</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 预备统计量(Sums of square and sums of producte)
Sx = sum(x)
Sy = sum(y)
Sxx = sum((x - mean(x))^2)
Syy = sum((y - mean(y))^2)
Sxy = sum((x - mean(x)) * (y - mean(y)))

## 这里仅仅作为补充,具体原因不是很清楚
Syy = deviance(lm(y~1))
n = length(x)
</code></pre>
</div>

<h4 id="section-8">回归系数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 回归系数$\alpha$和$beta$（这样计算，residuals有最小值)
beta = Sxy/Sxx
beta
alpha = mean(y) - beta*mean(x)
alpha
# 提取lm或glm对象中的回归系数
coef(fit)
</code></pre>
</div>

<h4 id="section-9">残差及五分位数</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>residuals = y - (beta + alpha * x)
residuals
quantile(residuals)
# 提取模型lm或glm的残差
# 也可简化为
residuals(fit)
</code></pre>
</div>

<h4 id="pearsonr-1">Pearson相关系数r</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>r = sqrt(Sxy/(Sxx * Syy))
r
</code></pre>
</div>

<h4 id="r-1">R平方</h4>
<p>决定系数，其值为 回归的平方和/总的平方和。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>rsquare = (Syy - sum(residuals^2))/Syy
rsquare
</code></pre>
</div>

<h4 id="adjust-r">adjust R平方</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>## 考虑到了自变量的个数, 包括截距在内, 本例子中k = 2
n = length(x)
k = 2
adjustrsquare = 1- (1-rsquare)*(n-1)/(n-k)
adjustrsquare
</code></pre>
</div>

<h3 id="f">回归方程的F检验</h3>
<p>在简单线性回归的模型，我们可以在<script type="math/tex">β = 0</script>时，对F统计量进行检验。
在F检验中统计量F</p>

<script type="math/tex; mode=display">F = \frac{(回归的平方和/回归的自由度)}{(误差的平方和/误差的自由度}</script>

<p>对应p值越小，说明此时越小的概率时间发生了，越不能接受原假设。</p>

<h3 id="t">斜率β的t检验</h3>
<p>在简单线性回归的模型，我们可以检验回归系数(斜率)β是否相等于特定的$β_0$(通常使$β_0 = 0$以检验$x_i$对$y_i$是否有关联)。
统计量t</p>

<p><img src="http://xukuang.github.io/blog/images/student_t.png" alt="" />
在零假设为$β = β_0$的情况下服从自由度为n − 2之t分布，其中</p>

<p><img src="http://xukuang.github.io/blog/images/student_se.png" alt="" />
同F检验一样，p值越小，说明此时越小的概率事件发生了，越不能接受原假设。</p>

<h2 id="section-10">话外篇</h2>
<p>在R中，lm(y ~ x)和lm(y ~ x + 1)的效果是相同的。此外，lm(y ~ 1)中截距的估计值为y的平均值，残差为每个y与均值的离差。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>离散型随机变量的常用统计指标</title>
      <link>http://xukuang.github.io/blog/2016/04/moment-in_statistics/</link>
      <pubDate>2016-04-06T16:25:50-06:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/04/moment-in_statistics</guid>
      <content:encoded><![CDATA[<h2 id="section">期望</h2>

<script type="math/tex; mode=display">E[X] = \sum_{i=1}^n x_i</script>

<p>期望存在一下特性:</p>

<p>1.<script type="math/tex">E[aX + bY] = aE[X] + bE(Y)</script></p>

<p>2.一般情况下，<script type="math/tex">E[X Y] \neq E[X]E(Y)</script>；当X和Y相互独立时，才有<script type="math/tex">E[X Y] = E[X]E(Y)</script></p>

<h2 id="section-1">方差</h2>
<p>方差描述的是随机变量的离散程度，也就是该变量离其期望值的距离。</p>

<script type="math/tex; mode=display">Var(X) = E[(X -E[X])^2] = E[X^{2} - 2X E[X] + (E[X])^{2}] = E[X^{2}] - (E[X])^{2}</script>

<p>此外，方差还可以看作是随机变量和自身的协方差<script type="math/tex">Var(X) = Cov(X, X)</script>。</p>

<h2 id="section-2">标准差</h2>
<p>标准差是一组数值自平均值分散开来的程度的一种测量观念。</p>

<p>总体的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N}}</script>

<p>样本的标准差</p>

<script type="math/tex; mode=display">SD = \sqrt{\frac{Var(x)}{N - 1}}</script>

<h2 id="section-3">标准误</h2>
<p>标准误差针对样本统计量而言，是某个样本统计量的标准差。当谈及标准误差时，一般须指明对应的样本统计量才有意义。以下以样本均值（样本均值是一种样本统计量）作为例子。于是，假设可以从总体中随机选取无限的大小相同的样本，那每个样本都可以有一个样本均值。依此法可以到一个由无限多样本均值组成的总体，该总体的标准差即为标准误差。</p>

<script type="math/tex; mode=display">SE = \frac{SD}{\sqrt{N}}</script>

<h2 id="section-4">协方差</h2>
<p>协方差用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情况。</p>

<script type="math/tex; mode=display">Cov(X, Y) = E((X - E[X])(Y - E(Y)) = E[XY] - E[X] E[Y]</script>

<p>协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。如果X与Y是统计独立的，那么二者之间的协方差就是0，但是反过来并不成立，即如果X与Y的协方差为0，二者并不一定是统计独立的。</p>

<h2 id="section-5">协方差的相关性η(线性相关)</h2>

<script type="math/tex; mode=display">\eta =  \frac{cov(X, Y)}{\sqrt{var(X) \cdot var(Y)}}</script>

<p>协方差的相关性η更准确地说是线性相关的相关系数r，是一个衡量线性独立的无量纲数，其取值在[－1,+1]之间。相关性η = 1时称为“完全线性相关”(相关性η = -1时称为“完全线性负相关”)，此时将<script type="math/tex">Y_{i}</script>对<script type="math/tex">X_{i}</script>作Y-X散点图，将得到一组精确排列在直线上的点；相关性数值介于－1到1之间时，其绝对值越接近1表明线性相关性越好，作散点图得到的点的排布越接近一条直线。相关性为0(因而协方差也为0)的两个随机变量又被称为是不相关的，或者更准确地说叫作“线性无关”、“线性不相关”，这仅仅表明X 与Y两随机变量之间没有线性相关性，并非表示它们之间一定没有任何内在的（非线性）函数关系，和前面所说的“X、Y二者并不一定是统计独立的”说法一致。</p>

<p>-—–</p>

<p><strong>本篇文章整理自维基百科。</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>用R进行文件系统管理</title>
      <link>http://xukuang.github.io/blog/2016/03/docement-mangement/</link>
      <pubDate>2016-03-01T10:24:47-07:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/03/docement-mangement</guid>
      <content:encoded><![CDATA[<p>学习中，已经体会到了R在数据处理方面的厉害，偶然看到张丹的博文<a href="http://blog.fens.me/r-file-folder/">《用R进行文件系统管理》</a>，发现R居然还可以进行文件系统的管理，又一次全新的认识了世界（其实主要是R）。这里基本上是把张丹的文章照搬过来了，只是加了少许自己学习时心得。本文中提到的文件系统管理主要是指文件和目录（即文件夹）的创建、查看、重命名、复制、删除和文件权限处理。</p>

<h2 id="section">文件操作</h2>

<ul>
  <li>创建文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 创建一个空文件 A.txt
file.create("A.txt")
# 查看当前目录下的子目录和文件
list.files()

# 创建多个空文件 A1.txt，A2.txt，A3.txt
file.create("A1.txt", "A2.txt", "A3.txt")
# 查看当前目录下的子目录和文件
list.files()

# 创建一个有内容的文件 B.txt
cat("文件测试\n", file = "B.txt")
list.files()
</code></pre>
</div>

<ul>
  <li>查看文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 显示当前目录中的目录和文件

## 下面两句结果相同
list.files() # 建议使用该命令，方便记忆
dir()


## 参数full.names = TRUE，确定文件显示全名

## 参数recursive = TRUE，递归显示，即把目录下的目录和文件都以文件的形式显示
list.files(, full.names = TRUE, recursive = TRUE)

# 检查文件是否存在

## 存在的文件
file.exists("A.txt")

## 不存在的文件
file.exists("readme.txt")

# 判断是否是文件
file_test("-f", "A.txt")
</code></pre>
</div>
<!--more-->

<ul>
  <li>读取文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 文件A.txt读取
readLines("A.txt")

# 文件B.txt读取
readLines("B.txt")
</code></pre>
</div>

<ul>
  <li>文件重命名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 给文件A.txt重命名为AA.txt
file.rename("A.txt","AA.txt")
list.files()
</code></pre>
</div>

<ul>
  <li>复制文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.copy("B.txt", "C.txt")
# 查看文件内容
readLines("C.txt")
</code></pre>
</div>

<ul>
  <li>追加文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.append("A.txt", rep("B.txt", 10))
# 查看文件内容
readLines("A.txt") 
</code></pre>
</div>

<ul>
  <li>删除文件</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 新建文件
file.create("tempa1", "tempa2", "tempa3", "tempa4")
list.files()
# 删除文件
file.remove("tempa1", "tempa2", "tempa3", "tempa4")
list.files()
</code></pre>
</div>

<ul>
  <li>文件权限</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看文件完整信息
file.info("A.txt")

# 查看文件访问权限
# 0表示有相关权限
# 1表示没有相关权限

## 是否存在
file.access("A.txt",0)

## 是否可执行
file.access("A.txt",1)

## 是否可写
file.access("A.txt",2)

## 是否可读
file.access("A.txt",4)

# 文件权限修改

## 查看文件信息
file.info("A.txt")

## 修改文件权限，创建者可读可写可执行，其他人无权限
Sys.chmod("A.txt", mode = "0400", use_umask = TRUE)

## 查看文件信息
file.info("A.txt")
</code></pre>
</div>

<h2 id="section-1">目录操作</h2>

<ul>
  <li>创建目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 新建一个目录
dir.create("test") # 不能同时创建多个目录
list.dirs()

# 递归创建
dir.create("test/test",recursive = TRUE)
list.dirs()
</code></pre>
</div>

<ul>
  <li>查看目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看当前默认目录的一级目录和文件
list.files() # 同时会显示目录下的文件
dir()

# 查看当前默认目录的子目录

## 默认递归显示各级子目录
list.dirs()

## 只显示一级子目录
list.dirs(recursive= FALSE)

# 通过系统命令查看目录结构
system("tree")

# 检查目录是否存在
# 存在的目录
file.exists(".")
file.exists("./test")

# 不存在的目录
file.exists("./test1")

# 判断是否是目录

## 下面两个语句结果相同
file_test("-d", "./test")
file_test("-d", "test")
</code></pre>
</div>

<ul>
  <li>目录重命名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看目录
dir()

# 对test目录重命名
file.rename("test", "test1")

# 查看目录
dir()

# 目录重命名
file.rename("test1", "test")
</code></pre>
</div>

<ul>
  <li>删除目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dir.create('temp')
dir.create('temp1/temp1', recursive = TRUE)
dir()

# 删除temp目录
unlink("temp", recursive = TRUE) # unlink也可用来删除文件，此时不需要设置参数recursive
dir()

unlink("temp1", recursive = TRUE) # 
dir()
</code></pre>
</div>

<ul>
  <li>目录的权限</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 查看目录完整信息
file.info(".")

# 检查目录的权限
df&lt;-dir(full.names = TRUE)

# 检查文件或目录是否存在，mode=0
file.access(df, 0) == 0

# 检查文件或目录是否可执行，mode=1，目录为可以执行
file.access(df, 1) == 0

# 检查文件或目录是否可写，mode=2
file.access(df, 2) == 0

# 检查文件或目录是否可读，mode=4
file.access(df, 4) == 0

# 修改目录权限，所有用户只读
Sys.chmod("./test", mode = "0555", use_umask = TRUE)
file.info("./test")
</code></pre>
</div>

<h2 id="section-2">其他功能函数</h2>

<ul>
  <li>拼接目录字符串</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>file.path("p1","p2","p3")
</code></pre>
</div>

<ul>
  <li>所在目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dirname("/home/conan/R/fs/readme.txt")
</code></pre>
</div>

<ul>
  <li>最底层子目录或文件名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>basename("/home/conan/R/fs/readme.txt")
basename("/home/conan/R/fs")
</code></pre>
</div>

<ul>
  <li>win下标准路径转化</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>normalizePath(c(R.home(), tempdir()))
</code></pre>
</div>

<ul>
  <li>短路径，缩减路径的显示长度，只在win中运行</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>shortPathName(c(R.home(), tempdir()))
</code></pre>
</div>

<h2 id="section-3">几个特殊的目录</h2>

<p><strong>R.home()</strong> 查看R软件的相关目录</p>

<p><strong>.Library</strong> 查看R核心包的目录</p>

<p>**.libPaths() ** 查看R所有包的存放目录</p>

<p><strong>ystem.file()</strong> 查看指定包所在的目录</p>

<ul>
  <li>R软件的相关目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># R.home() 查看R软件的相关目录

## 打印R软件安装目录
R.home()

## 打印R软件bin的目录
R.home(component="bin")

## 打印R软件文件的目录
R.home(component="doc")
</code></pre>
</div>

<ul>
  <li>R软件的包目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 打印核心包的目录
.Library
# 打印所有包的存放目录
.libPaths()
</code></pre>
</div>

<ul>
  <li>查看指定包所在的目录</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># base包的存放目录
system.file()
# dplyr包的存放目录
system.file(package = "dplyr")
</code></pre>
</div>

<h2 id="section-4">小结</h2>
<p>正如张丹所说，用R语言操作文件系统还是很方便的，但其对于函数命名不太规范,比如文件和目录的操作函数名有时区分，有时又不区分。最后，对文件和目录的操作进行简单的小结以方便自己的记忆。</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">操作名称</th>
      <th style="text-align: center">文件操作</th>
      <th style="text-align: right">目录操作</th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">创建</td>
      <td style="text-align: center">file.create()</td>
      <td style="text-align: right">dir.create()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">查看</td>
      <td style="text-align: center">list.files()</td>
      <td style="text-align: right">list.dirs()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">读取</td>
      <td style="text-align: center">readLines()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">重命名</td>
      <td style="text-align: center">file.rename()</td>
      <td style="text-align: right">file.rename()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">复制</td>
      <td style="text-align: center">file.copy()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">追加</td>
      <td style="text-align: center">file.append()</td>
      <td style="text-align: right">-</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">删除</td>
      <td style="text-align: center">file.remove()</td>
      <td style="text-align: right">unlink()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限查看</td>
      <td style="text-align: center">file.info()</td>
      <td style="text-align: right">file.info()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限查看</td>
      <td style="text-align: center">file.access()</td>
      <td style="text-align: right">file.access()</td>
      <td> </td>
    </tr>
    <tr>
      <td style="text-align: center">权限修改</td>
      <td style="text-align: center">Sys.chomod()</td>
      <td style="text-align: right">Sys.chomod()</td>
      <td> </td>
    </tr>
  </tbody>
</table>
]]></content:encoded>
    </item>
    
    <item>
      <title>R中的文本处理</title>
      <link>http://xukuang.github.io/blog/2016/02/char-in-R/</link>
      <pubDate>2016-02-27T10:14:59-07:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/02/char-in-R</guid>
      <content:encoded><![CDATA[<!--
* 目录{:toc}
-->
<blockquote>
  <p>处理文本是每一种计算机语言都应该具备的功能，但不是每一种语言都侧重于处理文本。R语言是统计的语言，处理文本不是它的强项。尽管R语言处理文本的能力不够强，但适当使用可以大幅提高工作效率的，而且有些文本操作还不得不用。高效处理文本少不了正则表达式（regular expression），虽然R在这方面先天不高效，但其中处理文本的绝大多数函数都支持正则表达式。</p>
</blockquote>

<h2 class="no_toc" id="section">正则表达式</h2>

<p>正则表达式是用于描述和匹配一个文本集合的表达式。它不是R的专属内容，这里也只简单介绍，更详细的内容请查阅其他文章。<!--more--></p>

<ol>
  <li>所有英文字母、数字和很多可显示的字符本身就是正则表达式，用于匹配它们自己。比如 ‘a’ 就是匹配字母 ‘a’ 的正则表达式</li>
  <li>一些特殊的字符在正则表达式中被“转义”不在用来描述它自身，这些字符称为“元字符”。常见元字符的意义如下:
    <ul>
      <li>\^放在表达式开始处表示匹配文本开始位置，放在方括号内开始处表示非方括号内的任一字符</li>
      <li>$ 匹配一个字符串的结尾</li>
      <li>点号. 表示除了换行符以外的任一字符</li>
      <li>* 表示将其前的字符进行0个或多个的匹配</li>
      <li>.* 可以匹配任意字符</li>
      <li>+ 匹配1或多个正好在它之前的那个字符</li>
      <li>? 匹配0或1个正好在它之前的那个字符</li>
      <li>大括号{}表示前面的字符或表达式的重复次数</li>
      <li>方括号[]表示选择方括号中的任意一个（如[a-z] 表示任意一个小写字符）</li>
      <li>| 表示可选项，即| 前后的表达式任选一个</li>
    </ul>
  </li>
  <li>
    <p>如果要在正则表达式中表示元字符本身，比如我就要在文本中查找问号‘?’，那么就要使用引用符号（或称换码符号），一般是反斜杠 ‘'。需要注意的是，在R语言中得用两个反斜杠即 ‘\\’，如要匹配括号就要写成 ’\\(\\)‘</p>
  </li>
  <li>不同语言或应用程序（事实上很多规则都通用）定义了一些特殊的元字符用于表示某类字符，如 :
    <ul>
      <li>\d 表示数字0-9，\D 表示非数字</li>
      <li>\s 表示空白字符（包括空格、制表符、换行符等），\S 表示非空白字符，</li>
      <li>\w 表示字（字母和数字），\W 表示非字</li>
      <li>\&lt; 和 \&gt; 分别表示以空白字符开始和结束的文本
 需要注意的是，反斜杠 ‘\‘在R语言中得用两个反斜杠即 ‘\\’，如’\s’就要写成 ’\\s‘。</li>
    </ul>
  </li>
  <li>正则表达式符号运算顺序：圆括号括起来的表达式最优先，然后是表示重复次数的操作(即：* + {} )，接下来是连接运算（其实就是几个字符放在一起，如abc），最后是表示可选项的运算(|)。所以’foot|bar’ 可以匹配’foot‘或者’bar‘，但是 ‘foot|ba{2}r’匹配的是’foot‘或者’baar‘。</li>
  <li>“贪婪”和“懒惰”的匹配规则。默认情况下是匹配尽可能多的字符，是为贪婪匹配，比如 “a.*b”默认匹配最长的a开头b结尾的字串，也就是整个字符串。如果要进行懒惰匹配，也就是匹配最短的字串，只需要在后面加个 ?，比如 “a.*?b”，就会匹配最开始找到的最短的a开头b结尾的字串</li>
</ol>

<h2 id="section-1">文本处理</h2>

<h3 id="section-2">字符数统计</h3>
<p>函数nchar，统计向量中每个元素的字符个数，注意这个函数和length函数的差别：length是向量长度（向量元素的个数）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x &lt;- c("Hellow", "World", "!") 
nchar(x); length(x)
	# [1] 6 5 1 
	# [1] 3
length(''); nchar('') 
	# [1] 1 
	# [1] 0 
</code></pre>
</div>

<h3 id="section-3">字符大小写转化</h3>

<ul>
  <li>函数tolower，将向量中的元素转化为小写字母</li>
  <li>函数toupper，将向量中的元素转化为大写字母</li>
  <li>函数casefold，将向量中的元素转化为小或大写字母（upper = F，转化为小写；upper = T，转化为大写）</li>
  <li>函数chartr，按指定的规则进行转换</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>tolower(x)
	# [1] "hellow" "world"  "!"  
toupper(x)
	# [1] "HELLOW" "WORLD"  "!" 
casefold(x) # 默认upper = F
	# [1] "hellow" "world"  "!" 
casefold(x, upper = T)
	# [1] "HELLOW" "WORLD"  "!"  

chartr('ol', 'pm', x) # o转化为p，l转化为m
	# "Hemmpw" "Wprmd"  "!"
	
DNA &lt;- "AtGCtttACC" # DNA为长度为1的字符向量
tolower(DNA) 
	# [1] "atgctttacc" 
toupper(DNA) 
	# [1] "ATGCTTTACC" 
chartr("Tt", "Uu", DNA) # T转化为U，t转化为u
	# [1] "AuGCuuuACC" 
chartr("Tt", "UU", DNA) 
	# [1] "AUGCUUUACC"
</code></pre>
</div>

<h3 id="section-4">字符串连接</h3>
<p>函数paste应该是R中最常用字符串函数了，也是R字符串处理函数里面非常纯的不使用正则表达式的函数（因为用不着）。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>paste("CK", 1:6, sep = "")
	# [1] "CK1" "CK2" "CK3" "CK4" "CK5" "CK6"
x &lt;- list(a = "aaa", b = "bbb", c = "ccc")
y &lt;- list(d = 1, e = 2)
paste(x, y, sep = "-")  #较短的向量被循环使用
	# [1] "aaa-1" "bbb-2" "ccc-1"
</code></pre>
</div>
<p>paste函数还有一个用法，设置collapse参数，连成一个字符串。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>paste(x, y, sep = "-", collapse = "; ")
	# [1] "aaa-1; bbb-2; ccc-1"
paste(x, collapse = "; ")
	# [1] "aaa; bbb; ccc"
</code></pre>
</div>

<h3 id="section-5">字符串拆分</h3>

<p>strsplit函数使用正则表达式，使用格式为:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)
</code></pre>
</div>

<ul>
  <li>参数x为字串向量，每个元素都将单独进行拆分。</li>
  <li>参数split为拆分位置的字串向量，</li>
  <li>默认为正则表达式匹配（fixed=FALSE）。如果你没接触过正则表达式，设置fixed=TRUE，表示使用普通文本匹配或正则表达式的精确匹配。普通文本的运算速度快。</li>
  <li>参数perl=TRUE/FALSE的设置和perl语言版本有关，如果正则表达式很长，正确设置表达式并且使用perl=TRUE可以提高运算速度。</li>
  <li>参数useBytes设置是否逐个字节进行匹配，默认为FALSE，即按字符而不是字节进行匹配。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>text &lt;- "Hello Adam!\nHello Ava!"
strsplit(text, " ") # R语言的字符串事实上也是正则表达式，文本中的\n在图形输出中是被解释为换行符的。
	# [[1]]
	# [1] "Hello"        "Adam!\nHello" "Ava!"
strsplit(text, "\\s")
	# [[1]]
	# [1] "Hello" "Adam!" "Hello" "Ava!"
</code></pre>
</div>

<p>strsplit得到的结果是列表，后面要怎么处理就得看情况而定了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>class(strsplit(text, "\\s"))
	# [1] "list"
</code></pre>
</div>
<p>有一种情况很特殊，如果split参数的字符长度为0，得到的结果就是一个个的字符。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strsplit(text, "")
	# [[1]]
	#  [1] "H"  "e"  "l"  "l"  "o"  " "  "A"  "d"  "a"  "m"  "!"  "\n" "H"  "e" 
	# [15] "l"  "l"  "o"  " "  "A"  "v"  "a"  "!"
</code></pre>
</div>
<p>从这里也可以看到R把 \n 是当成一个字符来处理的。</p>

<h3 id="section-6">字符串查询和替换</h3>
<p>R中字符串的查询函数有：grep、grepl、regexpr、gregexpr和regexpr，字符串的替换函数有sub和gsub。</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 字符串查询
grep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,
     fixed = FALSE, useBytes = FALSE, invert = FALSE)

grepl(pattern, x, ignore.case = FALSE, perl = FALSE,
      fixed = FALSE, useBytes = FALSE)

regexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
        fixed = FALSE, useBytes = FALSE)

gregexpr(pattern, text, ignore.case = FALSE, perl = FALSE,
         fixed = FALSE, useBytes = FALSE)

regexec(pattern, text, ignore.case = FALSE,
        fixed = FALSE, useBytes = FALSE)
# 字符串替换
sub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
    fixed = FALSE, useBytes = FALSE)
## sub函数会根据pattern的规则对x中各元素进行搜索，遇到符合条件的第一个子字符串的位置，用replacement替换该子字符串，返回替换后的结果，和x的结构相同
gsub(pattern, replacement, x, ignore.case = FALSE, perl = FALSE,
     fixed = FALSE, useBytes = FALSE)
## gsub函数会根据pattern的规则对x中各元素进行搜索，找出所有符合条件的子字符串的位置，用replacement替换该子字符串，返回替换后的结果，和x的结构相同	 
</code></pre>
</div>

<p>这几个函数有相似的格式，都使用正则表达式的规则进行匹配。默认是egrep的规则，也可以选用Perl语言的规则。</p>

<ul>
  <li>pattern为字符串表示正则表达式</li>
  <li>replacement也是字符串表示替换的内容</li>
  <li>x为字符型向量表示被替换的字符向量</li>
  <li>参数ignore.case = FALSE，表示大小写敏感</li>
  <li>参数extended = TRUE，表示使用egrep规则</li>
  <li>perl = FALSE，表示不使用Perl规则</li>
  <li>fixed = FALSE，表示不使用精确匹配</li>
  <li>useBytes = FALSE，表示按字符匹配</li>
</ul>

<h4 id="section-7">字符串查询</h4>
<p>grep和grepl函数这两个函数返回向量水平的匹配结果，不涉及匹配字符串的详细位置信息。此外，尽管这两个函数的参数看起来差不多，但是返回结果的形式并不一样。	
regexpr、gregexpr和regexpr这三个函数返回的结果包均含了匹配的具体位置和字符串长度信息，只是他们的结果显示方式不同。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text &lt;- c("Hellow, Adam!", "Hi, Paul!", "How are you, Adam.")
grep("Adam", text)
	# [1] 1 3
grepl("Adam", text)
	# [1]  TRUE FALSE  TRUE
regexpr("Adam", text)
	# [1]  9  -1 14
	# attr(,"match.length")
	# [1] 4 -1 4
	# attr(,"useBytes")
	# [1] TRUE
gregexpr("Adam", text)
	# [[1]]
	# [1] 9
	# attr(,"match.length")
	# [1] 4
	# attr(,"useBytes")
	# [1] TRUE
	# 
	# [[2]]
	# [1] -1
	# attr(,"match.length")
	# [1] -1
	# attr(,"useBytes")
	# [1] TRUE
	# 
	# [[3]]
	# [1] 14
	# attr(,"match.length")
	# [1] 4
	# attr(,"useBytes")
	# [1] TRUE
regexec("Adam", text)
	# [[1]]
	# [1] 9
	# attr(,"match.length")
	# [1] 4
	# 
	# [[2]]
	# [1] -1
	# attr(,"match.length")
	# [1] -1
	# 
	# [[3]]
	# [1] 14
	# attr(,"match.length")
	# [1] 4
</code></pre>
</div>

<h4 id="section-8">字符串替换</h4>
<p>尽管sub和gsub是用于字符串替换的函数，但严格地说R语言没有字符串替换的函数，因为R语言不管什么操作对参数都是传值不传址。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text
	# [1] "Hellow, Adam!"      "Hi, Paul!"          "How are you, Adam."
sub(pattern = "Adam", replacement = "world", text)
	# [1] "Hellow, world!"      "Hi, Paul!"          "How are you, world."
text
	# [1] "Hellow, Adam!"      "Hi, Paul!"          "How are you, Adam."
</code></pre>
</div>
<p>可以看到：虽然说是“替换”，但原字符串并没有改变，要改变原变量我们只能通过再赋值的方式。 sub和gsub的区别是前者只做一次替换（不管有几次匹配），而gsub把满足条件的匹配都做替换。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>text1 = c("Hellow, Adam!", "Hi, Paul!", "How are you, Adam, Ava.")
sub(pattern = "Adam|Ava", replacement = "world", text1)
	# [1] "Hellow, world!"      "Hi, Paul!"          "How are you, world, Ava."
gsub(pattern = "Adam|Ava", replacement = "world", text1)
	# [1] "Hellow, world!"      "Hi, Paul"          "How are you, world, world."
</code></pre>
</div>

<p>sub和gsub函数可以使用提取表达式（转义字符+数字）让部分变成全部：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sub(pattern = ".*(Adam).*", replacement = "Hi, \\1", text)
	# [1] "Hi, Adam"  "Hi, Paul!" "Hi, Adam" 
</code></pre>
</div>

<h2 id="section-9">字符串提取</h2>
<p>substr和substring函数通过位置进行字符串拆分或提取，它们本身并不使用正则表达式，但是结合正则表达式函数regexpr、gregexpr或regexec使用可以非常方便地从大量文本中提取所需信息。两者的参数设置基本相同，但它们的返回值的长度（个数）有差别：substr返回的字串个数等于第一个参数的长度，而substring返回字串个数等于三个参数中最长向量长度，短向量循环使用。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>substr(x, start, stop)
substring(text, first, last = 1000000L)
</code></pre>
</div>

<ul>
  <li>x均为要拆分的字串向量</li>
  <li>start/first 为截取的起始位置向量</li>
  <li>stop/last 为截取字串的终止位置向量</li>
</ul>

<p>先看第1参数（要拆分的字符向量）长度为1例子。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x &lt;- "123456789"
substr(x, c(2, 4), c(4, 5, 8))
	# [1] "234"
substring(x, c(2, 4), c(4, 5, 8))
	# [1] "234"     "45"      "2345678"
</code></pre>
</div>
<p>因为x的向量长度为1，所以substr获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。 而substring的语句三个参数中最长的向量为c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。</p>

<h3 id="section-10">字符串的整理</h3>

<ul>
  <li>strtrim 函数</li>
</ul>

<p>该函数用于将字符串修剪到特定的显示宽度，其用法为，</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strtrim(x,width)
</code></pre>
</div>
<p>返回字符串向量的长度等于x的长度。因为是“修剪”，所以只能去掉多余的字符不能增加其他额外的字符：如果字符串本身的长度小于width，得到的是原字符串，别指望它会用空格或其他什么字符补齐。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strtrim(c("abcdef", "abcdef", "abcdef"), c(1, 5, 10))
	# [1] "a"      "abcde"  "abcdef"
strtrim(c(1, 123, 1234567), 4)
	# [1] "1"    "123"  "1234"
</code></pre>
</div>

<ul>
  <li>strwrap函数</li>
</ul>

<p>该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>str1 &lt;- "Each character string in the input is first split into paragraphs\n(or lines containing whitespace only).  The paragraphs are then\nformatted by breaking lines at word boundaries.  The target\ncolumns for wrapping lines and the indentation of the first and\nall subsequent lines of a paragraph can be controlled\nindependently."
str2 &lt;- rep(str1, 2)
strwrap(str2, width = 80, indent = 2)
	#  [1] "  Each character string in the input is first split into paragraphs (or lines"
	#  [2] "containing whitespace only).  The paragraphs are then formatted by breaking"  
	#  [3] "lines at word boundaries.  The target columns for wrapping lines and the"     
	#  [4] "indentation of the first and all subsequent lines of a paragraph can be"      
	#  [5] "controlled independently."                                                    
	#  [6] "  Each character string in the input is first split into paragraphs (or lines"
	#  [7] "containing whitespace only).  The paragraphs are then formatted by breaking"  
	#  [8] "lines at word boundaries.  The target columns for wrapping lines and the"     
	#  [9] "indentation of the first and all subsequent lines of a paragraph can be"      
	# [10] "controlled independently."
</code></pre>
</div>

<p>simplify参数用于指定结果的返回样式，默认为TRUE，即结果中所有的字符串都按顺序放在一个字符串向量中（如上）；如果为FALSE，那么结果将是列表。另外一个参数exdent用于指定除第一行以外的行缩进。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>strwrap(str1, width = 80, indent = 0, exdent = 2)
	# [1] "Each character string in the input is first split into paragraphs (or lines"  
	# [2] "  containing whitespace only).  The paragraphs are then formatted by breaking"
	# [3] "  lines at word boundaries.  The target columns for wrapping lines and the"   
	# [4] "  indentation of the first and all subsequent lines of a paragraph can be"    
	# [5] "  controlled independently."
</code></pre>
</div>

<ul>
  <li>match和charmatch函数</li>
</ul>

<p>这两个函数用于字符的匹配。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>match("xx", c("abc", "xx", "xxx", "xx"))
	# [1] 2
match(2, c(3, 1, 2, 4))
	# [1] 3
charmatch("xx", "xx")
	# [1] 1
charmatch("xx", "xxa")
	# [1] 1
charmatch("xx", "axx")
	# [1] NA
</code></pre>
</div>
<p>match按向量进行运算，返回第一次匹配的元素的位置（如果有），非字符向量也可用。正如原作者说的那样，charmatch函数真太坑爹了，不建议使用。</p>

<p>-—–</p>

<p><strong>参考文章</strong></p>

<ol>
  <li>R语言进阶之二：文本（字符串）处理与正则表达式（这篇文章在许多网站都有转载，然而原创链接失效了）</li>
  <li><a href="http://jianl.org/2010/02/14/2010-02-14-R%E4%B8%AD%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E4%BB%8B/">R中正则表达式简介</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>长宽数据之间的转化(一)</title>
      <link>http://xukuang.github.io/blog/2016/01/melt-and-dcast/</link>
      <pubDate>2016-01-18T03:32:19-07:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/01/melt-and-dcast</guid>
      <content:encoded><![CDATA[<p>这里将数据框分为两种：宽数据和长数据，宽数据便于数据成果的展示，长数据则便于数据在R中进行分析。reshape2包中的melt函数可以实现宽数据向长数据的转换，而dcast可以实现宽数据向长数据的转化。</p>

<h2 id="section">宽数据转化为长数据</h2>

<h3 id="melt">melt函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>melt(data, id.vars, measure.vars,
  variable.name = "variable", ..., na.rm = FALSE, value.name = "value",
  factorsAsStrings = TRUE)
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>id.vars</strong> 数据的转化标准：依照那些列进行转化，数据格式为字符型或数字型的向量。如果该参数没有限定，会把所有数据转化为两列，其中指标一列，数据一列。</p>

<p><strong>measure.vars</strong>	被转化的数据：将哪些列数据值转化，该参数在没有指定的默认情况下，会将id.vars中以外的所有列数据进行转化，数据格式为字符型或数字型的向量</p>

<p><strong>variable.name</strong>	对转化后的数据标准列重新命名，默认情况下，列名为variable</p>

<p><strong>na.rm</strong> 是否去除数据中的NA，默认情况下为FALSE，不去除NA</p>

<p><strong>value.name</strong> 对转化后的数据列重新命名，默认情况下，列名为value</p>

<p><strong>factorsAsStrings</strong>	转化过程中是否将因子类型数据转化为字符型数据，默认情况下为TRUE，将因子类型数据转化为字符型数据
<!--more--></p>

<h3 id="section-1">实例</h3>

<ul>
  <li>按Month和Day列将其他指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code># 加载数据
library(reshape2)
head(airquality)
	#   Ozone Solar.R Wind Temp Month Day
	# 1    41     190  7.4   67     5   1
	# 2    36     118  8.0   72     5   2
	# 3    12     149 12.6   74     5   3
	# 4    18     313 11.5   62     5   4
	# 5    NA      NA 14.3   56     5   5
	# 6    28      NA 14.9   66     5   6
dim(airquality)	
	# [1] 153   6
dat1 = melt(airquality, id.vars = c('Month', 'Day'))
head(dat1)
	# 	Month Day variable value
	# 1     5   1    Ozone    41
	# 2     5   2    Ozone    36
	# 3     5   3    Ozone    12
	# 4     5   4    Ozone    18
	# 5     5   5    Ozone    NA
	# 6     5   6    Ozone    28
dim(dat1)
	# [1] 612   4
</code></pre>
</div>
<p>需要注意的是melt函数当中如果id.vars参数不指定值，则会把所有数据转化为两列输出。</p>

<ul>
  <li>按Month和Day列将Ozone和Solar.R列指标排成长数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dat2 = melt(airquality, id.vars = c('Month', 'Day'),
 measure = c('Ozone', 'Solar.R'))
head(dat2)
	# 	Month Day variable value
	# 1     5   1    Ozone    41
	# 2     5   2    Ozone    36
	# 3     5   3    Ozone    12
	# 4     5   4    Ozone    18
	# 5     5   5    Ozone    NA
	# 6     5   6    Ozone    28
dim(dat2) # 函数是dat1的1/2
	# [1] 306   4 
</code></pre>
</div>

<ul>
  <li>对排列后的数据进行重命名</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>dat3 = melt(airquality, id.vars = c('Month', 'Day'),
variable.name = 'type', value.name = 'value.type')
head(dat3) # 列名发生变化
	# 	Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 5     5   5 Ozone         NA
	# 6     5   6 Ozone         28
dim(dat3)
	# [1] 612   4
</code></pre>
</div>

<ul>
  <li>去除排列后数据中的NA</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>#　 airquality$Ozone 数的前四列有44 个NA
table(is.na(airquality$Ozone)) # 37
	# FALSE  TRUE 
	#   116    37 
table(is.na(airquality$Solar.R)) # 4
	# FALSE  TRUE 
	#   146     7 
table(is.na(airquality$Temp)) # 0
	# FALSE 
	#   153 
table(is.na(airquality$Wind)) # 0
	# FALSE 
	#   153 
dat4 = melt(airquality, id.vars = c('Month', 'Day'),
variable.name = 'type', value.name = 'value.type', na.rm = TRUE)
head(dat4)
	#   Month Day  type value.type
	# 1     5   1 Ozone         41
	# 2     5   2 Ozone         36
	# 3     5   3 Ozone         12
	# 4     5   4 Ozone         18
	# 6     5   6 Ozone         28
	# 7     5   7 Ozone         23
dim(dat4)# 比dat3少44行
	# [1] 568   4	
</code></pre>
</div>
<p>此外，还发现melt函数中所有参数名都可以只写’.’前的部分。</p>

<div class="highlighter-rouge"><pre class="highlight"><code>dat5 = melt(airquality, id = c('Month', 'Day'),
variable = 'type', value = 'value.type', na = TRUE)
head(dat5)
	# 	Month Day  type value
	# 1     5   1 Ozone    41
	# 2     5   2 Ozone    36
	# 3     5   3 Ozone    12
	# 4     5   4 Ozone    18
	# 5     5   5 Ozone    NA
	# 6     5   6 Ozone    28
</code></pre>
</div>

<h2 id="section-2">长数据转化为宽数据</h2>

<h3 id="dcast">dcast函数</h3>

<div class="highlighter-rouge"><pre class="highlight"><code>dcast(data, formula, fun.aggregate = NULL, ..., margins = NULL,
  subset = NULL, fill = NULL, drop = TRUE,
  value.var = guess_value(data))
</code></pre>
</div>

<p><strong>data</strong> 要转化的数据，数据格式为数据框类型或者可以转化为数据框类型</p>

<p><strong>formula</strong> 转化的标准，以公式的形式定义</p>

<p><strong>fun.aggregate</strong> 汇总函数。分类后，如果分类结果不唯一，就必须使用汇总函数。常用的汇总函数，包括求个数、和、平均值、标准差、方差，默认的为求个数</p>

<p><strong>margins</strong>	确定结果是否显示总的结果，默认不显示</p>

<p><strong>subset</strong> 是否只对某些标准内容进行计算，结合plyr包一起使用</p>

<p><strong>fill</strong> 不存在的组合值的显示结果。默认的显示为0。数据类型为数值型向量</p>

<p><strong>drop</strong> 确认不存在分分类组合是否显示，默认情况下显示</p>

<p><strong>value.var</strong> 貌似对对转化后的数据进行命名，使用默认情况即可</p>

<h3 id="section-3">实例</h3>

<ul>
  <li>每个分类结果有一个数据，此时不需要使用汇总函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">air1</span> <span class="o">=</span>  <span class="n">dcast</span><span class="p">(</span><span class="n">dat4</span><span class="p">,</span> <span class="n">Month</span> <span class="o">+</span> <span class="n">Day</span> <span class="o">~</span> <span class="n">type</span><span class="p">)</span>
<span class="n">dim</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span>
	<span class="c1"># [1] 153   6
</span><span class="n">head</span><span class="p">(</span><span class="n">air1</span><span class="p">)</span> <span class="c1"># 数据与airquality相同
</span>	<span class="c1"># 	Month Day Ozone Solar.R Wind Temp
</span>	<span class="c1"># 1     5   1    41     190  7.4   67
</span>	<span class="c1"># 2     5   2    36     118  8.0   72
</span>	<span class="c1"># 3     5   3    12     149 12.6   74
</span>	<span class="c1"># 4     5   4    18     313 11.5   62
</span>	<span class="c1"># 5     5   5    NA      NA 14.3   56
</span>	<span class="c1"># 6     5   6    28      NA 14.9   66
</span></code></pre>
</div>

<ul>
  <li>按Month列排成宽数据，每个分类结果有多个数据，必须有汇总函数</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>air2 =  dcast(dat4, Month ~ type, sum) # 这里使用sum函数
dim(air2)
	# [1] 5 5
head(air2)
	# 	Month Ozone Solar.R  Wind Temp
	# 1     5    NA      NA 360.3 2032
	# 2     6    NA    5705 308.0 2373
	# 3     7    NA    6711 277.2 2601
	# 4     8    NA      NA 272.6 2603
	# 5     9    NA    5023 305.4 2307
</code></pre>
</div>

<ul>
  <li>是否显示总的分类结果</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>air3 = dcast(dat4, Month ~ type, sum, margins = T) #列、行的总汇总都显示
dim(air3)
	# [1] 6 6
head(air3)
	#   Month Ozone Solar.R   Wind  Temp (all)
	# 1     5    NA      NA  360.3  2032    NA
	# 2     6    NA    5705  308.0  2373    NA
	# 3     7    NA    6711  277.2  2601    NA
	# 4     8    NA      NA  272.6  2603    NA
	# 5     9    NA    5023  305.4  2307    NA
	# 6 (all)    NA      NA 1523.5 11916    NA
dcast(dat4, Month ~ type, sum, margins = c('Month'))# 只显示列的汇总
	# 	Month Ozone Solar.R   Wind  Temp
	# 1     5    NA      NA  360.3  2032
	# 2     6    NA    5705  308.0  2373
	# 3     7    NA    6711  277.2  2601
	# 4     8    NA      NA  272.6  2603
	# 5     9    NA    5023  305.4  2307
	# 6 (all)    NA      NA 1523.5 11916
dcast(dat4, Month ~ type, sum, margins = c('type'))# 只显示行的汇总
	# 	Month Ozone Solar.R  Wind Temp (all)
	# 1     5    NA      NA 360.3 2032    NA
	# 2     6    NA    5705 308.0 2373    NA
	# 3     7    NA    6711 277.2 2601    NA
	# 4     8    NA      NA 272.6 2603    NA
	# 5     9    NA    5023 305.4 2307    NA
</code></pre>
</div>

<ul>
  <li>只显示部分的分类内容</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>library(plyr)
air4 = dcast(dat4, Month ~ type, sum, subset = .(type == 'Wind' )) # 只显示type中Wind的情况
dim(air4)
	# [1] 5 2
head(air4)
	# 	Month  Wind
	# 1     5 360.3
	# 2     6 308.0
	# 3     7 277.2
	# 4     8 272.6
	# 5     9 305.4
</code></pre>
</div>

<ul>
  <li>不存在的分类是否显示，以及怎么显示</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>air5 = dcast(dat4, Month + Day ~ type, length, drop = F) # 组合上存在的结果都显示
tail(air5) # 这里的最后一行只是组合上存在，数据中并不在
	# 		 Month Day Ozone Solar.R Wind Temp
	# 150      9  26     1       1    1    1
	# 151      9  27     1       1    1    1
	# 152      9  28     1       1    1    1
	# 153      9  29     1       1    1    1
	# 154      9  30     1       1    1    1
	# 155      9  31     0       0    0    0
tail(dcast(dat4, Month + Day ~ type, length, drop = F, fill= -1)) # 更改不存在结果的显示值，最后一行显示为-1
	# 		Month Day Ozone Solar.R Wind Temp
	# 150     9  26     1       1    1    1
	# 151     9  27     1       1    1    1
	# 152     9  28     1       1    1    1
	# 153     9  29     1       1    1    1
	# 154     9  30     1       1    1    1
	# 155     9  31    -1      -1   -1   -1
</code></pre>
</div>

]]></content:encoded>
    </item>
    
    <item>
      <title>数据合并-join函数</title>
      <link>http://xukuang.github.io/blog/2016/01/join-function/</link>
      <pubDate>2016-01-13T13:14:06-07:00</pubDate>
      <author>Xu Kuang</author>
      <guid>http://xukuang.github.io/blog/2016/01/join-function</guid>
      <content:encoded><![CDATA[<p>前面介绍了数据框合并的merge函数方法，其实还可以借助plyr和dplyr包中的join函数进行数据框的合并，它们数据框合并的原理同样是数据框的合并原理是这样的：首先在x表按指定列每一行的内容在y表的指定列都进行逐行匹配，直到x中所有行匹配完为止。</p>

<h2 id="section">数据说明</h2>
<p>这里的数据仍使用merge函数中的两个数据(略有修改)：作者信息数据和书籍信息数据。依照下面介绍的合并条件，这两个数据既有相同的内容，又有彼此中不存在的内容。</p>

<ul>
  <li>作者信息数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>authors &lt;- data.frame(
	id =  c(2, 4, 2, 5, 7, 8, 3),
	surname = I(c("Tukey", "Venables", 'kx', "Tierney", "Ripley", "McNeil", "kuangxu")),
	nationality = c("US", "Australia", 'China', "US", "UK", "Australia", "China"),
	deceased = c("yes", rep("no", 6)))
</code></pre>
</div>
<!--more-->
<p>为了区别数据，就把自己的名字也给安排进去了，唯一的一个中国人啊。</p>

<ul>
  <li>书籍信息数据</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>books &lt;- data.frame(
	id = c(1:7,2)
    name = I(c("Tukey", "Venables", "Tierney",
             "Ripley", "Ripley", "McNeil", "R Core", "kuang")),
    title = c("Exploratory Data Analysis",
              "Modern Applied Statistics ...",
              "LISP-STAT",
              "Spatial Statistics", "Stochastic Simulation",
              "Interactive Data Analysis",
              "An Introduction to R", "My R study"),
    other.author = c(NA, "Ripley", NA, NA, NA, NA,
                     "Venables &amp; Smith", NA))
</code></pre>
</div>

<h2 id="plyrjoin">plyr包的join函数</h2>
<p>join函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>join(x, y, by = NULL, type = 'left', match = 'all')
</code></pre>
</div>

<ul>
  <li>x,y 为合并的数据框</li>
  <li>by 为排序依据，默认值Null时按名字相同的量匹配,此时,要求必须有相同列名的列</li>
  <li>type为合并方式
    <ul>
      <li>inner，行：显示x，y中共有的行; 列：显示x，y中的所有列</li>
      <li>left，行：显示x中所有的行; 列：显示x，y中的所有列，未匹配到的值，不论字符数字，全显示为NA</li>
      <li>right，行：显示y中所有的行; 列：显示x，y中的所有列，未匹配到的值，不论字符数字，全显示为NA</li>
      <li>full，先显示x中所有的行在y中的匹配结果，接着显示y中未匹配上的内容</li>
    </ul>
  </li>
  <li>match匹配的规则
    <ul>
      <li>first，只匹配y中的第一个记录</li>
      <li>match，匹配y中所有记录</li>
    </ul>
  </li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>join(authors, books)
join(authors, books, type = 'left', match = 'first')
join(authors, books, type = 'inner')
join(authors, books, type = 'right')
join(authors, books, type = 'full')
</code></pre>
</div>

<h2 id="dplyrjoin">dplyr包的join函数</h2>
<p>dplyr包是plyr包的升级，join函数在dplyr包中是个系列函数。
join函数：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>join(x, y, by = NULL, copy = FALSE, ...)
</code></pre>
</div>

<ul>
  <li>x,y 为合并的数据框，不要求x,y中排序列唯一</li>
  <li>by 为排序依据，默认值Null时按名字相同的量匹配,此时,要求必须有相同列名的列</li>
  <li>join为系列函数，包括inner_join、left_join、semi_join和anti_join函数</li>
</ul>

<p>dplyr包的join函数似乎没有plyr包的join函数的match参数，只能进行所谓的all匹配</p>

<h3 id="innerjoin">inner_join函数</h3>
<p>函数结果, 行：显示x中所有能在y中匹配到行; 列：显示x，y中的所有列</p>

<div class="highlighter-rouge"><pre class="highlight"><code>library(dplyr)
# 单指标匹配
inner_join(authors, books)
inner_join(authors, books, by = c('surname' = 'name'))
# 多指标匹配
inner_join(authors, books, by = c('id'='id','surname' = 'name'))
</code></pre>
</div>

<h3 id="leftjoin">left_join函数</h3>

<p>结果, 行：显示x中所有的行; 列：显示x，y中的所有列，未匹配到的值，不论字符数字，全显示为NA。</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 单指标匹配
left_join(authors, books)
left_join(authors, books, by = c('surname' = 'name'))
# 多指标匹配
left_join(authors, books, by = c('id'='id','surname' = 'name'))
</code></pre>
</div>

<h3 id="semijoin">semi_join函数</h3>
<p>结果, 行：显示x中所有能在y匹配到行,并对显示结果按匹配依据进行了排序; 列：显示x中的所有列。
<code class="highlighter-rouge">
# 单指标匹配
semi_join(authors, books)
semi_join(authors, books, by = c('surname' = 'name'))
# 多指标匹配
semi_join(authors, books, by = c('id'='id','surname' = 'name'))
</code></p>

<h3 id="antijoin">anti_join函数</h3>
<p>结果, 行：显示x中所有未能在y中匹配到行, 并对显示结果按匹配依据进行了排序; 列：显示x中的所有列。</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 单指标匹配
anti_join(authors, books)
anti_join(authors, books, by = c('surname' = 'name'))
# 多指标匹配
anti_join(authors, books, by = c('id'='id','surname' = 'name'))
</code></pre>
</div>

<h3 id="fulljoin">full_join函数</h3>
<p>结果, 行：显示x, y中所有的行, 未匹配到的值，不论字符数字，全显示为NA。</p>

<div class="highlighter-rouge"><pre class="highlight"><code># 单指标匹配
full_join(authors, books)
full_join(authors, books, by = c('surname' = 'name'))
# 多指标匹配
full_join(authors, books, by = c('id'='id','surname' = 'name'))
</code></pre>
</div>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
